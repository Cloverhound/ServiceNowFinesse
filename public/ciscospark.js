(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
window.ciscospark = require('ciscospark')

},{"ciscospark":721}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

exports.default = evented;

var _common = require('@ciscospark/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var data = new ((0, _common.make)(_weakMap2.default, _map2.default))();

/**
 * Given a class property, this decorator changes it into a setter/getter pair;
 * the setter will trigger `change:${prop}` when invoked
 * @param {Object} target
 * @param {string} prop
 * @param {Object} descriptor
 * @returns {undefined}
 */
function evented(target, prop, descriptor) {
  var defaultValue = descriptor.initializer && descriptor.initializer();

  (0, _deleteProperty2.default)(descriptor, 'value');
  (0, _deleteProperty2.default)(descriptor, 'initializer');
  (0, _deleteProperty2.default)(descriptor, 'writable');

  descriptor.get = function get() {
    var value = data.get(this, prop);

    if (typeof value !== 'undefined') {
      return value;
    }

    return defaultValue;
  };

  descriptor.set = function set(value) {
    var previous = this[prop];
    if (previous !== value) {
      data.set(this, prop, value);
      this.trigger('change:' + prop, value, previous);
      this.trigger('change');
    }
  };
}


},{"@ciscospark/common":12,"babel-runtime/core-js/map":682,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703}],3:[function(require,module,exports){
(function (Buffer){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromBase64url = fromBase64url;
exports.toBase64Url = toBase64Url;
exports.encode = encode;
exports.decode = decode;
exports.validate = validate;

var _urlsafeBase = require('urlsafe-base64');

var _urlsafeBase2 = _interopRequireDefault(_urlsafeBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Converts a string from a base64url-encoded string
 * @param {string} str
 * @returns {string}
 */
function fromBase64url(str) {
  return _urlsafeBase2.default.decode(str).toString();
}

/**
 * Converts a string to a base64url-encoded string. It also accepts a buffer
 * @param {string|buffer} str
 * @returns {string}
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

function toBase64Url(str) {
  var buffer = str;
  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  }

  return _urlsafeBase2.default.encode(buffer);
}

/**
 * Converts a string to a base64url-encoded string. It also accepts a buffer
 * @param {string|buffer} str
 * @returns {string}
 */
function encode(str) {
  return toBase64Url(str);
}

/**
 * Converts a string from a base64url-encoded string
 * @param {string} str
 * @returns {string}
 */
function decode(str) {
  return fromBase64url(str);
}

/**
 * Indicates if the provided string is, in fact, a base64 string
 * @param {String} str
 * @returns {Boolean}
 */
function validate(str) {
  return _urlsafeBase2.default.validate(str);
}

exports.default = {
  fromBase64url: fromBase64url,
  toBase64Url: toBase64Url,
  encode: encode,
  decode: decode,
  validate: validate
};


}).call(this,require("buffer").Buffer)
},{"buffer":1735,"urlsafe-base64":1730}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

exports.default = debounce;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Behaves like debounce, but additionally executes after a number of calls are
 * attempted, rather than just time
 * @param {Function} fn
 * @param {Number} wait
 * @param {Object} options
 * @returns {Function}
 */
function debounce(fn, wait, options) {
  /* eslint no-invalid-this: [0] */

  if (!fn) {
    throw new Error('`fn` must be a function');
  }

  if (!wait) {
    throw new Error('`wait` is required');
  }

  options = options || {};
  if (!options.maxWait) {
    throw new Error('`options.maxWait` is required');
  }
  if (!options.maxCalls) {
    throw new Error('`options.maxCalls` is required');
  }

  var _options = options,
      maxCalls = _options.maxCalls,
      maxWait = _options.maxWait;

  var count = 0;
  var maxWaitTimer = void 0,
      waitTimer = void 0;

  return function wrapper() {
    count += 1;

    clearTimeout(waitTimer);
    waitTimer = setTimeout(function () {
      return exec();
    }, wait);

    if (!maxWaitTimer) {
      maxWaitTimer = setTimeout(function () {
        return exec();
      }, maxWait);
    }

    if (count >= maxCalls) {
      (0, _apply2.default)(exec, this, []);
    }
  };

  /**
   * @private
   * @returns {undefined}
   */
  function exec() {
    clearTimeout(waitTimer);
    waitTimer = null;
    clearTimeout(maxWaitTimer);
    maxWaitTimer = null;
    count = 0;

    (0, _apply2.default)(fn, this, []);
  }
}


},{"babel-runtime/core-js/reflect/apply":695}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = checkRequired;
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Check object for the specified keys
 * @param {Array<string>} keys
 * @param {Object} object
 * @returns {undefined}
 * @throws Error
 */
function checkRequired(keys, object) {
  keys.forEach(function (key) {
    if (!object[key]) {
      throw new Error("missing required property " + key + " from " + object);
    }
  });
}


},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

exports.default = Defer;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Creates a new `Defer`red object,
 * @returns {Defer}
 */
function Defer() {
  var _this = this;

  this.promise = new _promise2.default(function (resolve, reject) {
    /**
     * @instance
     * @memberof Defer
     * @type {function}
     */
    _this.resolve = resolve;
    /**
     * @instance
     * @memberof Defer
     * @type {function}
     */
    _this.reject = reject;
  });
}


},{"babel-runtime/core-js/promise":694}],7:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _coreDecorators = require('core-decorators');

/**
 * @private
 * @returns {function}
 */
function emptyDecorator() {
  return function noop() {/* eslint no-empty:[0] */};
} /*!
   * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
   */

var exportedDeprecated = process.env.NODE_ENV === 'production' ? emptyDecorator : _coreDecorators.deprecated;

exports.default = exportedDeprecated;


}).call(this,require('_process'))
},{"_process":1743,"core-decorators":23}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

exports.proxyEvents = proxyEvents;
exports.transferEvents = transferEvents;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Proxies the event binding methods of emitter onto proxy
 * @param {EventEmitter|EventEmitterProxy} emitter
 * @param {mixed} proxy (probably a promise)
 * @returns {EventEmitter} Returns the source emitter to ease use in promise chains
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

function proxyEvents(emitter, proxy) {
  ['on', 'once'].forEach(function (key) {
    proxy[key] = function () {
      emitter[key].apply(emitter, arguments);
      return proxy;
    };
  });

  return emitter;
}

/**
 * Given a list of events, fires them on drain when they're emitted from source
 * @param {Array|string} events
 * @param {EventEmitter} source
 * @param {EventEmitter} drain
 * @returns {undefined}
 */
function transferEvents(events, source, drain) {
  events = (0, _isArray3.default)(events) ? events : [events];
  events.forEach(function (event) {
    if (source.on) {
      source.on(event, function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return emit.apply(undefined, [drain, event].concat(args));
      });
    }
  });
}

/**
 * Emits an event
 * @param {EventEmitter} target The EventEmitter from which to emit an event
 * @returns {mixed}
 */
function emit(target) {
  var method = target.trigger || target.emit;
  /* istanbul ignore if */
  if (!method) {
    throw new Error('count not determine emit method');
  }

  for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    rest[_key2 - 1] = arguments[_key2];
  }

  return (0, _apply2.default)(method, target, rest);
}


},{"babel-runtime/core-js/reflect/apply":695,"lodash/isArray":1648}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _setPrototypeOf = require('babel-runtime/core-js/object/set-prototype-of');

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _construct = require('babel-runtime/core-js/reflect/construct');

var _construct2 = _interopRequireDefault(_construct);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class, _temp;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = (0, _construct2.default)(cls, (0, _from2.default)(arguments));
    (0, _setPrototypeOf2.default)(instance, (0, _getPrototypeOf2.default)(this));
    return instance;
  }

  ExtendableBuiltin.prototype = (0, _create2.default)(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (_setPrototypeOf2.default) {
    (0, _setPrototypeOf2.default)(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Base Exception class
 */
var Exception = (_temp = _class = function (_extendableBuiltin2) {
  (0, _inherits3.default)(Exception, _extendableBuiltin2);

  /**
   * constructor
   * @param {mixed} args
   * @returns {Exception}
   */
  function Exception() {
    var _ref;

    (0, _classCallCheck3.default)(this, Exception);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = Exception.__proto__ || (0, _getPrototypeOf2.default)(Exception)).call.apply(_ref, [this].concat(args)));

    var message = void 0;
    if (_this.parse) {
      message = _this.parse.apply(_this, args);
    } else if (_this.constructor.parse) {
      var _this$constructor;

      message = (_this$constructor = _this.constructor).parse.apply(_this$constructor, args);
    }

    if (!message) {
      message = _this.constructor.defaultMessage;
    }

    _this.name = _this.constructor.name;

    _this.message = message;
    return _this;
  }

  /**
   * Generates the value assigned to `this.message`. You'll probably want to
   * override this in your custom Exception
   * @param {mixed} args
   * @returns {string}
   */


  (0, _createClass3.default)(Exception, null, [{
    key: 'parse',
    value: function parse() {
      return arguments.length <= 0 ? undefined : arguments[0];
    }
  }]);
  return Exception;
}(_extendableBuiltin(Error)), _class.defaultMessage = 'An error occurred', _temp);
exports.default = Exception;


},{"babel-runtime/core-js/array/from":678,"babel-runtime/core-js/object/create":685,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/set-prototype-of":692,"babel-runtime/core-js/reflect/construct":696,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

exports.default = true;


},{}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _node = require('./node');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_node).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


},{"./node":10}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _base = require('./base64');

Object.defineProperty(exports, 'base64', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_base).default;
  }
});

var _cappedDebounce = require('./capped-debounce');

Object.defineProperty(exports, 'cappedDebounce', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_cappedDebounce).default;
  }
});

var _checkRequired = require('./check-required');

Object.defineProperty(exports, 'checkRequired', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_checkRequired).default;
  }
});

var _defer = require('./defer');

Object.defineProperty(exports, 'Defer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_defer).default;
  }
});

var _makeStateDatatype = require('./make-state-datatype');

Object.defineProperty(exports, 'makeStateDataType', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_makeStateDatatype).default;
  }
});

var _templateContainer = require('./template-container');

Object.defineProperty(exports, 'make', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_templateContainer).default;
  }
});

var _oneFlight = require('./one-flight');

Object.defineProperty(exports, 'oneFlight', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_oneFlight).default;
  }
});

var _patterns = require('./patterns.js');

Object.defineProperty(exports, 'patterns', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_patterns).default;
  }
});

var _events = require('./events');

Object.defineProperty(exports, 'proxyEvents', {
  enumerable: true,
  get: function get() {
    return _events.proxyEvents;
  }
});
Object.defineProperty(exports, 'transferEvents', {
  enumerable: true,
  get: function get() {
    return _events.transferEvents;
  }
});

var _resolveWith = require('./resolve-with');

Object.defineProperty(exports, 'resolveWith', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_resolveWith).default;
  }
});

var _retry = require('./retry');

Object.defineProperty(exports, 'retry', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_retry).default;
  }
});

var _tap = require('./tap');

Object.defineProperty(exports, 'tap', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_tap).default;
  }
});

var _whileInFlight = require('./while-in-flight');

Object.defineProperty(exports, 'whileInFlight', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_whileInFlight).default;
  }
});

var _exception = require('./exception');

Object.defineProperty(exports, 'Exception', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_exception).default;
  }
});

var _deprecated = require('./deprecated');

Object.defineProperty(exports, 'deprecated', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_deprecated).default;
  }
});

var _inBrowser = require('./in-browser');

Object.defineProperty(exports, 'inBrowser', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_inBrowser).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


},{"./base64":3,"./capped-debounce":4,"./check-required":5,"./defer":6,"./deprecated":7,"./events":8,"./exception":9,"./in-browser":11,"./make-state-datatype":13,"./one-flight":14,"./patterns.js":15,"./resolve-with":16,"./retry":17,"./tap":18,"./template-container":19,"./while-in-flight":20}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = makeStateDataType;
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

// Reminder: any class using this function must have something like the
// following in its initialize method:
//
// // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure
// // function.
// this._dataTypes = cloneDeep(this._dataTypes);
// Object.keys(this._dataTypes).forEach((key) => {
//   if (this._dataTypes[key].set) {
//     this._dataTypes[key].set = this._dataTypes[key].set.bind(this);
//   }
// });
// // END HACK

/**
 * Creates an ampersand state object that wires its event handlers like a an
 * ampersand child
 * @param {Function} Constructor
 * @param {string} name
 * @returns {Object}
 */
function makeStateDataType(Constructor, name) {
  if (!Constructor || !name) {
    throw new Error('missing parameter for makeStateDataType');
  }

  return {
    dataType: {
      set: function set(newVal) {
        // newVal.parent = this;
        if (newVal instanceof Constructor) {
          newVal.parent = this;
          return {
            val: newVal,
            type: name
          };
        }

        // We only want to construct the new instance if we have some set of
        // attributes (even an empty object) to base it on. This is to deal with
        // the unexpected side effect that AmpState#unset will create a new
        // instance.
        return {
          val: newVal ? new Constructor(newVal, { parent: this }) : undefined,
          type: name
        };
      },
      compare: function compare(currentValue, newVal) {
        return currentValue === newVal;
      },
      onChange: function onChange(newVal, previousVal, attributeName) {
        // Copied from ampersand-state.js
        // if this has changed we want to also handle
        // event propagation
        if (previousVal) {
          this.stopListening(previousVal, 'all', this._getCachedEventBubblingHandler(attributeName));
        }

        if (newVal) {
          this.listenTo(newVal, 'all', this._getCachedEventBubblingHandler(attributeName));
        }
      }
    },
    prop: {
      /**
       * This is a really unfortunate hack to deal with ampersand`s decision to
       * make the dateType#set function pure. The only function called with the
       * scope of the parent at set time seems to be test
       * @param {AmpersandState} newVal
       * @returns {boolean}
       */
      test: function test(newVal) {
        if (!newVal) {
          return false;
        }
        newVal.parent = this;
        return false;
      },
      type: name
    }
  };
}


},{}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _wrap2 = require('lodash/wrap');

var _wrap3 = _interopRequireDefault(_wrap2);

exports.default = oneFlight;

var _templateContainer = require('./template-container');

var _templateContainer2 = _interopRequireDefault(_templateContainer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Alias Map and WeakMap to get around a babel compiler bug
var W = _weakMap2.default; /*!
                            * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                            */

var M = _map2.default;
var WeakMappedMappedMap = (0, _templateContainer2.default)(W, M, M);

var flights = new WeakMappedMappedMap();

/**
 * @memberof Util
 * @param {Object} options
 * @param {Function} options.keyFactory
 * @param {boolean} options.cacheFailures
 * @param {boolean} options.cacheSuccesses
 * @returns {Function}
 */
function oneFlight() {
  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  if (params.length === 3) {
    return (0, _apply2.default)(oneFlightDecorator, null, params);
  }

  var options = params[0] || {};

  var cacheFailures = options.cacheFailures,
      cacheSuccesses = options.cacheSuccesses,
      keyFactory = options.keyFactory;


  return oneFlightDecorator;

  /**
   * @param {Object} target
   * @param {string} prop
   * @param {Object} descriptor
   * @private
   * @returns {Object}
   */
  function oneFlightDecorator(target, prop, descriptor) {
    var key = prop;

    descriptor.value = (0, _wrap3.default)(descriptor.value, function oneFlightExecutor(fn) {
      var _this = this;

      var innerKey = key;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (keyFactory) {
        innerKey = innerKey + '_' + keyFactory.apply(undefined, args);
      }

      /* eslint no-invalid-this: [0] */
      var flight = flights.get(this, target, innerKey);
      if (flight) {
        return flight;
      }

      flight = (0, _apply2.default)(fn, this, args);
      if (!cacheFailures && flight && flight.catch) {
        flight = flight.catch(function (reason) {
          flights.delete(_this, target, innerKey);
          return _promise2.default.reject(reason);
        });
      }

      if (!cacheSuccesses && flight && flight.then) {
        flight = flight.then(function (result) {
          flights.delete(_this, target, innerKey);
          return result;
        });
      }

      flights.set(this, target, innerKey, flight);

      return flight;
    });

    // This *should* make decorators compatible with AmpersandState class
    // definitions
    if ((typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) === 'object' && !target.prototype) {
      target[prop] = descriptor.value;
    }

    return descriptor;
  }
}


},{"./template-container":19,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/typeof":711,"lodash/wrap":1715}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * @description Set of regex patterns to compile once and use throughout the
 * app. All non-prefixed patterns have start/end characters to ensure exact
 * matches. Patterns prefixed with "exec" are the same as their non-prefixed
 * counterparts but without the start/end characters so they can be used with
 * methods like `RegExp#exec`.
 */
exports.default = {
  /**
   * Matches an email address by requiring an @ and excluding spaces
   * @todo add a better email address matcher
   * @type {RegExp}
   */
  email: /^[^\s]+?@[^\s]+?$/,

  /**
   * Matches a UUID
   * @type {RegExp}
   */
  uuid: /^[a-f\d]{8}(?:-[a-f\d]{4}){3}-[a-f\d]{12}$/,

  /**
   * Same as this.email, but allows for surrounding characters
   * @type {RegExp}
   */
  execEmail: /[^\s]+?@[^\s]+?/,

  /**
   * Same as this.uuid but allows for surrounding characters
   * @type {RegExp}
   */
  execUuid: /[a-f\d]{8}(?:-[a-f\d]{4}){3}-[a-f\d]{12}/
};


},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

exports.default = resolveWith;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Sugar method for returning the desired object at the end of a promise chain
 * @param {any} object the item with which to resolve the promise chain
 * @returns {function}
 * @example
 * var item = {
 *   prop: 2
 * };
 * Promise
 *  .resolve(item.prop)
 *  .then(resolveWith(item))
 *  .then(function(res) {
 *    require('assert').deepEqual(res, {prop:2});
 *    return 'success'
 *  })
 *  // => success
 *
 */
function resolveWith(object) {
  return function resolver() {
    return _promise2.default.resolve(object);
  };
}


},{"babel-runtime/core-js/promise":694}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _wrap2 = require('lodash/wrap');

var _wrap3 = _interopRequireDefault(_wrap2);

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

exports.default = retry;

var _events = require('events');

var _backoff = require('backoff');

var _backoff2 = _interopRequireDefault(_backoff);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint max-nested-callbacks: [0] */

/**
 * Makes a promise-returning method retryable according to the specified backoff
 * pattern
 * @param {Object} options
 * @param {boolean} options.backoff
 * @param {number} options.delay
 * @param {number} options.initialDelay
 * @param {number} options.maxAttempts
 * @param {number} options.maxDelay
 *
 * @returns {Function}
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

function retry() {
  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  var options = params[0] || {};

  options = (0, _assign2.default)({}, options);
  (0, _defaults3.default)(options, {
    backoff: true,
    delay: 1,
    maxAttempts: 3
  });

  var strategyOptions = void 0;
  if (options.backoff) {
    strategyOptions = {
      initialDelay: options.delay,
      maxDelay: options.maxDelay
    };
  } else {
    strategyOptions = {
      initialDelay: 1,
      maxDelay: 1
    };
  }

  if (params.length === 3) {
    return (0, _apply2.default)(retryDecorator, null, params);
  }

  return retryDecorator;

  /**
   * @param {Object} target
   * @param {string} prop
   * @param {Object} descriptor
   * @private
   * @returns {Object}
   */
  function retryDecorator(target, prop, descriptor) {
    descriptor.value = (0, _wrap3.default)(descriptor.value, function retryExecutor(fn) {
      var _this = this;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var emitter = new _events.EventEmitter();
      var promise = new _promise2.default(function (resolve, reject) {
        // backoff.call is not Function.prototype.call; it's an unfortunate naming
        // collision.
        /* eslint prefer-reflect: [0] */
        var call = _backoff2.default.call(function (cb) {
          /* eslint no-invalid-this: [0] */
          var innerPromise = (0, _apply2.default)(fn, _this, args);

          if ((0, _isFunction3.default)(innerPromise.on)) {
            innerPromise.on('progress', emitter.emit.bind(emitter, 'progress'));
            innerPromise.on('upload-progress', emitter.emit.bind(emitter, 'upload-progress'));
            innerPromise.on('download-progress', emitter.emit.bind(emitter, 'download-progress'));
          }

          return innerPromise.then(function (res) {
            cb(null, res);
          }).catch(function (reason) {
            if (!reason) {
              reason = new Error('retryable method failed without providing an error object');
            }
            cb(reason);
          });
        }, function (err, res) {
          if (err) {
            return reject(err);
          }

          return resolve(res);
        });

        call.setStrategy(new _backoff2.default.ExponentialStrategy(strategyOptions));
        if (options.maxAttempts) {
          call.failAfter(options.maxAttempts - 1);
        }

        call.start();
      });

      promise.on = function on(key, callback) {
        emitter.on(key, callback);
        return promise;
      };

      return promise;
    });

    // This *should* make decorators compatible with AmpersandState class
    // definitions
    if ((typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) === 'object' && !target.prototype) {
      target[prop] = descriptor.value;
    }

    return descriptor;
  }
}


},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/typeof":711,"backoff":712,"events":1737,"lodash/defaults":1618,"lodash/isFunction":1656,"lodash/wrap":1715}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

exports.default = tap;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Injects code into a promise chain without modifying the promise chain's result
 * @param {Function} fn
 * @returns {Promise}
 * @example
 * function f() {
 *   return Promise.resolve(5);
 * }
 *
 * f()
 *   .then(tap(() => 12))
 *   // => 5
 */
function tap(fn) {
  return function (r) {
    return new _promise2.default(function (resolve) {
      resolve(fn(r));
    }).then(function () {
      return r;
    }).catch(function () {
      return r;
    });
  };
}


},{"babel-runtime/core-js/promise":694}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Factory which produces a multi-keyed container based on the provided set of
 * constructors
 * @param {mixed} containers
 * @returns {Container}
 */
function make() {
  for (var _len = arguments.length, containers = Array(_len), _key = 0; _key < _len; _key++) {
    containers[_key] = arguments[_key];
  }

  var TopContainer = containers.shift();

  var data = new _weakMap2.default();
  var sizes = new _weakMap2.default();

  var ChildContainer = containers.length > 1 ? make.apply(undefined, containers) : containers[0];

  var name = '(' + [TopContainer.name].concat(containers.map(function (container) {
    return container.name;
  })).join(', ') + ')';

  /**
   * Container that wraps an arbitrary set of tupples to their values
   */

  var Container = function () {
    /**
     * @constructs Container
     */
    function Container() {
      (0, _classCallCheck3.default)(this, Container);

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      data.set(this, new (Function.prototype.bind.apply(TopContainer, [null].concat(args)))());
      sizes.set(this, 0);
    }

    /**
     * getter for .size
     * @returns {number}
     */


    (0, _createClass3.default)(Container, [{
      key: 'add',


      /**
       * Identical to Container#set() but leads slightly more intuitive code when
       * the container is based on a Set rather than a Map.
       * @returns {Container}
       */
      value: function add() {
        return this.set.apply(this, arguments);
      }

      /**
       * Removes all items from the container
       * @returns {undefined}
       */

    }, {
      key: 'clear',
      value: function clear() {
        var ret = data.get(this).clear();
        sizes.set(this, 0);
        return ret;
      }

      /**
       * Removes the specified item to the container
       * @param {mixed} key
       * @param {Array<mixed>} keys
       * @returns {boolean}
       */

    }, {
      key: 'delete',
      value: function _delete(key) {
        var mine = data.get(this);

        for (var _len3 = arguments.length, keys = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          keys[_key3 - 1] = arguments[_key3];
        }

        if (!keys.length) {
          return mine.delete(key);
        }

        var next = mine.get(key);
        if (!next) {
          return false;
        }

        var ret = next.delete.apply(next, keys);

        if (ret) {
          sizes.set(this, sizes.get(this) - 1);
        }

        if (next.size === 0) {
          mine.delete(key);
        }

        return ret;
      }

      /**
       * Retrieves the specified item from the container
       * @param {mixed} key
       * @param {Array<mixed>} keys
       * @returns {mixed}
       */

    }, {
      key: 'get',
      value: function get(key) {
        var mine = data.get(this);

        if (!mine.get) {
          return mine;
        }

        for (var _len4 = arguments.length, keys = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          keys[_key4 - 1] = arguments[_key4];
        }

        if (!keys.length) {
          return mine.get(key);
        }

        var next = mine.get(key);
        if (!next) {
          return undefined;
        }

        if (!next.get) {
          return next;
        }
        return next.get.apply(next, keys);
      }

      /**
       * Indicates whether the container holds the specified item
       * @param {mixed} key
       * @param {Array<mixed>} keys
       * @returns {Boolean}
       */

    }, {
      key: 'has',
      value: function has() {
        return typeof this.get.apply(this, arguments) !== 'undefined';
      }

      /**
       * Stores the specified item in the container
       * @param {mixed} key
       * @param {Array<mixed>} args
       * @param {mixed} value
       * @returns {Container}
       */

    }, {
      key: 'set',
      value: function set() {
        var overwrite = false;

        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        if (this.has.apply(this, args)) {
          overwrite = true;
        }
        var mine = data.get(this);

        var key = args.shift();

        if (!mine.get) {
          insert.apply(undefined, [mine, key].concat(args));
          return this;
        }

        var next = mine.get(key);
        if (!next) {
          if (!ChildContainer) {
            insert.apply(undefined, [mine, key].concat(args));
            return this;
          }
          next = new ChildContainer();
          insert(mine, key, next);
        }
        insert.apply(undefined, [next].concat(args));

        if (!overwrite) {
          sizes.set(this, sizes.get(this) + 1);
        }
        return this;
      }

      /**
       * @private
       * @returns {string}
       */

    }, {
      key: 'inspect',
      value: function inspect() {
        return 'Container' + name + ' {\n  ' + _util2.default.inspect(data.get(this), { depth: null }) + '\n}';
      }
    }, {
      key: 'size',
      get: function get() {
        return sizes.get(this);
      }
    }]);
    return Container;
  }();

  return Container;
}

/**
 * Inserts into an arbitrary container
 * @param {Map|WeakMap|Set|WeakSet} container
 * @param {Array<mixed>} args
 * @private
 * @returns {undefined}
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

function insert(container) {
  for (var _len6 = arguments.length, args = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
    args[_key6 - 1] = arguments[_key6];
  }

  if (container.add) {
    container.add.apply(container, args);
    return;
  }

  if (container.set) {
    container.set.apply(container, args);
    return;
  }

  if (container.push) {
    container.push.apply(container, args);
    return;
  }
  throw new TypeError('Could not determine how to insert into the specified container');
}
exports.default = make;


},{"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"util":1769}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _wrap2 = require('lodash/wrap');

var _wrap3 = _interopRequireDefault(_wrap2);

exports.default = whileInFlight;

var _tap = require('./tap');

var _tap2 = _interopRequireDefault(_tap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * While the promise returned by the decorated is unfullfilled, sets, the
 * specified boolean on the target class to `true`
 * @param {string} param
 * @returns {Function}
 */
function whileInFlight(param) {
  return function whileInFlightDecorator(target, name, descriptor) {
    descriptor.value = (0, _wrap3.default)(descriptor.value, function whileInFlightExecutor(fn) {
      var _this = this;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return new _promise2.default(function (resolve) {
        _this[param] = true;
        resolve((0, _apply2.default)(fn, _this, args).then((0, _tap2.default)(function () {
          _this[param] = false;
        })).catch(function (reason) {
          _this[param] = false;
          return _promise2.default.reject(reason);
        }));
      });
    });
  };
} /*!
   * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
   */

/* eslint no-invalid-this: [0] */


},{"./tap":18,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"lodash/wrap":1715}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyDecorators;
var defineProperty = Object.defineProperty,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

function applyDecorators(Class, props) {
  var prototype = Class.prototype;


  for (var key in props) {
    var decorators = props[key];

    for (var i = 0, l = decorators.length; i < l; i++) {
      var decorator = decorators[i];

      defineProperty(prototype, key, decorator(prototype, key, getOwnPropertyDescriptor(prototype, key)));
    }
  }

  return Class;
}
},{}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = autobind;

var _utils = require('./private/utils');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var defineProperty = Object.defineProperty,
    getPrototypeOf = Object.getPrototypeOf;


var mapStore = void 0;

function getBoundSuper(obj, fn) {
  if (typeof WeakMap === 'undefined') {
    throw new Error('Using @autobind on ' + fn.name + '() requires WeakMap support due to its use of super.' + fn.name + '()\n      See https://github.com/jayphelps/core-decorators.js/issues/20');
  }

  if (!mapStore) {
    mapStore = new WeakMap();
  }

  if (mapStore.has(obj) === false) {
    mapStore.set(obj, new WeakMap());
  }

  var superStore = mapStore.get(obj);

  if (superStore.has(fn) === false) {
    superStore.set(fn, (0, _utils.bind)(fn, obj));
  }

  return superStore.get(fn);
}

function autobindClass(klass) {
  var descs = (0, _utils.getOwnPropertyDescriptors)(klass.prototype);
  var keys = (0, _utils.getOwnKeys)(descs);

  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    var desc = descs[key];

    if (typeof desc.value !== 'function' || key === 'constructor') {
      continue;
    }

    defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc));
  }
}

function autobindMethod(target, key, _ref) {
  var fn = _ref.value,
      configurable = _ref.configurable,
      enumerable = _ref.enumerable;

  if (typeof fn !== 'function') {
    throw new SyntaxError('@autobind can only be used on functions, not: ' + fn);
  }

  var constructor = target.constructor;


  return {
    configurable: configurable,
    enumerable: enumerable,

    get: function get() {
      // Class.prototype.key lookup
      // Someone accesses the property directly on the prototype on which it is
      // actually defined on, i.e. Class.prototype.hasOwnProperty(key)
      if (this === target) {
        return fn;
      }

      // Class.prototype.key lookup
      // Someone accesses the property directly on a prototype but it was found
      // up the chain, not defined directly on it
      // i.e. Class.prototype.hasOwnProperty(key) == false && key in Class.prototype
      if (this.constructor !== constructor && getPrototypeOf(this).constructor === constructor) {
        return fn;
      }

      // Autobound method calling super.sameMethod() which is also autobound and so on.
      if (this.constructor !== constructor && key in this.constructor.prototype) {
        return getBoundSuper(this, fn);
      }

      var boundFn = (0, _utils.bind)(fn, this);

      defineProperty(this, key, {
        configurable: true,
        writable: true,
        // NOT enumerable when it's a bound method
        enumerable: false,
        value: boundFn
      });

      return boundFn;
    },

    set: (0, _utils.createDefaultSetter)(key)
  };
}

function handle(args) {
  if (args.length === 1) {
    return autobindClass.apply(undefined, _toConsumableArray(args));
  } else {
    return autobindMethod.apply(undefined, _toConsumableArray(args));
  }
}

function autobind() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length === 0) {
    return function () {
      return handle(arguments);
    };
  } else {
    return handle(args);
  }
}
},{"./private/utils":35}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _override = require('./override');

Object.defineProperty(exports, 'override', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_override).default;
  }
});

var _deprecate = require('./deprecate');

Object.defineProperty(exports, 'deprecate', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_deprecate).default;
  }
});
Object.defineProperty(exports, 'deprecated', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_deprecate).default;
  }
});

var _suppressWarnings = require('./suppress-warnings');

Object.defineProperty(exports, 'suppressWarnings', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_suppressWarnings).default;
  }
});

var _memoize = require('./memoize');

Object.defineProperty(exports, 'memoize', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_memoize).default;
  }
});

var _autobind = require('./autobind');

Object.defineProperty(exports, 'autobind', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_autobind).default;
  }
});

var _readonly = require('./readonly');

Object.defineProperty(exports, 'readonly', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_readonly).default;
  }
});

var _enumerable = require('./enumerable');

Object.defineProperty(exports, 'enumerable', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_enumerable).default;
  }
});

var _nonenumerable = require('./nonenumerable');

Object.defineProperty(exports, 'nonenumerable', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_nonenumerable).default;
  }
});

var _nonconfigurable = require('./nonconfigurable');

Object.defineProperty(exports, 'nonconfigurable', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_nonconfigurable).default;
  }
});

var _debounce = require('./debounce');

Object.defineProperty(exports, 'debounce', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_debounce).default;
  }
});

var _throttle = require('./throttle');

Object.defineProperty(exports, 'throttle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_throttle).default;
  }
});

var _decorate = require('./decorate');

Object.defineProperty(exports, 'decorate', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_decorate).default;
  }
});

var _mixin = require('./mixin');

Object.defineProperty(exports, 'mixin', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_mixin).default;
  }
});
Object.defineProperty(exports, 'mixins', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_mixin).default;
  }
});

var _lazyInitialize = require('./lazy-initialize');

Object.defineProperty(exports, 'lazyInitialize', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_lazyInitialize).default;
  }
});

var _time = require('./time');

Object.defineProperty(exports, 'time', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_time).default;
  }
});

var _extendDescriptor = require('./extendDescriptor');

Object.defineProperty(exports, 'extendDescriptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_extendDescriptor).default;
  }
});

var _profile = require('./profile');

Object.defineProperty(exports, 'profile', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_profile).default;
  }
});

var _applyDecorators = require('./applyDecorators');

Object.defineProperty(exports, 'applyDecorators', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_applyDecorators).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./applyDecorators":21,"./autobind":22,"./debounce":24,"./decorate":25,"./deprecate":26,"./enumerable":27,"./extendDescriptor":28,"./lazy-initialize":29,"./memoize":30,"./mixin":31,"./nonconfigurable":32,"./nonenumerable":33,"./override":34,"./profile":36,"./readonly":37,"./suppress-warnings":38,"./throttle":39,"./time":40}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = debounce;

var _utils = require('./private/utils');

var DEFAULT_TIMEOUT = 300;

function handleDescriptor(target, key, descriptor, _ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      _ref2$ = _ref2[0],
      wait = _ref2$ === undefined ? DEFAULT_TIMEOUT : _ref2$,
      _ref2$2 = _ref2[1],
      immediate = _ref2$2 === undefined ? false : _ref2$2;

  var callback = descriptor.value;

  if (typeof callback !== 'function') {
    throw new SyntaxError('Only functions can be debounced');
  }

  return _extends({}, descriptor, {
    value: function value() {
      var _this = this;

      var _metaFor = (0, _utils.metaFor)(this),
          debounceTimeoutIds = _metaFor.debounceTimeoutIds;

      var timeout = debounceTimeoutIds[key];
      var callNow = immediate && !timeout;
      var args = arguments;

      clearTimeout(timeout);

      debounceTimeoutIds[key] = setTimeout(function () {
        delete debounceTimeoutIds[key];
        if (!immediate) {
          callback.apply(_this, args);
        }
      }, wait);

      if (callNow) {
        callback.apply(this, args);
      }
    }
  });
}

function debounce() {
  (0, _utils.internalDeprecation)('@debounce is deprecated and will be removed shortly. Use @debounce from lodash-decorators.\n\n  https://www.npmjs.com/package/lodash-decorators');

  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = decorate;

var _utils = require('./private/utils');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var defineProperty = Object.defineProperty;


function handleDescriptor(target, key, descriptor, _ref) {
  var _ref2 = _toArray(_ref),
      decorator = _ref2[0],
      args = _ref2.slice(1);

  var configurable = descriptor.configurable,
      enumerable = descriptor.enumerable,
      writable = descriptor.writable;

  var originalGet = descriptor.get;
  var originalSet = descriptor.set;
  var originalValue = descriptor.value;
  var isGetter = !!originalGet;

  return {
    configurable: configurable,
    enumerable: enumerable,
    get: function get() {
      var fn = isGetter ? originalGet.call(this) : originalValue;
      var value = decorator.call.apply(decorator, [this, fn].concat(_toConsumableArray(args)));

      if (isGetter) {
        return value;
      } else {
        var desc = {
          configurable: configurable,
          enumerable: enumerable
        };

        desc.value = value;
        desc.writable = writable;

        defineProperty(this, key, desc);

        return value;
      }
    },

    set: isGetter ? originalSet : (0, _utils.createDefaultSetter)()
  };
}

function decorate() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = deprecate;

var _utils = require('./private/utils');

var DEFAULT_MSG = 'This function will be removed in future versions.';

function handleDescriptor(target, key, descriptor, _ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      _ref2$ = _ref2[0],
      msg = _ref2$ === undefined ? DEFAULT_MSG : _ref2$,
      _ref2$2 = _ref2[1],
      options = _ref2$2 === undefined ? {} : _ref2$2;

  if (typeof descriptor.value !== 'function') {
    throw new SyntaxError('Only functions can be marked as deprecated');
  }

  var methodSignature = target.constructor.name + '#' + key;

  if (options.url) {
    msg += '\n\n    See ' + options.url + ' for more details.\n\n';
  }

  return _extends({}, descriptor, {
    value: function deprecationWrapper() {
      (0, _utils.warn)('DEPRECATION ' + methodSignature + ': ' + msg);
      return descriptor.value.apply(this, arguments);
    }
  });
}

function deprecate() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = enumerable;

var _utils = require('./private/utils');

function handleDescriptor(target, key, descriptor) {
  descriptor.enumerable = true;
  return descriptor;
}

function enumerable() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = extendDescriptor;

var _utils = require('./private/utils');

var getPrototypeOf = Object.getPrototypeOf,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;


function handleDescriptor(target, key, descriptor) {
  var superKlass = getPrototypeOf(target);
  var superDesc = getOwnPropertyDescriptor(superKlass, key);

  return _extends({}, superDesc, {
    value: descriptor.value,
    initializer: descriptor.initializer,
    get: descriptor.get || superDesc.get,
    set: descriptor.set || superDesc.set
  });
}

function extendDescriptor() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = lazyInitialize;

var _utils = require('./private/utils');

var defineProperty = Object.defineProperty;


function handleDescriptor(target, key, descriptor) {
  var configurable = descriptor.configurable,
      enumerable = descriptor.enumerable,
      initializer = descriptor.initializer,
      value = descriptor.value;

  return {
    configurable: configurable,
    enumerable: enumerable,

    get: function get() {
      // This happens if someone accesses the
      // property directly on the prototype
      if (this === target) {
        return;
      }

      var ret = initializer ? initializer.call(this) : value;

      defineProperty(this, key, {
        configurable: configurable,
        enumerable: enumerable,
        writable: true,
        value: ret
      });

      return ret;
    },


    set: (0, _utils.createDefaultSetter)(key)
  };
}

function lazyInitialize() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = memoize;

var _utils = require('./private/utils');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function toObject(cache, value) {
  if (value === Object(value)) {
    return value;
  }
  return cache[value] || (cache[value] = {});
}

function applyAndCache(context, fn, args, cache, signature) {
  var ret = fn.apply(context, args);
  cache[signature] = ret;
  return ret;
}

function metaForDescriptor(descriptor) {
  var fn = void 0,
      wrapKey = void 0;

  // This is ugly code, but way faster than other
  // ways I tried that *looked* pretty

  if (descriptor.value) {
    fn = descriptor.value;
    wrapKey = 'value';
  } else if (descriptor.get) {
    fn = descriptor.get;
    wrapKey = 'get';
  } else if (descriptor.set) {
    fn = descriptor.set;
    wrapKey = 'set';
  }

  return { fn: fn, wrapKey: wrapKey };
}

function handleDescriptor(target, key, descriptor) {
  var _metaForDescriptor = metaForDescriptor(descriptor),
      fn = _metaForDescriptor.fn,
      wrapKey = _metaForDescriptor.wrapKey;

  var argumentCache = new WeakMap();
  var signatureCache = Object.create(null);
  var primativeRefCache = Object.create(null);
  var argumentIdCounter = 0;

  return _extends({}, descriptor, _defineProperty({}, wrapKey, function memoizeWrapper() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var signature = '0';

    for (var i = 0, l = args.length; i < l; i++) {
      var arg = args[i];
      var argRef = toObject(primativeRefCache, arg);
      var argKey = argumentCache.get(argRef);

      if (argKey === undefined) {
        argKey = ++argumentIdCounter;
        argumentCache.set(argRef, argKey);
      }

      signature += argKey;
    }

    return signatureCache[signature] || applyAndCache(this, fn, arguments, signatureCache, signature);
  }));
}

function memoize() {
  (0, _utils.internalDeprecation)('@memoize is deprecated and will be removed shortly. Use @memoize from lodash-decorators.\n\n  https://www.npmjs.com/package/lodash-decorators');

  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = mixin;

var _utils = require('./private/utils');

var defineProperty = Object.defineProperty,
    getPrototypeOf = Object.getPrototypeOf;


function buggySymbol(symbol) {
  return Object.prototype.toString.call(symbol) === '[object Symbol]' && (typeof symbol === 'undefined' ? 'undefined' : _typeof(symbol)) === 'object';
}

function hasProperty(prop, obj) {
  // We have to traverse manually prototypes' chain for polyfilled ES6 Symbols
  // like "in" operator does.
  // I.e.: Babel 5 Symbol polyfill stores every created symbol in Object.prototype.
  // That's why we cannot use construction like "prop in obj" to check, if needed
  // prop actually exists in given object/prototypes' chain.
  if (buggySymbol(prop)) {
    do {
      if (obj === Object.prototype) {
        // Polyfill assigns undefined as value for stored symbol key.
        // We can assume in this special case if there is nothing assigned it doesn't exist.
        return typeof obj[prop] !== 'undefined';
      }
      if (obj.hasOwnProperty(prop)) {
        return true;
      }
    } while (obj = getPrototypeOf(obj));
    return false;
  } else {
    return prop in obj;
  }
}

function handleClass(target, mixins) {
  if (!mixins.length) {
    throw new SyntaxError('@mixin() class ' + target.name + ' requires at least one mixin as an argument');
  }

  for (var i = 0, l = mixins.length; i < l; i++) {
    var descs = (0, _utils.getOwnPropertyDescriptors)(mixins[i]);
    var keys = (0, _utils.getOwnKeys)(descs);

    for (var j = 0, k = keys.length; j < k; j++) {
      var key = keys[j];

      if (!hasProperty(key, target.prototype)) {
        defineProperty(target.prototype, key, descs[key]);
      }
    }
  }
}

function mixin() {
  for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
    mixins[_key] = arguments[_key];
  }

  (0, _utils.internalDeprecation)('@mixin is deprecated and will be removed shortly. Use @mixin from lodash-decorators.\n\n  https://www.npmjs.com/package/lodash-decorators');

  if (typeof mixins[0] === 'function') {
    return handleClass(mixins[0], []);
  } else {
    return function (target) {
      return handleClass(target, mixins);
    };
  }
}
},{"./private/utils":35}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nonconfigurable;

var _utils = require('./private/utils');

function handleDescriptor(target, key, descriptor) {
  descriptor.configurable = false;
  return descriptor;
}

function nonconfigurable() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nonenumerable;

var _utils = require('./private/utils');

function handleDescriptor(target, key, descriptor) {
  descriptor.enumerable = false;
  return descriptor;
}

function nonenumerable() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = override;

var _utils = require('./private/utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GENERIC_FUNCTION_ERROR = '{child} does not properly override {parent}';
var FUNCTION_REGEXP = /^function ([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?(\([^\)]*\))[\s\S]+$/;

var SyntaxErrorReporter = function () {
  _createClass(SyntaxErrorReporter, [{
    key: '_getTopic',
    value: function _getTopic(descriptor) {
      if (descriptor === undefined) {
        return null;
      }

      if ('value' in descriptor) {
        return descriptor.value;
      }

      if ('get' in descriptor) {
        return descriptor.get;
      }

      if ('set' in descriptor) {
        return descriptor.set;
      }
    }
  }, {
    key: '_extractTopicSignature',
    value: function _extractTopicSignature(topic) {
      switch (typeof topic === 'undefined' ? 'undefined' : _typeof(topic)) {
        case 'function':
          return this._extractFunctionSignature(topic);
        default:
          return this.key;
      }
    }
  }, {
    key: '_extractFunctionSignature',
    value: function _extractFunctionSignature(fn) {
      var _this = this;

      return fn.toString().replace(FUNCTION_REGEXP, function (match) {
        var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.key;
        var params = arguments[2];
        return name + params;
      });
    }
  }, {
    key: 'key',
    get: function get() {
      return this.childDescriptor.key;
    }
  }, {
    key: 'parentNotation',
    get: function get() {
      return this.parentKlass.constructor.name + '#' + this.parentPropertySignature;
    }
  }, {
    key: 'childNotation',
    get: function get() {
      return this.childKlass.constructor.name + '#' + this.childPropertySignature;
    }
  }, {
    key: 'parentTopic',
    get: function get() {
      return this._getTopic(this.parentDescriptor);
    }
  }, {
    key: 'childTopic',
    get: function get() {
      return this._getTopic(this.childDescriptor);
    }
  }, {
    key: 'parentPropertySignature',
    get: function get() {
      return this._extractTopicSignature(this.parentTopic);
    }
  }, {
    key: 'childPropertySignature',
    get: function get() {
      return this._extractTopicSignature(this.childTopic);
    }
  }]);

  function SyntaxErrorReporter(parentKlass, childKlass, parentDescriptor, childDescriptor) {
    _classCallCheck(this, SyntaxErrorReporter);

    this.parentKlass = parentKlass;
    this.childKlass = childKlass;
    this.parentDescriptor = parentDescriptor;
    this.childDescriptor = childDescriptor;
  }

  _createClass(SyntaxErrorReporter, [{
    key: 'assert',
    value: function assert(condition) {
      var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      if (condition !== true) {
        this.error(GENERIC_FUNCTION_ERROR + msg);
      }
    }
  }, {
    key: 'error',
    value: function error(msg) {
      var _this2 = this;

      msg = msg
      // Replace lazily, because they actually might not
      // be available in all cases
      .replace('{parent}', function (m) {
        return _this2.parentNotation;
      }).replace('{child}', function (m) {
        return _this2.childNotation;
      });
      throw new SyntaxError(msg);
    }
  }]);

  return SyntaxErrorReporter;
}();

function getDescriptorType(descriptor) {
  if (descriptor.hasOwnProperty('value')) {
    return 'data';
  }

  if (descriptor.hasOwnProperty('get') || descriptor.hasOwnProperty('set')) {
    return 'accessor';
  }

  // If none of them exist, browsers treat it as
  // a data descriptor with a value of `undefined`
  return 'data';
}

function checkFunctionSignatures(parent, child, reporter) {
  reporter.assert(parent.length === child.length);
}

function checkDataDescriptors(parent, child, reporter) {
  var parentValueType = _typeof(parent.value);
  var childValueType = _typeof(child.value);

  if (parentValueType === 'undefined' && childValueType === 'undefined') {
    // class properties can be any expression, which isn't ran until the
    // the instance is created, so we can't reliably get type information
    // for them yet (per spec). Perhaps when Babel includes flow-type info
    // in runtime? Tried regex solutions, but super hacky and only feasible
    // on primitives, which is confusing for usage...
    reporter.error('descriptor values are both undefined. (class properties are are not currently supported)\'');
  }

  if (parentValueType !== childValueType) {
    var isFunctionOverUndefined = childValueType === 'function' && parentValueType === undefined;
    // Even though we don't support class properties, this
    // will still handle more than just functions, just in case.
    // Shadowing an undefined value is an error if the inherited
    // value was undefined (usually a class property, not a method)
    if (isFunctionOverUndefined || parentValueType !== undefined) {
      reporter.error('value types do not match. {parent} is "' + parentValueType + '", {child} is "' + childValueType + '"');
    }
  }

  // Switch, in preparation for supporting more types
  switch (childValueType) {
    case 'function':
      checkFunctionSignatures(parent.value, child.value, reporter);
      break;

    default:
      reporter.error('Unexpected error. Please file a bug with: {parent} is "' + parentValueType + '", {child} is "' + childValueType + '"');
      break;
  }
}

function checkAccessorDescriptors(parent, child, reporter) {
  var parentHasGetter = typeof parent.get === 'function';
  var childHasGetter = typeof child.get === 'function';
  var parentHasSetter = typeof parent.set === 'function';
  var childHasSetter = typeof child.set === 'function';

  if (parentHasGetter || childHasGetter) {
    if (!parentHasGetter && parentHasSetter) {
      reporter.error('{parent} is setter but {child} is getter');
    }

    if (!childHasGetter && childHasSetter) {
      reporter.error('{parent} is getter but {child} is setter');
    }

    checkFunctionSignatures(parent.get, child.get, reporter);
  }

  if (parentHasSetter || childHasSetter) {
    if (!parentHasSetter && parentHasGetter) {
      reporter.error('{parent} is getter but {child} is setter');
    }

    if (!childHasSetter && childHasGetter) {
      reporter.error('{parent} is setter but {child} is getter');
    }

    checkFunctionSignatures(parent.set, child.set, reporter);
  }
}

function checkDescriptors(parent, child, reporter) {
  var parentType = getDescriptorType(parent);
  var childType = getDescriptorType(child);

  if (parentType !== childType) {
    reporter.error('descriptor types do not match. {parent} is "' + parentType + '", {child} is "' + childType + '"');
  }

  switch (childType) {
    case 'data':
      checkDataDescriptors(parent, child, reporter);
      break;

    case 'accessor':
      checkAccessorDescriptors(parent, child, reporter);
      break;
  }
}

var suggestionTransforms = [function (key) {
  return key.toLowerCase();
}, function (key) {
  return key.toUpperCase();
}, function (key) {
  return key + 's';
}, function (key) {
  return key.slice(0, -1);
}, function (key) {
  return key.slice(1, key.length);
}];

function findPossibleAlternatives(superKlass, key) {
  for (var i = 0, l = suggestionTransforms.length; i < l; i++) {
    var fn = suggestionTransforms[i];
    var suggestion = fn(key);

    if (suggestion in superKlass) {
      return suggestion;
    }
  }

  return null;
}

function handleDescriptor(target, key, descriptor) {
  descriptor.key = key;
  var superKlass = Object.getPrototypeOf(target);
  var superDescriptor = Object.getOwnPropertyDescriptor(superKlass, key);
  var reporter = new SyntaxErrorReporter(superKlass, target, superDescriptor, descriptor);

  if (superDescriptor === undefined) {
    var suggestedKey = findPossibleAlternatives(superKlass, key);
    var suggestion = suggestedKey ? '\n\n  Did you mean "' + suggestedKey + '"?' : '';
    reporter.error('No descriptor matching {child} was found on the prototype chain.' + suggestion);
  }

  checkDescriptors(superDescriptor, descriptor, reporter);

  return descriptor;
}

function override() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warn = exports.getOwnKeys = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;

exports.isDescriptor = isDescriptor;
exports.decorate = decorate;
exports.metaFor = metaFor;
exports.getOwnPropertyDescriptors = getOwnPropertyDescriptors;
exports.createDefaultSetter = createDefaultSetter;
exports.bind = bind;
exports.internalDeprecation = internalDeprecation;

var _lazyInitialize = require('../lazy-initialize');

var _lazyInitialize2 = _interopRequireDefault(_lazyInitialize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var defineProperty = Object.defineProperty,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
    getOwnPropertyNames = Object.getOwnPropertyNames,
    getOwnPropertySymbols = Object.getOwnPropertySymbols;
function isDescriptor(desc) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  var keys = ['value', 'initializer', 'get', 'set'];

  for (var i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function decorate(handleDescriptor, entryArgs) {
  if (isDescriptor(entryArgs[entryArgs.length - 1])) {
    return handleDescriptor.apply(undefined, _toConsumableArray(entryArgs).concat([[]]));
  } else {
    return function () {
      return handleDescriptor.apply(undefined, _toConsumableArray(Array.prototype.slice.call(arguments)).concat([entryArgs]));
    };
  }
}

var Meta = (_class = function Meta() {
  _classCallCheck(this, Meta);

  _initDefineProp(this, 'debounceTimeoutIds', _descriptor, this);

  _initDefineProp(this, 'throttleTimeoutIds', _descriptor2, this);

  _initDefineProp(this, 'throttlePreviousTimestamps', _descriptor3, this);

  _initDefineProp(this, 'throttleTrailingArgs', _descriptor4, this);

  _initDefineProp(this, 'profileLastRan', _descriptor5, this);
}, (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'debounceTimeoutIds', [_lazyInitialize2.default], {
  enumerable: true,
  initializer: function initializer() {
    return {};
  }
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'throttleTimeoutIds', [_lazyInitialize2.default], {
  enumerable: true,
  initializer: function initializer() {
    return {};
  }
}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'throttlePreviousTimestamps', [_lazyInitialize2.default], {
  enumerable: true,
  initializer: function initializer() {
    return {};
  }
}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, 'throttleTrailingArgs', [_lazyInitialize2.default], {
  enumerable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, 'profileLastRan', [_lazyInitialize2.default], {
  enumerable: true,
  initializer: function initializer() {
    return null;
  }
})), _class);


var META_KEY = typeof Symbol === 'function' ? Symbol('__core_decorators__') : '__core_decorators__';

function metaFor(obj) {
  if (obj.hasOwnProperty(META_KEY) === false) {
    defineProperty(obj, META_KEY, {
      // Defaults: NOT enumerable, configurable, or writable
      value: new Meta()
    });
  }

  return obj[META_KEY];
}

var getOwnKeys = exports.getOwnKeys = getOwnPropertySymbols ? function (object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
} : getOwnPropertyNames;

function getOwnPropertyDescriptors(obj) {
  var descs = {};

  getOwnKeys(obj).forEach(function (key) {
    return descs[key] = getOwnPropertyDescriptor(obj, key);
  });

  return descs;
}

function createDefaultSetter(key) {
  return function set(newValue) {
    Object.defineProperty(this, key, {
      configurable: true,
      writable: true,
      // IS enumerable when reassigned by the outside word
      enumerable: true,
      value: newValue
    });

    return newValue;
  };
}

function bind(fn, context) {
  if (fn.bind) {
    return fn.bind(context);
  } else {
    return function __autobind__() {
      return fn.apply(context, arguments);
    };
  }
}

var warn = exports.warn = function () {
  if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) !== 'object' || !console || typeof console.warn !== 'function') {
    return function () {};
  } else {
    return bind(console.warn, console);
  }
}();

var seenDeprecations = {};
function internalDeprecation(msg) {
  if (seenDeprecations[msg] !== true) {
    seenDeprecations[msg] = true;
    warn('DEPRECATION: ' + msg);
  }
}
},{"../lazy-initialize":29}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultConsole = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = profile;

var _utils = require('./private/utils');

var oc = console;

// Exported for mocking in tests
var defaultConsole = exports.defaultConsole = {
  profile: console.profile ? (0, _utils.bind)(console.profile, console) : function () {},
  profileEnd: console.profileEnd ? (0, _utils.bind)(console.profileEnd, console) : function () {},
  warn: _utils.warn
};

function handleDescriptor(target, key, descriptor, _ref) {
  var _ref2 = _slicedToArray(_ref, 3),
      _ref2$ = _ref2[0],
      prefix = _ref2$ === undefined ? null : _ref2$,
      _ref2$2 = _ref2[1],
      onceThrottleOrFunction = _ref2$2 === undefined ? false : _ref2$2,
      _ref2$3 = _ref2[2],
      console = _ref2$3 === undefined ? defaultConsole : _ref2$3;

  if (!profile.__enabled) {
    if (!profile.__warned) {
      console.warn('console.profile is not supported. All @profile decorators are disabled.');
      profile.__warned = true;
    }
    return descriptor;
  }

  var fn = descriptor.value;

  if (prefix === null) {
    prefix = target.constructor.name + '.' + key;
  }

  if (typeof fn !== 'function') {
    throw new SyntaxError('@profile can only be used on functions, not: ' + fn);
  }

  return _extends({}, descriptor, {
    value: function value() {
      var now = Date.now();
      var meta = (0, _utils.metaFor)(this);
      if (onceThrottleOrFunction === true && !meta.profileLastRan || onceThrottleOrFunction === false || typeof onceThrottleOrFunction === 'number' && now - meta.profileLastRan > onceThrottleOrFunction || typeof onceThrottleOrFunction === 'function' && onceThrottleOrFunction.apply(this, arguments)) {
        console.profile(prefix);
        meta.profileLastRan = now;
      }

      try {
        return fn.apply(this, arguments);
      } finally {
        console.profileEnd(prefix);
      }
    }
  });
}

function profile() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}

// Only Chrome, Firefox, and Edge support profile.
// Exposing properties for testing.
profile.__enabled = !!console.profile;
profile.__warned = false;
},{"./private/utils":35}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = readonly;

var _utils = require('./private/utils');

function handleDescriptor(target, key, descriptor) {
  descriptor.writable = false;
  return descriptor;
}

function readonly() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = suppressWarnings;

var _utils = require('./private/utils');

function suppressedWarningNoop() {
  // Warnings are currently suppressed via @suppressWarnings
}

function applyWithoutWarnings(context, fn, args) {
  if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === 'object') {
    var nativeWarn = console.warn;
    console.warn = suppressedWarningNoop;
    var ret = fn.apply(context, args);
    console.warn = nativeWarn;
    return ret;
  } else {
    return fn.apply(context, args);
  }
}

function handleDescriptor(target, key, descriptor) {
  return _extends({}, descriptor, {
    value: function suppressWarningsWrapper() {
      return applyWithoutWarnings(this, descriptor.value, arguments);
    }
  });
}

function suppressWarnings() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = throttle;

var _utils = require('./private/utils');

var DEFAULT_TIMEOUT = 300;

function handleDescriptor(target, key, descriptor, _ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      _ref2$ = _ref2[0],
      wait = _ref2$ === undefined ? DEFAULT_TIMEOUT : _ref2$,
      _ref2$2 = _ref2[1],
      options = _ref2$2 === undefined ? {} : _ref2$2;

  var callback = descriptor.value;

  if (typeof callback !== 'function') {
    throw new SyntaxError('Only functions can be throttled');
  }

  if (options.leading !== false) {
    options.leading = true;
  }

  if (options.trailing !== false) {
    options.trailing = true;
  }

  return _extends({}, descriptor, {
    value: function value() {
      var _this = this;

      var meta = (0, _utils.metaFor)(this);
      var throttleTimeoutIds = meta.throttleTimeoutIds,
          throttlePreviousTimestamps = meta.throttlePreviousTimestamps;

      var timeout = throttleTimeoutIds[key];
      // last execute timestamp
      var previous = throttlePreviousTimestamps[key] || 0;
      var now = Date.now();

      if (options.trailing) {
        meta.throttleTrailingArgs = arguments;
      }

      // if first be called and disable the execution on the leading edge
      // set last execute timestamp to now
      if (!previous && options.leading === false) {
        previous = now;
      }

      var remaining = wait - (now - previous);

      if (remaining <= 0) {
        clearTimeout(timeout);
        delete throttleTimeoutIds[key];
        throttlePreviousTimestamps[key] = now;
        callback.apply(this, arguments);
      } else if (!timeout && options.trailing) {
        throttleTimeoutIds[key] = setTimeout(function () {
          throttlePreviousTimestamps[key] = options.leading === false ? 0 : Date.now();
          delete throttleTimeoutIds[key];
          callback.apply(_this, meta.throttleTrailingArgs);
          // don't leak memory!
          meta.throttleTrailingArgs = null;
        }, remaining);
      }
    }
  });
}

function throttle() {
  (0, _utils.internalDeprecation)('@throttle is deprecated and will be removed shortly. Use @throttle from lodash-decorators.\n\n  https://www.npmjs.com/package/lodash-decorators');

  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultConsole = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = time;

var _utils = require('./private/utils');

var labels = {};

// Exported for mocking in tests
var defaultConsole = exports.defaultConsole = {
  time: console.time ? console.time.bind(console) : function (label) {
    labels[label] = new Date();
  },
  timeEnd: console.timeEnd ? console.timeEnd.bind(console) : function (label) {
    var timeNow = new Date();
    var timeTaken = timeNow - labels[label];
    delete labels[label];
    console.log(label + ': ' + timeTaken + 'ms');
  }
};

var count = 0;

function handleDescriptor(target, key, descriptor, _ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      _ref2$ = _ref2[0],
      prefix = _ref2$ === undefined ? null : _ref2$,
      _ref2$2 = _ref2[1],
      console = _ref2$2 === undefined ? defaultConsole : _ref2$2;

  var fn = descriptor.value;

  if (prefix === null) {
    prefix = target.constructor.name + '.' + key;
  }

  if (typeof fn !== 'function') {
    throw new SyntaxError('@time can only be used on functions, not: ' + fn);
  }

  return _extends({}, descriptor, {
    value: function value() {
      var label = prefix + '-' + count;
      count++;
      console.time(label);

      try {
        return fn.apply(this, arguments);
      } finally {
        console.timeEnd(label);
      }
    }
  });
}

function time() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _utils.decorate)(handleDescriptor, args);
}
},{"./private/utils":35}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.safeSetTimeout = safeSetTimeout;
exports.safeSetInterval = safeSetInterval;
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Wrapper around setTimout which (in node) unrefs the returned timer to avoid
 * wedging the process open unexpectedly.
 * @param {Mixed} args
 * @protected
 * @returns {Timer|Number}
 */
function safeSetTimeout() {
  var timer = setTimeout.apply(undefined, arguments);
  if (timer.unref) {
    timer.unref();
  }
  return timer;
}

/**
 * Wrapper around setTimout which (in node) unrefs the returned timer to avoid
 * wedging the process open unexpectedly.
 * @param {Mixed} args
 * @protected
 * @returns {Timer|Number}
 */
function safeSetInterval() {
  var interval = setInterval.apply(undefined, arguments);
  if (interval.unref) {
    interval.unref();
  }
  return interval;
}


},{}],42:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _dec, _dec2, _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13;

var _lodashDecorators = require('lodash-decorators');

var _coreDecorators = require('core-decorators');

var _common = require('@ciscospark/common');

var _commonEvented = require('@ciscospark/common-evented');

var _commonEvented2 = _interopRequireDefault(_commonEvented);

var _ampersandEvents = require('ampersand-events');

var _ampersandEvents2 = _interopRequireDefault(_ampersandEvents);

var _sdpTransform = require('sdp-transform');

var _grammar = require('sdp-transform/lib/grammar');

var _grammar2 = _interopRequireDefault(_grammar);

var _webrtcHelpers = require('./webrtc-helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _initDefineProp(target, property, descriptor, context) {
  if (!descriptor) return;
  (0, _defineProperty2.default)(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
}

// Add support for our custom "content" attribute. Note: this seems to make
// parse() work correctly, but I don't think I could get write() to work.
if (!_grammar2.default.a.find(function (g) {
  return g.name === 'content';
})) {
  _grammar2.default.a.unshift({
    // name appears to be where we stick the value of this field in the parsed
    // media object
    name: 'content',
    // reg determines whether or not this line should be handled by this rule
    reg: /^content:(slides)/
  });
}

var DirectionContainer = (0, _common.make)(_weakMap2.default, _map2.default);
var targetMediaDirection = new DirectionContainer();

var capitalize = {
  audio: 'Audio',
  video: 'Video'
};

/**
 * Wrapper around targetMediaDirection.get which return `inactive` instead of
 * undefined
 * @param {WebRTCMediaEngine} target
 * @param {string} kind
 * @private
 * @returns {string}
 */
function getTargetMediaDirection(target, kind) {
  return targetMediaDirection.get(target, kind) || 'inactive';
}

/**
 * Interface for doing webrtc things
 * @protected
 */
var WebRTCMediaEngine = (_dec = (0, _common.whileInFlight)('gumming'), _dec2 = (0, _lodashDecorators.debounce)(500), (_class = function () {
  (0, _createClass3.default)(WebRTCMediaEngine, [{
    key: 'audioDirection',


    /**
     * Returns the current audio direction
     * @returns {string}
     */
    get: function get() {
      return (0, _webrtcHelpers.getMediaDirectionFromTracks)('audio', this.pc);
    }

    /**
     * Returns the current video direction
     * @returns {string}
     */

  }, {
    key: 'videoDirection',
    get: function get() {
      return (0, _webrtcHelpers.getMediaDirectionFromTracks)('video', this.pc);
    }

    /**
     * Returns the current screen direction
     * @returns {string}
     */

  }, {
    key: 'screenDirection',
    get: function get() {
      return !this.localScreenShare || this.localScreenShare.getTracks().length === 0 ? 'inactive' : 'sendonly';
    }

    /**
     * Constructor
     * @param {Object} attrs
     * @param {Object} options
     * @param {Logger} options.logger (optional): defaults to console
     * @returns {WebRTCMediaEngine}
     */

  }], [{
    key: 'getUserMedia',

    /**
     * Wrapper around navigator.mediaDevices.getUserMedia
     *
     * @param {MediaStreamContraints} constraints
     * @returns {Promise<MediaStream>}
     */
    value: function getUserMedia(constraints) {
      var finalConstraints = (0, _defaults3.default)({}, constraints, { fake: process.env.NODE_ENV === 'test' });
      return navigator.mediaDevices.getUserMedia(finalConstraints);
    }
    /**
     * Represents the local party's outgoing stream. Instantiated when the class
     * is instantiated.
     * @type {MediaStream}
     */

    /**
     * Represent the remote party's incoming media. Instantiated when the class is
     * instantiated.
     * @type {MediaStream}
     */

    /**
     * Reserved for future use
     * @type {MediaStream}
     */


    /**
     * Peer Connection
     * @type {RTCPeerConnection}
     */

    /**
     * The most-recently produced offer
     * @private
     */

    /**
     * The most-recently accepted answer
     * @private
     */

  }]);

  function WebRTCMediaEngine() {
    var _this = this;

    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, WebRTCMediaEngine);
    this.logger = console;

    _initDefineProp(this, 'localMediaStream', _descriptor, this);

    _initDefineProp(this, 'remoteMediaStream', _descriptor2, this);

    _initDefineProp(this, 'localScreenShare', _descriptor3, this);

    this.pc = new RTCPeerConnection({
      iceServers: [],
      bundlePolicy: 'max-compat'
    });

    _initDefineProp(this, 'offerSdp', _descriptor4, this);

    _initDefineProp(this, 'answerSdp', _descriptor5, this);

    _initDefineProp(this, 'sendingAudio', _descriptor6, this);

    _initDefineProp(this, 'sendingVideo', _descriptor7, this);

    _initDefineProp(this, 'receivingAudio', _descriptor8, this);

    _initDefineProp(this, 'receivingVideo', _descriptor9, this);

    _initDefineProp(this, 'ended', _descriptor10, this);

    this.negotiationNeeded = false;
    this.bandwidthLimit = {
      audioBandwidthLimit: 60000,
      videoBandwidthLimit: 1000000
    };

    _initDefineProp(this, 'constraints', _descriptor11, this);

    _initDefineProp(this, 'offerOptions', _descriptor12, this);

    _initDefineProp(this, 'gumming', _descriptor13, this);

    if (options.parent) {
      // This is a bit of weirdness to maintain amp-state compatibility
      process.nextTick(function () {
        if (options.parent.logger) {
          _this.logger = options.parent.logger;
        }
      });
    } else if (attrs.logger) {
      this.logger = attrs.logger;
    }

    this.pc.onnegotiationneeded = function () {
      if (_this.answerSdp && !_this.negotiationNeeded) {
        _this.logger.info('peer connection emitted negotiationneeded');
        _this.negotiationNeeded = true;
        _this.triggerNegotiationNeeded();
      }
    };

    // Note: adapter.js doesn't seem to fully shim the track event.
    // addEventListener doesn't appear to work for it in chrome
    this.pc.ontrack = function (event) {
      _this.trigger('track');
      var stream = _this.remoteMediaStream || new MediaStream();
      event.streams[0].getTracks().forEach(function (track) {
        stream.addTrack(track);
        track.onended = function () {
          stream.removeTrack(track);
          track.onended = undefined;
          try {
            _this['receiving' + capitalize[track.kind]] = (0, _webrtcHelpers.getMediaDirectionFromTracks)(track.kind, _this.pc).includes('recv');
          } catch (err) {
            _this['receiving' + capitalize[track.kind]] = false;
          }
        };

        _this['receiving' + capitalize[track.kind]] = (0, _webrtcHelpers.getMediaDirectionFromTracks)(track.kind, _this.pc).includes('recv');
      });
      _this.remoteMediaStream = stream;
      _this.trigger('internalTrackUpdate');
    };
  }

  /* eslint-disable complexity */
  /**
   * Determines if ice gathering is necessary and sends it up when appropriate
   * @private
   * @returns {Promise|undefined}
   */


  (0, _createClass3.default)(WebRTCMediaEngine, [{
    key: '_prepareIceGatherer',
    value: function _prepareIceGatherer() {
      var _this2 = this;

      var needsIce = false;
      if (this.pc.iceGatheringState === 'new') {
        this.logger.info('ice gathering is in state "new", definitely need to block for ice gathering');
        needsIce = true;
      } else {
        var sdp = (0, _sdpTransform.parse)(this.pc.localDescription.sdp);
        ['audio', 'video', 'screen'].forEach(function (kind) {
          var directionKey = kind + 'Direction';
          if (_this2[directionKey] !== 'inactive' || getTargetMediaDirection(_this2, kind) !== _this2[directionKey] && getTargetMediaDirection(_this2, kind) !== 'inactive') {
            var media = sdp.media.find(function (m) {
              return m.type === kind;
            });
            if (media) {
              _this2.logger.info(kind + ' candidates already gathered');
            } else {
              _this2.logger.info('transitioning ' + kind + ' from inactive, ice needed');
              needsIce = true;
            }
          }
        });
      }

      var icePromise = void 0;
      if (needsIce) {
        icePromise = new _promise2.default(function (resolve) {
          _this2.logger.info('configuring ice gathering');
          _this2.pc.onicecandidate = function (event) {
            if (!event.candidate) {
              _this2.logger.info('ice gathering complete');
              _this2.pc.onicecandidate = undefined;
              resolve();
              return;
            }

            _this2.logger.info('got ice candidate');
          };
        });
      }

      return icePromise;
    }

    /* eslint-enable complexity */

    /**
     * Creates an offer SDP
     * @returns {Promise<string>}
     */

  }, {
    key: 'createOffer',
    value: function createOffer() {
      var _this3 = this;

      this.logger.info('beginning negotiation');

      var td = getTargetMediaDirection(this, 'video');
      var wantsVideo = td.includes('send') || td.includes('recv');

      var icePromise = this._prepareIceGatherer();

      return new _promise2.default(function (resolve) {
        if (_this3.gumming) {
          _this3.logger.info('gum in flight, waiting until it completes');
          // Since gum is protected by @oneflight, returning it here will block
          // until it completes but, more importantly, propagate a thrown
          // exception up the stack
          resolve(_this3._getUserMedia().then((0, _common.tap)(function () {
            return _this3.logger.info('gum completed');
          })));
          return;
        }

        resolve();
      }).then((0, _common.tap)(function () {
        return _this3.logger.info('starting create offer', _this3.offerOptions);
      })).then(function () {
        // This is a (hopefully temporary) hack to deal with the fact that one
        // out of two browsers removes the remote stream when offerToReceive* is
        // false. We've already made the choice to disable the stream, but we
        // want to make sure we're still willing to receive an answer for it.
        _this3.offerOptions.offerToReceiveAudio = _this3.offerOptions.offerToReceiveAudio || !!_this3.pc.getReceivers().find(function (r) {
          return r.track.kind === 'audio';
        });
        _this3.offerOptions.offerToReceiveVideo = _this3.offerOptions.offerToReceiveVideo || !!_this3.pc.getReceivers().find(function (r) {
          return r.track.kind === 'video';
        });
        _this3.logger.info('creating REAL offer', _this3.offerOptions);
        return _this3.pc.createOffer(_this3.offerOptions);
      }).then((0, _common.tap)(function (offer) {
        offer.sdp = (0, _webrtcHelpers.limitBandwith)(_this3.bandwidthLimit, offer.sdp);
      })).then((0, _common.tap)(function () {
        return _this3.logger.info('setting local description');
      })).then(function (offer) {
        return _this3.pc.setLocalDescription(offer);
      }).then((0, _common.tap)(function () {
        return icePromise && _this3.logger.info('blocking for ice gathering');
      })).then(function () {
        return icePromise;
      }).then((0, _common.tap)(function () {
        return _this3.logger.info('limiting bandwith');
      })).then(function () {
        return (0, _webrtcHelpers.limitBandwith)(_this3.bandwidthLimit, _this3.pc.localDescription.sdp);
      }).then((0, _common.tap)(function () {
        return wantsVideo && _this3.logger.info('confirm h264 in offer');
      })).then((0, _webrtcHelpers.ensureH264)(wantsVideo)).then(function (sdp) {
        if (_this3.localScreenShare) {
          // Add content descriptor to the local sdp
          var streamId = _this3.localScreenShare.id;
          var track = _this3.localScreenShare.getVideoTracks()[0];
          if (track) {
            var trackId = track.id;
            var msid = streamId + ' ' + trackId;
            var sections = sdp.split(msid);
            if (sections[1]) {
              sections[1] = '\r\na=content:slides' + sections[1];
              sdp = sections.join(msid);
              return sdp;
            }
          }

          sdp += 'a=content:slides\r\n';
        }
        return sdp;
      }).then((0, _common.tap)(function (sdp) {
        _this3.offerSdp = sdp;
      }));
    }

    /**
     * Receives an answer SDP
     * @param {string} sdp
     * @returns {Promise}
     */

  }, {
    key: 'acceptAnswer',
    value: function acceptAnswer(sdp) {
      var _this4 = this;

      this.logger.info('accepting answer');

      // Allow larger frames (this makes screenshare look *way* better, but no
      // idea what impact it's having on the camera stream - we may want to limit
      // it to just screen share at some future point)
      var defaultCodecParams = /max-mbps=27600;max-fs=920/g;
      var newCodecParams = 'max-mbps=27600;max-fs=8160';
      sdp = sdp.replace(defaultCodecParams, newCodecParams);

      // If the screenshare goes inactive, make sure the sdp includes a direction
      // config
      sdp = sdp.replace(/m=video 0(.*?\r\n)/, 'm=video 0$1a=inactive\r\n');
      return this.pc.setRemoteDescription(new RTCSessionDescription({
        sdp: sdp,
        type: 'answer'
      })).then(function () {
        _this4.logger.info('answer accepted');
        _this4.answerSdp = sdp;
        _this4.sendingAudio = (0, _webrtcHelpers.getMediaDirectionFromTracks)('audio', _this4.pc).includes('send');
        _this4.sendingVideo = (0, _webrtcHelpers.getMediaDirectionFromTracks)('video', _this4.pc).includes('send');
        _this4.trigger('answeraccepted');
        _this4.negotiationNeeded = false;
      });
    }
    /**
     * {@link MediaStreamConstraints} that'll be used for the next call to
     * {@link WebRTCMediaEngine.getUserMedia()}
     * @private
     * @type {MediaStreamConstraints}
     */

    /**
     * {@link RTCOfferOptions} that'll be used for the next call to
     * {@link RTCPeerConnection.createOffer}
     * @private
     * @type {RTCOfferOptions}
     */

    /**
     * Indicates whether or not a call to {@link MediaDevices#getUserMedia()} is
     * in flight
     * @private
     * @type {boolean}
     */

  }, {
    key: '_setNewMediaDirection',


    /**
     * Change media direction without consumer provided tracks or complex
     * constraints
     * @param {string} kind
     * @param {string} direction
     * @private
     * @returns {undefined}
     */
    value: function _setNewMediaDirection(kind, direction) {
      var _this5 = this;

      this.logger.info('setting ' + kind + ' direction to ' + direction);
      var constraint = direction.includes('send');
      this.constraints[kind] = constraint;

      if (constraint) {
        if (!this[kind + 'Direction'].includes('send')) {
          this._setNewMediaConstraint(kind, constraint);
        }
      } else {
        this.logger.info('removing any no-longer-needed ' + kind + ' tracks');
        if (!this.localMediaStream) {
          return;
        }
        this.localMediaStream.getTracks().filter(function (t) {
          return t.kind === kind;
        }).forEach(function (t) {
          _this5.logger.info('removing ' + kind + ' track ' + t.id + ' from localMediaStream');
          _this5.localMediaStream.removeTrack(t);
          _this5.logger.info('removing ' + kind + ' track ' + t.id + ' from peer connection');
          // Note: Doesn't like removing senders whose tracks are not live, so
          // t.stop() has to come after removeTrack()
          try {
            _this5.pc.removeTrack(_this5.pc.getSenders().find(function (s) {
              return s.track && s.track === t;
            }));
          } catch (err) {
            if (t.readyState === 'ended') {
              _this5.logger.warn('Suppressing error caused by trying to remove an ended track from a peer connection');
            } else {
              _this5.logger.warn('suppressing removeTrack error. We don\'t know why firefox does this, but we\'re still going to make sure the track is stopped');
            }
            _this5.logger.warn(err);
          }
          _this5.logger.info('setting sending' + capitalize[kind] + ' to ' + constraint);
          _this5['sending' + capitalize[kind]] = constraint;
          _this5.logger.info('stopping ' + kind + ' track ' + t.id);
          t.stop();
        });
      }
    }

    /**
     * Sets or replaces current track for $kind
     * @param {string} kind
     * @param {MediaStreamTrack} track
     * @returns {undefined}
     */

  }, {
    key: '_setNewMediaTrack',
    value: function _setNewMediaTrack(kind, track) {
      this.logger.info('setting new ' + kind + ' track');
      this.constraints[kind] = false;
      this.addOrReplaceTrack(track);
    }

    /**
     * Causes track for ${kind} to be set or replaced according to $constraint
     * @param {string} kind
     * @param {Object|boolean} constraint
     * @returns {undefined}
     */

  }, {
    key: '_setNewMediaConstraint',
    value: function _setNewMediaConstraint(kind, constraint) {
      this.logger.info('setting ' + kind + ' with new constraint');
      this.constraints[kind] = constraint;
      this._getUserMedia();
    }

    /**
     * Starts or stops an outbound screenshare
     *
     * @param {string} direction currently only inactive or sendonly
     * @param {Object|MediaStreamTrack} trackOrConstraint
     * @returns {Promise}
     */

  }, {
    key: '_setScreenShare',
    value: function _setScreenShare(direction, trackOrConstraint) {
      var _this6 = this;

      this.logger.info('calling _setScreenShare');
      targetMediaDirection.set(this, 'screen', direction);
      if (direction.includes('send')) {
        var constraint = (0, _defaults3.default)({}, trackOrConstraint, {
          mediaSource: 'application',
          width: {
            min: '160',
            max: '1920'
          },
          height: {
            min: '90',
            max: '1080'
          },
          frameRate: {
            min: '1',
            max: '30'
          }
        });

        this._setNewMediaConstraint('screen', constraint);
        return;
      }

      this.logger.info('removing existing screenshare tracks from peer connection and localScreenShare stream');
      this.pc.getSenders().filter(function (s) {
        return s.track && _this6.localScreenShare.getTracks().includes(s.track);
      }).forEach(function (s) {
        _this6.logger.info('removing screenshare track ' + s.track.id + ' from peer connection and localScreenShare stream');
        var senderTrack = s.track;
        _this6.pc.removeTrack(s);
        _this6.localScreenShare.removeTrack(senderTrack);
        senderTrack.stop();

        _this6.logger.info('removed screenshare track ' + senderTrack.id + ' from peer connection and localScreenShare stream');
      });
    }

    // I don't see any further ways to reduce complexity without hurting
    // readability
    /* eslint-disable complexity */
    /**
     * Sets a media direction for a given media type. Almost certainly triggers
     * renegotiation. This is the method to use if you want to replace a track.
     * @param {string} kind audio|video
     * @param {string} direction sendonly|recvonly|sendrecv|inactive
     * @param {MediaStreamTrack|Object} trackOrConstraint
     * @returns {Promise}
     */

  }, {
    key: 'setMedia',
    value: function setMedia(kind, direction, trackOrConstraint) {
      this.logger.info('setMedia');
      if (kind === 'screen') {
        this.logger.info('setMedia: setting new screen direction');
        this._setScreenShare(direction, trackOrConstraint);
        return;
      }
      if (trackOrConstraint) {
        if (!direction.includes('send')) {
          throw new Error('Cannot set new ' + kind + ' track or constraint if direction does not include send');
        }

        if (trackOrConstraint instanceof MediaStreamTrack) {
          if (trackOrConstraint.kind !== kind) {
            throw new Error('track is not a valid ' + kind + ' media stream track');
          }

          this._setNewMediaTrack(kind, trackOrConstraint);
        } else {
          this._setNewMediaConstraint(kind, trackOrConstraint);
        }
      } else {
        if (direction === getTargetMediaDirection(this, kind)) {
          this.logger.info('setMedia: ' + kind + ' already transitioning to ' + direction + ', not making changes');
          return;
        }

        if (direction === this[kind + 'Direction']) {
          this.logger.info('setMedia: ' + kind + ' already set to ' + direction + ', not making changes');
          return;
        }
        this._setNewMediaDirection(kind, direction);
      }

      var shouldRecv = direction.includes('recv');

      targetMediaDirection.set(this, kind, direction);

      this.offerOptions['offerToReceive' + (0, _webrtcHelpers.kindToPropertyFragment)(kind)] = shouldRecv;

      if (shouldRecv) {
        if (this.remoteMediaStream && this.remoteMediaStream.getTracks().find(function (t) {
          return t.kind === kind;
        })) {
          this.unpauseReceivingMedia(kind);
        } else if (this.answerSdp) {
          this.triggerNegotiationNeeded();
        }
      } else if (this.remoteMediaStream && this.remoteMediaStream.getTracks().find(function (t) {
        return t.kind === kind;
      })) {
        this.pauseReceivingMedia(kind);
      }
    }

    /* eslint-enable complexity */

  }, {
    key: '_getUserMedia',

    /**
     * Wrapper around {@link MediaDevices#getUserMedia()} that delays the call one
     * tick to reduce the number of permissions dialogs presented to the user.
     * @name _getUserMedia
     * @returns {Promise<MediaStream>}
     */
    // It's not missing, but the decorator is throwing off eslint
    // eslint-disable-next-line require-jsdoc
    value: function _getUserMedia() {
      var _this7 = this;

      this.logger.info('enqueing request to get user media');
      return new _promise2.default(function (resolve) {
        return process.nextTick(resolve);
      }).then(function () {
        if (_this7.constraints.audio === true && _this7.pc.getSenders().find(function (s) {
          return s.track && s.track.kind === 'audio';
        })) {
          _this7.logger.info('already have a local audio track, removing constraint for a second one');
          (0, _deleteProperty2.default)(_this7.constraints, 'audio');
        }

        if (_this7.constraints.video === true && _this7.pc.getSenders().find(function (s) {
          return s.track && s.track.kind === 'video';
        })) {
          _this7.logger.info('already have a local video track, removing constraint for a second one');
          (0, _deleteProperty2.default)(_this7.constraints, 'video');
        }

        var _constraints = _this7.constraints,
            audio = _constraints.audio,
            video = _constraints.video,
            screen = _constraints.screen;


        return _promise2.default.all([(audio || video) && WebRTCMediaEngine.getUserMedia({ audio: audio, video: video }), screen && WebRTCMediaEngine.getUserMedia({ video: screen })]);
      }).then(function (_ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            userStream = _ref2[0],
            screenStream = _ref2[1];

        if (userStream) {
          _this7.logger.info('got local media stream with ' + userStream.getAudioTracks().length + ' audio tracks and ' + userStream.getVideoTracks().length + ' video tracks');
          userStream.getTracks().forEach(function (t) {
            return _this7.addOrReplaceTrack(t);
          });
        }

        if (screenStream) {
          if (_this7.localScreenShare) {
            _this7.logger.info('removing existing screenshare tracks from peer connection and localScreenShare stream');
            _this7.pc.getSenders().filter(function (s) {
              return _this7.localScreenShare.getTracks().includes(s.track);
            }).forEach(function (s) {
              _this7.pc.removeTrack(s);
              _this7.localScreenShare.removeTrack(s.track);
            });

            _this7.logger.info('adding new screen track to localScreenShare stream');
            screenStream.getTracks().forEach(function (t) {
              _this7.localScreenShare.addTrack(t);
              _this7.pc.addTrack(t, _this7.localScreenShare);
            });
          } else {
            _this7.logger.info('adding localScreenShare for the first time');
            _this7.localScreenShare = screenStream;

            _this7.logger.info('adding new screenshare track to peer connection');
            screenStream.getVideoTracks().forEach(function (t) {
              return _this7.pc.addTrack(t, screenStream);
            });
          }
        }

        _this7.constraints = {};
      }).catch(function (err) {
        _this7.trigger('error', err);
        return _promise2.default.reject(err);
      });
    }

    /**
     * adds or replaces a local @{link MediaStreamTrack}
     * @private
     * @param {MediaStreamTrack} track
     * @returns {undefined}
     */

  }, {
    key: 'addOrReplaceTrack',
    value: function addOrReplaceTrack(track) {
      if (!this.localMediaStream) {
        this.localMediaStream = new MediaStream();
      }
      this.logger.info('preparing to add ' + track.kind + ' to local media stream');
      var existing = this.pc.getSenders().find(function (s) {
        return s.track && s.track.kind === track.kind && s.track !== track;
      });
      if (existing) {
        this.logger.info('removing previous ' + track.kind + ' from local media stream');
        // Track object is removed from existing after calling `pc.removeTrack`
        var existingTrack = existing.track;
        this.pc.removeTrack(existing);
        this.localMediaStream.removeTrack(existingTrack);
        // it may not be appropriate to stop the track if it was supplied by the
        // engine consumer, but I'm inclined not to deal with that unless it
        // becomes a real issue.
        track.stop();
      }

      this.logger.info('adding ' + track.kind + ' to local media stream');
      this.localMediaStream.addTrack(track);
      this.logger.info('adding ' + track.kind + ' to peer connection');
      this.pc.addTrack(track, this.localMediaStream);

      this.logger.info('setting sending' + capitalize[track.kind] + ' to true');
      this['sending' + capitalize[track.kind]] = true;
    }

    /**
     * Stops sending useful bits on the identified track, but does not end it (the
     * camera/mic will stay on but the remote party(s) will not see/hear anything).
     * Avoids renegotiation. Throws if `kind` does not identify a track.
     * @param {string} kind
     * @returns {Promise}
     */

  }, {
    key: 'pauseSendingMedia',
    value: function pauseSendingMedia(kind) {
      var _this8 = this;

      if (!kind) {
        throw new Error('kind is required');
      }
      var senders = this.pc.getSenders().filter(function (s) {
        return s.track && s.track.kind === kind;
      });

      if (senders.length === 0) {
        throw new Error('No ' + kind + ' media senders to pause');
      }

      senders.forEach(function (s) {
        _this8.logger.info('pausing ' + kind + ' sender');
        s.track.enabled = false;
      });

      this.logger.info('setting sending' + capitalize[kind] + ' to false');
      this['sending' + capitalize[kind]] = false;
    }

    /**
     * Resumes sending bits on the identified track. Throws if `kind` does not
     * identify a track.
     * @param {string} kind
     * @returns {Promise}
     */

  }, {
    key: 'unpauseSendingMedia',
    value: function unpauseSendingMedia(kind) {
      var _this9 = this;

      if (!kind) {
        throw new Error('kind is required');
      }
      var senders = this.pc.getSenders().filter(function (s) {
        return s.track && s.track.kind === kind;
      });

      if (senders.length === 0) {
        throw new Error('No ' + kind + ' media senders to unpause');
      }

      senders.forEach(function (s) {
        _this9.logger.info('unpausing ' + kind + ' sender');
        s.track.enabled = true;
      });

      this.logger.info('setting sending' + capitalize[kind] + ' to true');
      this['sending' + capitalize[kind]] = true;
    }

    /**
     * Convenience function. Sets a remote track.enabled=false. Does not
     * renegotiate.Throws if `kind` does not identify a track.
     * @param {string} kind
     * @returns {Promise}
     */

  }, {
    key: 'pauseReceivingMedia',
    value: function pauseReceivingMedia(kind) {
      var _this10 = this;

      if (!kind) {
        throw new Error('kind is required');
      }
      if (!this.remoteMediaStream) {
        throw new Error('No remote media stream available');
      }
      var tracks = this.remoteMediaStream.getTracks().filter(function (t) {
        return t.kind === kind;
      });

      if (tracks.length === 0) {
        throw new Error('No remote ' + kind + ' media tracks to pause');
      }

      tracks.forEach(function (t) {
        _this10.logger.info('pausing remote ' + kind + ' track');
        t.enabled = false;
      });

      this.logger.info('setting receiving' + capitalize[kind] + ' to false');
      this['receiving' + capitalize[kind]] = false;
    }

    /**
     * Convenience function. Sets a remote track.enabled=true. Does not
     * renegotiate.Throws if `kind` does not identify a track.
     * @param {string} kind
     * @returns {Promise}
     */

  }, {
    key: 'unpauseReceivingMedia',
    value: function unpauseReceivingMedia(kind) {
      var _this11 = this;

      if (!kind) {
        throw new Error('kind is required');
      }
      if (!this.remoteMediaStream) {
        throw new Error('No remote media stream available');
      }
      var tracks = this.remoteMediaStream.getTracks().filter(function (t) {
        return t.kind === kind;
      });

      if (tracks.length === 0) {
        throw new Error('No remote ' + kind + ' media tracks to pause');
      }

      tracks.forEach(function (t) {
        if (!t.enabled) {
          _this11.logger.info('unpausing remote ' + kind + ' track');
          t.enabled = true;
        }
      });

      this.logger.info('setting receiving' + capitalize[kind] + ' to true from ' + this['receiving' + capitalize[kind]]);
      this['receiving' + capitalize[kind]] = true;
    }

    /**
     * Stops all tracks and streams, closes the peer connection, and removes all
     * listeners
     * @returns {undefined}
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (this.pc.signalingState !== 'closed') {
        this.pc.getSenders().forEach(function (s) {
          return s.track && s.track.stop();
        });
        this.pc.close();
      }

      this.pc.onnegotiationneeded = undefined;
      this.pc.ontrack = undefined;
      this.pc.onicecandidate = undefined;
      this.ended = true;
      this.off();
    }
  }, {
    key: 'triggerNegotiationNeeded',

    /**
     * Debounced helper for triggering `negotiationneeded`.
     * @private
     * @returns {undefined}
     */
    // It's not missing, but the decorator is throwing off eslint
    // eslint-disable-next-line require-jsdoc
    value: function triggerNegotiationNeeded() {
      this.trigger('negotiationneeded');
    }

    /**
     * Returns a string when attempting to serialize object
     * @returns {string}
     */

  }, {
    key: 'serialize',
    value: function serialize() {
      return 'WebRTCMediaEngine';
    }
  }]);
  return WebRTCMediaEngine;
}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'localMediaStream', [_commonEvented2.default], {
  enumerable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'remoteMediaStream', [_commonEvented2.default], {
  enumerable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'localScreenShare', [_commonEvented2.default], {
  enumerable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, 'offerSdp', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return '';
  }
}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, 'answerSdp', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return '';
  }
}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, 'sendingAudio', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, 'sendingVideo', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, 'receivingAudio', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, 'receivingVideo', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, 'ended', [_commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, 'constraints', [_coreDecorators.nonenumerable], {
  enumerable: true,
  initializer: function initializer() {
    return {};
  }
}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, 'offerOptions', [_coreDecorators.nonenumerable], {
  enumerable: true,
  initializer: function initializer() {
    return {};
  }
}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, 'gumming', [_coreDecorators.nonenumerable, _commonEvented2.default], {
  enumerable: true,
  initializer: function initializer() {
    return false;
  }
}), _applyDecoratedDescriptor(_class.prototype, '_getUserMedia', [_dec, _common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_getUserMedia'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'triggerNegotiationNeeded', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'triggerNegotiationNeeded'), _class.prototype)), _class));
exports.default = WebRTCMediaEngine;


(0, _assign2.default)(WebRTCMediaEngine.prototype, _ampersandEvents2.default);


}).call(this,require('_process'))
},{"./webrtc-helpers":45,"@ciscospark/common":55,"@ciscospark/common-evented":2,"_process":1743,"ampersand-events":673,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/define-property":687,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/slicedToArray":709,"core-decorators":66,"lodash-decorators":1349,"lodash/defaults":1618,"sdp-transform":85,"sdp-transform/lib/grammar":84}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.webrtcHelpers = exports.WebRTCMediaEngine = exports.default = undefined;

var _engine = require('./engine.js');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_engine).default;
  }
});
Object.defineProperty(exports, 'WebRTCMediaEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_engine).default;
  }
});

var _webrtcHelpers2 = require('./webrtc-helpers');

var _webrtcHelpers = _interopRequireWildcard(_webrtcHelpers2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line object-curly-spacing


exports.webrtcHelpers = _webrtcHelpers;


},{"./engine.js":42,"./webrtc-helpers":45}],44:[function(require,module,exports){
(function (process){
'use strict';

/**
 * @file webrtc-adapter-adapter
 * Yep, you read that filename right. There seems to be a bug in adapter.js that
 * doesn't quite clean up everythings it supposed to. This is an adapter for the
 * adapter that makes sure it removes the correct streams from the
 * PeerConnection's caches
 */

if (!process.env.NO_WEBRTC_ADAPTER) {
  try {
    // eslint-disable-next-line global-require
    require('webrtc-adapter');
  } catch (err) {
    // eslint-disable-next-line no-console
    console[process.env.NODE_ENV === 'production' ? 'info' : 'warn']('Failed to apply adapter.js. Are we running in an environment that disallows altering globals?', err);
  }
}


}).call(this,require('_process'))
},{"_process":1743,"webrtc-adapter":89}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ensureH264 = undefined;

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _curry2 = require('lodash/curry');

var _curry3 = _interopRequireDefault(_curry2);

exports.getMediaDirectionFromSDP = getMediaDirectionFromSDP;
exports.getMediaFromSDP = getMediaFromSDP;
exports.reverseMediaDirection = reverseMediaDirection;
exports.limitBandwith = limitBandwith;
exports.kindToPropertyFragment = kindToPropertyFragment;
exports.getMediaDirectionFromSDPForAnswer = getMediaDirectionFromSDPForAnswer;
exports.boolToDirection = boolToDirection;
exports.getMediaDirectionFromTracks = getMediaDirectionFromTracks;

require('./webrtc-adapter-adapter');

var _sdpTransform = require('sdp-transform');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Pulls the direction line for the specified media kind from an sdp
 * @param {string} kind
 * @param {string} sdp
 * @protected
 * @returns {string}
 */
// we need to import the webrtc adapter before anything else happens
/* eslint-disable import/first */

function getMediaDirectionFromSDP(kind, sdp) {
  var query = kind === 'screen' ? {
    content: 'slides',
    type: 'video'
  } : {
    type: kind
  };

  var media = (0, _find3.default)((0, _sdpTransform.parse)(sdp).media, query);
  if (!media) {
    return 'inactive';
  }

  return media.direction;
}

/**
 *
 * @param {string} kind
 * @param {string} sdp
 * @param {string} direction
 * @protected
 * @returns {object}
 */
function getMediaFromSDP(kind, sdp, direction) {
  var query = kind === 'screen' ? {
    content: 'slides',
    type: 'video'
  } : {
    type: kind
  };

  if (direction) {
    query.direction = direction;
  }

  var media = (0, _find3.default)((0, _sdpTransform.parse)(sdp).media, query);

  return media;
}

/**
 * Reverses a media direction from offer to answer (e.g. sendonly -> recvonly)
 * @param {string} direction
 * @protected
 * @returns {string}
 */
function reverseMediaDirection(direction) {
  switch (direction) {
    case 'inactive':
    case 'sendrecv':
      return direction;
    case 'sendonly':
      return 'recvonly';
    case 'recvonly':
      return 'sendonly';
    default:
      throw new Error('direction "' + direction + '" is not valid');
  }
}

/**
 * Checks a given sdp to ensure it contains an offer for the h264 codec
 * @param {boolean} wantsVideo
 * @param {string} offer
 * @protected
 * @returns {string} returns the offer to simplify use in promise chains
 */
var ensureH264 = exports.ensureH264 = (0, _curry3.default)(function (wantsVideo, offer) {
  if (wantsVideo) {
    if (!offer.includes('m=video')) {
      throw new Error('No video section found in offer');
    }
    if (!/[hH]264/.test(offer)) {
      throw new Error('Offer does not include h264 codec');
    }
  }
  return offer;
});

/**
 * Adds a bandwith limit line to the sdp; without this line, calling fails
 * @param {Object} bandwidthLimit
 * @param {string} sdp SDP
 * @protected
 * @returns {string} The modified SDP
 */
function limitBandwith(_ref, sdp) {
  var audioBandwidthLimit = _ref.audioBandwidthLimit,
      videoBandwidthLimit = _ref.videoBandwidthLimit;

  return sdp.split('\r\n').reduce(function (lines, line) {
    lines.push(line);
    if (line.startsWith('m=')) {
      lines.push('b=TIAS:' + (line.includes('audio') ? audioBandwidthLimit : videoBandwidthLimit));
    }
    return lines;
  }, []).join('\r\n');
}

/**
 * Helper for dealing wait capitalization
 * @param {string} kind audio|video
 * @protected
 * @returns {string} Audio|Video
 */
function kindToPropertyFragment(kind) {
  return kind === 'audio' ? 'Audio' : 'Video';
}

/**
 * Like get getMediaDirectionFromSDP, but reverses the the result
 * @param {string} kind
 * @param {string} offerSdp
 * @protected
 * @returns {string}
 */
function getMediaDirectionFromSDPForAnswer(kind, offerSdp) {
  return reverseMediaDirection(getMediaDirectionFromSDP(kind, offerSdp));
}

/**
 * Converts a pair of booleans to a SDP direction string
 * @param {boolean} send
 * @param {boolean} recv
 * @protected
 * @returns {string}
 */
function boolToDirection(send, recv) {
  if (send && recv) {
    return 'sendrecv';
  }

  if (send) {
    return 'sendonly';
  }

  if (recv) {
    return 'recvonly';
  }

  return 'inactive';
}

/**
 * Determines the flow of media for a given kind of media on a peer connection
 * @param {string} kind
 * @param {RTCPeerConnection} pc
 * @protected
 * @returns {string}
 */
function getMediaDirectionFromTracks(kind, pc) {
  if (pc.signalingState === 'closed') {
    return 'inactive';
  }

  var send = false;
  var senders = pc.getSenders().filter(function (s) {
    return s.track && s.track.kind === kind;
  });

  send = senders.length > 0 && senders.reduce(function (acc, s) {
    return acc && s.track.enabled;
  }, true);

  // Ideally, we'd do something like this commented code, but as of
  // webrtc-adapter@5.0.4, receivers don't accurately reflect reality in Chrome.
  // let recv = false;
  // const receivers = pc
  //   .getReceivers()
  //   .filter((r) => r.track.kind === kind);

  // recv = receivers.length > 0 && receivers.reduce((acc, s) => acc && s.track.enabled, true);

  var remoteStreams = pc.getRemoteStreams();
  var recv = remoteStreams.length > 0 && remoteStreams.reduce(function (acc1, stream) {
    var tracks = stream.getTracks().filter(function (t) {
      return t.kind === kind;
    });

    return acc1 && tracks.length > 0 && tracks.reduce(function (acc, t) {
      return acc && t.enabled;
    }, true);
  }, true);

  return boolToDirection(send, recv);
}


},{"./webrtc-adapter-adapter":44,"lodash/curry":1615,"lodash/find":1627,"sdp-transform":85}],46:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"buffer":1735,"dup":3,"urlsafe-base64":1730}],47:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":4}],48:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],49:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":6}],50:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"_process":1743,"core-decorators":66,"dup":7}],51:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":8,"lodash/isArray":1648}],52:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"babel-runtime/core-js/array/from":678,"babel-runtime/core-js/object/create":685,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/set-prototype-of":692,"babel-runtime/core-js/reflect/construct":696,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":9}],53:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],54:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./node":53,"dup":11}],55:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./base64":46,"./capped-debounce":47,"./check-required":48,"./defer":49,"./deprecated":50,"./events":51,"./exception":52,"./in-browser":54,"./make-state-datatype":56,"./one-flight":57,"./patterns.js":58,"./resolve-with":59,"./retry":60,"./tap":61,"./template-container":62,"./while-in-flight":63,"dup":12}],56:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],57:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./template-container":62,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/typeof":711,"dup":14,"lodash/wrap":1715}],58:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],59:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":16}],60:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/typeof":711,"backoff":712,"dup":17,"events":1737,"lodash/defaults":1618,"lodash/isFunction":1656,"lodash/wrap":1715}],61:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":18}],62:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":19,"util":1769}],63:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./tap":61,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":20,"lodash/wrap":1715}],64:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],65:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./private/utils":78,"dup":22}],66:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./applyDecorators":64,"./autobind":65,"./debounce":67,"./decorate":68,"./deprecate":69,"./enumerable":70,"./extendDescriptor":71,"./lazy-initialize":72,"./memoize":73,"./mixin":74,"./nonconfigurable":75,"./nonenumerable":76,"./override":77,"./profile":79,"./readonly":80,"./suppress-warnings":81,"./throttle":82,"./time":83,"dup":23}],67:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./private/utils":78,"dup":24}],68:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"./private/utils":78,"dup":25}],69:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./private/utils":78,"dup":26}],70:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./private/utils":78,"dup":27}],71:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./private/utils":78,"dup":28}],72:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./private/utils":78,"dup":29}],73:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./private/utils":78,"dup":30}],74:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./private/utils":78,"dup":31}],75:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./private/utils":78,"dup":32}],76:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./private/utils":78,"dup":33}],77:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./private/utils":78,"dup":34}],78:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"../lazy-initialize":72,"dup":35}],79:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./private/utils":78,"dup":36}],80:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./private/utils":78,"dup":37}],81:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./private/utils":78,"dup":38}],82:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./private/utils":78,"dup":39}],83:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./private/utils":78,"dup":40}],84:[function(require,module,exports){
var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{ //o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  //k: [{}], // outdated thing ignored
  t: [{ //t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{ //c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{ //b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [
    { //a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding) ?
          'rtpmap:%d %s/%s/%s':
          o.rate ?
          'rtpmap:%d %s/%s':
          'rtpmap:%d %s';
      }
    },
    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      //a=fmtp:111 minptime=10; useinbandfec=1
      push: 'fmtp',
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ['payload', 'config'],
      format: 'fmtp:%d %s'
    },
    { //a=control:streamid=0
      name: 'control',
      reg: /^control:(.*)/,
      format: 'control:%s'
    },
    { //a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null) ?
          'rtcp:%d %s IP%d %s':
          'rtcp:%d';
      }
    },
    { //a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: 'rtcp-fb:%d trr-int %d'
    },
    { //a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null) ?
          'rtcp-fb:%s %s %s':
          'rtcp-fb:%s %s';
      }
    },
    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      //a=extmap:1/recvonly URI-gps-string
      push: 'ext',
      reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
      names: ['value', 'direction', 'uri', 'config'],
      format: function (o) {
        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');
      }
    },
    { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null) ?
          'crypto:%d %s %s %s':
          'crypto:%d %s %s';
      }
    },
    { //a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: 'setup:%s'
    },
    { //a=mid:1
      name: 'mid',
      reg: /^mid:([^\s]*)/,
      format: 'mid:%s'
    },
    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: 'msid',
      reg: /^msid:(.*)/,
      format: 'msid:%s'
    },
    { //a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*)/,
      format: 'ptime:%d'
    },
    { //a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*)/,
      format: 'maxptime:%d'
    },
    { //a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    { //a=ice-lite
      name: 'icelite',
      reg: /^(ice-lite)/
    },
    { //a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: 'ice-ufrag:%s'
    },
    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: 'ice-pwd:%s'
    },
    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: 'fingerprint:%s %s'
    },
    { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
      format: function (o) {
        var str = 'candidate:%s %d %s %d %s %d typ %s';

        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

        // NB: candidate has three optional chunks, so %void middles one if it's missing
        str += (o.tcptype != null) ? ' tcptype %s' : '%v';

        if (o.generation != null) {
          str += ' generation %d';
        }

        str += (o['network-id'] != null) ? ' network-id %d' : '%v';
        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
        return str;
      }
    },
    { //a=end-of-candidates (keep after the candidates line for readability)
      name: 'endOfCandidates',
      reg: /^(end-of-candidates)/
    },
    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: 'remote-candidates:%s'
    },
    { //a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: 'ice-options:%s'
    },
    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: 'ssrcs',
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ['id', 'attribute', 'value'],
      format: function (o) {
        var str = 'ssrc:%d';
        if (o.attribute != null) {
          str += ' %s';
          if (o.value != null) {
            str += ':%s';
          }
        }
        return str;
      }
    },
    { //a=ssrc-group:FEC 1 2
      //a=ssrc-group:FEC-FR 3004364195 1080772241
      push: 'ssrcGroups',
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ['semantics', 'ssrcs'],
      format: 'ssrc-group:%s %s'
    },
    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: 'msidSemantic',
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: 'msid-semantic: %s %s' // space after ':' is not accidental
    },
    { //a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: 'group:%s %s'
    },
    { //a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    { //a=rtcp-rsize
      name: 'rtcpRsize',
      reg: /^(rtcp-rsize)/
    },
    { //a=sctpmap:5000 webrtc-datachannel 1024
      name: 'sctpmap',
      reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
      names: ['sctpmapNumber', 'app', 'maxMessageSize'],
      format: function (o) {
        return (o.maxMessageSize != null) ?
          'sctpmap:%s %s %s' :
          'sctpmap:%s %s';
      }
    },
    { //a=x-google-flag:conference
      name: 'xGoogleFlag',
      reg: /^x-google-flag:([^\s]*)/,
      format: 'x-google-flag:%s'
    },
    { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: 'rids',
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ['id', 'direction', 'params'],
      format: function (o) {
        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
      }
    },
    { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      //a=imageattr:* send [x=800,y=640] recv *
      //a=imageattr:100 recv [x=320,y=240]
      push: 'imageattrs',
      reg: new RegExp(
        //a=imageattr:97
        '^imageattr:(\\d+|\\*)' +
        //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
        '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
        //recv [x=330,y=250]
        '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
      ),
      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
      format: function (o) {
        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      //a=simulcast:recv 1;4,5 send 6;7
      name: 'simulcast',
      reg: new RegExp(
        //a=simulcast:
        '^simulcast:' +
        //send 1,2,3;~4,~5
        '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
        //space + recv 6;~7,~8
        '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
        //end
        '$'
      ),
      names: ['dir1', 'list1', 'dir2', 'list2'],
      format: function (o) {
        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    { //Old simulcast draft 03 (implemented by Firefox)
      //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      //a=simulcast: recv pt=97;98 send pt=97
      //a=simulcast: send rid=5;6;7 paused=6,7
      name: 'simulcast_03',
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ['value'],
      format: 'simulcast: %s'
    },
    {
      //a=framerate:25
      //a=framerate:29.97
      name: 'framerate',
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: 'framerate:%s'
    },
    { // RFC4570
      //a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: 'sourceFilter',
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
      format: 'source-filter: %s %s %s %s %s'
    },
    { // any a= that we don't understand is kepts verbatim on media.invalid
      push: 'invalid',
      names: ['value']
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});

},{}],85:[function(require,module,exports){
var parser = require('./parser');
var writer = require('./writer');

exports.write = writer;
exports.parse = parser.parse;
exports.parseFmtpConfig = parser.parseFmtpConfig;
exports.parseParams = parser.parseParams;
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;

},{"./parser":86,"./writer":87}],86:[function(require,module,exports){
var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = require('./grammar');
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var paramReducer = function (acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  } else if (s.length === 1 && expr.length > 1) {
    acc[s[0]] = undefined;
  }
  return acc;
};

exports.parseParams = function (str) {
  return str.split(/\;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;

exports.parsePayloads = function (str) {
  return str.split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
  });
};

exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid, paused = false;

      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }

      return {
        scid: scid,
        paused: paused
      };
    });
  });
};

},{"./grammar":84}],87:[function(require,module,exports){
var grammar = require('./grammar');

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
    case '%%':
      return '%';
    case '%s':
      return String(arg);
    case '%d':
      return Number(arg);
    case '%v':
      return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};

},{"./grammar":84}],88:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
}

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
}

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.substr(17).split(' ');
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  var cname;
  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5],
  };
}

// Expose public methods.
if (typeof module === 'object') {
  module.exports = SDPUtils;
}

},{}],89:[function(require,module,exports){
(function (global){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

var adapterFactory = require('./adapter_factory.js');
module.exports = adapterFactory({window: global.window});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./adapter_factory.js":90}],90:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

var utils = require('./utils');
// Shimming starts here.
module.exports = function(dependencies, opts) {
  var window = dependencies && dependencies.window;

  var options = {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true,
  };

  for (var key in opts) {
    if (hasOwnProperty.call(opts, key)) {
      options[key] = opts[key];
    }
  }

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;
  var commonShim = require('./common_shim') || null;

  // Export to the adapter global object visible in the browser.
  var adapter = {
    browserDetails: browserDetails,
    commonShim: commonShim,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection ||
          !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;
      commonShim.shimCreateObjectURL(window);

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimSourceObject(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);
      chromeShim.shimSenderReceiverGetStats(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection ||
          !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;
      commonShim.shimCreateObjectURL(window);

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimSourceObject(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      firefoxShim.shimRemoveStream(window);
      firefoxShim.shimSenderGetStats(window);
      firefoxShim.shimReceiverGetStats(window);
      firefoxShim.shimRTCDataChannel(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;
      commonShim.shimCreateObjectURL(window);

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);

      // the edge shim implements the full RTCIceCandidate object.

      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;
      commonShim.shimCreateObjectURL(window);

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);
      safariShim.shimCreateOfferLegacy(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
};

},{"./chrome/chrome_shim":91,"./common_shim":93,"./edge/edge_shim":94,"./firefox/firefox_shim":97,"./safari/safari_shim":99,"./utils":100}],91:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(function(name) {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(function(id) {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  var filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  var trackStats = [];
  result.forEach(function(value) {
    if (value.type === 'track' &&
        value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(function(trackStat) {
    result.forEach(function(stats) {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimMediaStream: function(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        }
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!pc._ontrackpoly) {
          pc._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === te.track.id;
                });
              } else {
                receiver = {track: te.track};
              }

              var event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === track.id;
                });
              } else {
                receiver = {track: track};
              }
              var event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
          };
          pc.addEventListener('addstream', pc._ontrackpoly);
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    } else if (!('RTCRtpTransceiver' in window)) {
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        if (!e.transceiver) {
          e.transceiver = {receiver: e.receiver};
        }
        return e;
      });
    }
  },

  shimGetSendersWithDtmf: function(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (typeof window === 'object' && window.RTCPeerConnection &&
        !('getSenders' in window.RTCPeerConnection.prototype) &&
        'createDTMFSender' in window.RTCPeerConnection.prototype) {
      var shimSenderWithDtmf = function(pc, track) {
        return {
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
          var pc = this;
          var sender = origAddTrack.apply(pc, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(pc, track);
            pc._senders.push(sender);
          }
          return sender;
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function(sender) {
          var pc = this;
          origRemoveTrack.apply(pc, arguments);
          var idx = pc._senders.indexOf(sender);
          if (idx !== -1) {
            pc._senders.splice(idx, 1);
          }
        };
      }
      var origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origAddStream.apply(pc, [stream]);
        stream.getTracks().forEach(function(track) {
          pc._senders.push(shimSenderWithDtmf(pc, track));
        });
      };

      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origRemoveStream.apply(pc, [stream]);

        stream.getTracks().forEach(function(track) {
          var sender = pc._senders.find(function(s) {
            return s.track === track;
          });
          if (sender) {
            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
          }
        });
      };
    } else if (typeof window === 'object' && window.RTCPeerConnection &&
               'getSenders' in window.RTCPeerConnection.prototype &&
               'createDTMFSender' in window.RTCPeerConnection.prototype &&
               window.RTCRtpSender &&
               !('dtmf' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  },

  shimSenderReceiverGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender && window.RTCRtpReceiver)) {
      return;
    }

    // shim sender stats.
    if (!('getStats' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          var pc = this;
          var senders = origGetSenders.apply(pc, []);
          senders.forEach(function(sender) {
            sender._pc = pc;
          });
          return senders;
        };
      }

      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window.RTCPeerConnection.prototype.addTrack = function() {
          var sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window.RTCRtpSender.prototype.getStats = function() {
        var sender = this;
        return this._pc.getStats().then(function(result) {
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          return filterStats(result, sender.track, true);
        });
      };
    }

    // shim receiver stats.
    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
      var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window.RTCPeerConnection.prototype.getReceivers = function() {
          var pc = this;
          var receivers = origGetReceivers.apply(pc, []);
          receivers.forEach(function(receiver) {
            receiver._pc = pc;
          });
          return receivers;
        };
      }
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function() {
        var receiver = this;
        return this._pc.getStats().then(function(result) {
          return filterStats(result, receiver.track, false);
        });
      };
    }

    if (!('getStats' in window.RTCRtpSender.prototype &&
        'getStats' in window.RTCRtpReceiver.prototype)) {
      return;
    }

    // shim RTCPeerConnection.getStats(track).
    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function() {
      var pc = this;
      if (arguments.length > 0 &&
          arguments[0] instanceof window.MediaStreamTrack) {
        var track = arguments[0];
        var sender;
        var receiver;
        var err;
        pc.getSenders().forEach(function(s) {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        pc.getReceivers().forEach(function(r) {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || (sender && receiver)) {
          return Promise.reject(new DOMException(
            'There are more than one sender or receiver for the track.',
            'InvalidAccessError'));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException(
          'There is no sender or receiver for the track.',
          'InvalidAccessError'));
      }
      return origGetStats.apply(pc, arguments);
    };
  },

  shimSourceObject: function(window) {
    var URL = window && window.URL;

    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return undefined;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimAddTrackRemoveTrackWithNative: function(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map(function(streamId) {
        return pc._shimmedLocalStreams[streamId][0];
      });
    };

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      var sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      var existingSenders = pc.getSenders();
      origAddStream.apply(this, arguments);
      var newSenders = pc.getSenders().filter(function(newSender) {
        return existingSenders.indexOf(newSender) === -1;
      });
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };

    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {
          var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            pc._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (pc._shimmedLocalStreams[streamId].length === 1) {
            delete pc._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  },

  shimAddTrackRemoveTrack: function(window) {
    var browserDetails = utils.detectBrowser(window);
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack &&
        browserDetails.version >= 65) {
      return this.shimAddTrackRemoveTrackWithNative(window);
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    var origGetLocalStreams = window.RTCPeerConnection.prototype
        .getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      var nativeStreams = origGetLocalStreams.apply(this);
      pc._reverseStreams = pc._reverseStreams || {};
      return nativeStreams.map(function(stream) {
        return pc._reverseStreams[stream.id];
      });
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!pc._reverseStreams[stream.id]) {
        var newStream = new window.MediaStream(stream.getTracks());
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(pc, [stream]);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);
      delete pc._reverseStreams[(pc._streams[stream.id] ?
          pc._streams[stream.id].id : stream.id)];
      delete pc._streams[stream.id];
    };

    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      var streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 ||
          !streams[0].getTracks().find(function(t) {
            return t === track;
          })) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
          ' stream which is associated with the specified track.',
          'NotSupportedError');
      }

      var alreadyExists = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }

      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};
      var oldStream = pc._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(function() {
          pc.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        var newStream = new window.MediaStream([track]);
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        pc.addStream(newStream);
      }
      return pc.getSenders().find(function(s) {
        return s.track === track;
      });
    };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
            externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
            internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function() {
        var pc = this;
        var args = arguments;
        var isLegacyCall = arguments.length &&
            typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(pc, [
            function(description) {
              var desc = replaceInternalStreamId(pc, description);
              args[0].apply(null, [desc]);
            },
            function(err) {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]
          ]);
        }
        return nativeMethod.apply(pc, arguments)
        .then(function(description) {
          return replaceInternalStreamId(pc, description);
        });
      };
    });

    var origSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription = function() {
      var pc = this;
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(pc, arguments);
      }
      arguments[0] = replaceExternalStreamId(pc, arguments[0]);
      return origSetLocalDescription.apply(pc, arguments);
    };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    var origLocalDescription = Object.getOwnPropertyDescriptor(
        window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype,
        'localDescription', {
          get: function() {
            var pc = this;
            var description = origLocalDescription.get.apply(this);
            if (description.type === '') {
              return description;
            }
            return replaceInternalStreamId(pc, description);
          }
        });

    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.', 'TypeError');
      }
      var isLocal = sender._pc === pc;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      pc._streams = pc._streams || {};
      var stream;
      Object.keys(pc._streams).forEach(function(streamid) {
        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {
          return sender.track === track;
        });
        if (hasTrack) {
          stream = pc._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          pc.removeStream(pc._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        pc.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        // Translate iceTransportPolicy to iceTransports,
        // see https://code.google.com/p/webrtc/issues/detail?id=4869
        // this was fixed in M56 along with unprefixing RTCPeerConnection.
        logging('PeerConnection');
        if (pcConfig && pcConfig.iceTransportPolicy) {
          pcConfig.iceTransports = pcConfig.iceTransportPolicy;
        }

        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.webkitRTCPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      if (window.webkitRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.webkitRTCPeerConnection.generateCertificate;
          }
        });
      }
    } else {
      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
      var OrigPeerConnection = window.RTCPeerConnection;
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (pcConfig && pcConfig.iceServers) {
          var newIceServers = [];
          for (var i = 0; i < pcConfig.iceServers.length; i++) {
            var server = pcConfig.iceServers[i];
            if (!server.hasOwnProperty('urls') &&
                server.hasOwnProperty('url')) {
              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
              server = JSON.parse(JSON.stringify(server));
              server.urls = server.url;
              newIceServers.push(server);
            } else {
              newIceServers.push(pcConfig.iceServers[i]);
            }
          }
          pcConfig.iceServers = newIceServers;
        }
        return new OrigPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }

    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(selector,
        successCallback, errorCallback) {
      var pc = this;
      var args = arguments;

      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }

      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 ||
          typeof arguments[0] !== 'function')) {
        return origGetStats.apply(this, []);
      }

      var fixChromeStats_ = function(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function(report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(function(name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };

      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        return new Map(Object.keys(stats).map(function(key) {
          return [key, stats[key]];
        }));
      };

      if (arguments.length >= 2) {
        var successCallbackWrapper_ = function(response) {
          args[1](makeMapStats(fixChromeStats_(response)));
        };

        return origGetStats.apply(this, [successCallbackWrapper_,
          arguments[0]]);
      }

      // promise-support
      return new Promise(function(resolve, reject) {
        origGetStats.apply(pc, [
          function(response) {
            resolve(makeMapStats(fixChromeStats_(response)));
          }, reject]);
      }).then(successCallback, errorCallback);
    };

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            window.RTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var pc = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(pc, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // promise support for createOffer and createAnswer. Available (without
    // bugs) since M52: crbug/619289
    if (browserDetails.version < 52) {
      ['createOffer', 'createAnswer'].forEach(function(method) {
        var nativeMethod = window.RTCPeerConnection.prototype[method];
        window.RTCPeerConnection.prototype[method] = function() {
          var pc = this;
          if (arguments.length < 1 || (arguments.length === 1 &&
              typeof arguments[0] === 'object')) {
            var opts = arguments.length === 1 ? arguments[0] : undefined;
            return new Promise(function(resolve, reject) {
              nativeMethod.apply(pc, [resolve, reject, opts]);
            });
          }
          return nativeMethod.apply(this, arguments);
        };
      });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
};

},{"../utils.js":100,"./getusermedia":92}],92:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;

  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === 'object') {
      var remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function(d) {
              return matches.some(function(match) {
                return d.label.toLowerCase().indexOf(match) !== -1;
              });
            });
            if (!dev && devices.length && matches.indexOf('back') !== -1) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :
                                                        {ideal: dev.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return window.MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                kind: kinds[device.kind],
                deviceId: device.id,
                groupId: ''};
            }));
          });
        });
      },
      getSupportedConstraints: function() {
        return {
          deviceId: true, echoCancellation: true, facingMode: true,
          frameRate: true, height: true, width: true
        };
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":100}],93:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');
var utils = require('./utils');

module.exports = {
  shimRTCIceCandidate: function(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
        window.RTCIceCandidate.prototype)) {
      return;
    }

    var NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function(args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if (typeof args === 'object' && args.candidate &&
          args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substr(2);
      }

      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        var nativeCandidate = new NativeRTCIceCandidate(args);
        var parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        var augmentedCandidate = Object.assign(nativeCandidate,
            parsedCandidate);

        // Add a serializer that does not serialize the extra attributes.
        augmentedCandidate.toJSON = function() {
          return {
            candidate: augmentedCandidate.candidate,
            sdpMid: augmentedCandidate.sdpMid,
            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
            usernameFragment: augmentedCandidate.usernameFragment,
          };
        };
        return augmentedCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    utils.wrapPeerConnectionEvent(window, 'icecandidate', function(e) {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  },

  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.

  shimCreateObjectURL: function(window) {
    var URL = window && window.URL;

    if (!(typeof window === 'object' && window.HTMLMediaElement &&
          'srcObject' in window.HTMLMediaElement.prototype &&
        URL.createObjectURL && URL.revokeObjectURL)) {
      // Only shim CreateObjectURL using srcObject if srcObject exists.
      return undefined;
    }

    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
    var streams = new Map(), newId = 0;

    URL.createObjectURL = function(stream) {
      if ('getTracks' in stream) {
        var url = 'polyblob:' + (++newId);
        streams.set(url, stream);
        utils.deprecated('URL.createObjectURL(stream)',
            'elem.srcObject = stream');
        return url;
      }
      return nativeCreateObjectURL(stream);
    };
    URL.revokeObjectURL = function(url) {
      nativeRevokeObjectURL(url);
      streams.delete(url);
    };

    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,
                                              'src');
    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {
      get: function() {
        return dsc.get.apply(this);
      },
      set: function(url) {
        this.srcObject = streams.get(url) || null;
        return dsc.set.apply(this, [url]);
      }
    });

    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;
    window.HTMLMediaElement.prototype.setAttribute = function() {
      if (arguments.length === 2 &&
          ('' + arguments[0]).toLowerCase() === 'src') {
        this.srcObject = streams.get(arguments[1]) || null;
      }
      return nativeSetAttribute.apply(this, arguments);
    };
  },

  shimMaxMessageSize: function(window) {
    if (window.RTCSctpTransport || !window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);

    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get: function() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        }
      });
    }

    var sctpInDescription = function(description) {
      var sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some(function(mediaSection) {
        var mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application'
            && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };

    var getRemoteFirefoxVersion = function(description) {
      // TODO: Is there a better solution for detecting Firefox?
      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      var version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };

    var getCanSendMaxMessageSize = function(remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      var canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize =
            browserDetails.version === 57 ? 65535 : 65536;
        } else {
          // FF >= 60 supports sending ~2 GiB
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };

    var getMaxMessageSize = function(description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      var maxMessageSize = 65536;

      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox'
           && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }

      var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substr(19), 10);
      } else if (browserDetails.browser === 'firefox' &&
                  remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };

    var origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function() {
      var pc = this;
      pc._sctp = null;

      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        var isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        var canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        var maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        var sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get: function() {
            return maxMessageSize;
          }
        });
        pc._sctp = sctp;
      }

      return origSetRemoteDescription.apply(pc, arguments);
    };
  },

  shimSendThrowTypeError: function(window) {
    if (!(window.RTCPeerConnection &&
        'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }

    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

    function wrapDcSend(dc, pc) {
      var origDataChannelSend = dc.send;
      dc.send = function() {
        var data = arguments[0];
        var length = data.length || data.size || data.byteLength;
        if (dc.readyState === 'open' &&
            pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError('Message too large (can send a maximum of ' +
            pc.sctp.maxMessageSize + ' bytes)');
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    var origCreateDataChannel =
      window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel = function() {
      var pc = this;
      var dataChannel = origCreateDataChannel.apply(pc, arguments);
      wrapDcSend(dataChannel, pc);
      return dataChannel;
    };
    utils.wrapPeerConnectionEvent(window, 'datachannel', function(e) {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }
};

},{"./utils":100,"sdp":88}],94:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var filterIceServers = require('./filtericeservers');
var shimRTCPeerConnection = require('rtcpeerconnection-shim');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (window.RTCIceGatherer) {
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed. Workaround for a bug in
      // addStream, see below. No longer required in 15025+
      if (browserDetails.version < 15025) {
        var origMSTEnabled = Object.getOwnPropertyDescriptor(
            window.MediaStreamTrack.prototype, 'enabled');
        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
          set: function(value) {
            origMSTEnabled.set.call(this, value);
            var ev = new Event('enabled');
            ev.enabled = value;
            this.dispatchEvent(ev);
          }
        });
      }
    }

    // ORTC defines the DTMF sender a bit different.
    // https://github.com/w3c/ortc/issues/714
    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = new window.RTCDtmfSender(this);
            } else if (this.track.kind === 'video') {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
    // Edge currently only implements the RTCDtmfSender, not the
    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
    if (window.RTCDtmfSender && !window.RTCDTMFSender) {
      window.RTCDTMFSender = window.RTCDtmfSender;
    }

    var RTCPeerConnectionShim = shimRTCPeerConnection(window,
        browserDetails.version);
    window.RTCPeerConnection = function(config) {
      if (config && config.iceServers) {
        config.iceServers = filterIceServers(config.iceServers);
      }
      return new RTCPeerConnectionShim(config);
    };
    window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
  },
  shimReplaceTrack: function(window) {
    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
    if (window.RTCRtpSender &&
        !('replaceTrack' in window.RTCRtpSender.prototype)) {
      window.RTCRtpSender.prototype.replaceTrack =
          window.RTCRtpSender.prototype.setTrack;
    }
  }
};

},{"../utils":100,"./filtericeservers":95,"./getusermedia":96,"rtcpeerconnection-shim":1723}],95:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
module.exports = function(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
};

},{"../utils":100}],96:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

// Expose public methods.
module.exports = function(window) {
  var navigator = window && window.navigator;

  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};

},{}],97:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.transceiver = {receiver: event.receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
    if (typeof window === 'object' && window.RTCTrackEvent &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimSourceObject: function(window) {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (window.mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = window.mozRTCSessionDescription;
      window.RTCIceCandidate = window.mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    // shim getStats with maplike support
    var makeMapStats = function(stats) {
      var map = new Map();
      Object.keys(stats).forEach(function(key) {
        map.set(key, stats[key]);
        map[key] = stats[key];
      });
      return map;
    };

    var modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(
      selector,
      onSucc,
      onErr
    ) {
      return nativeGetStats.apply(this, [selector || null])
        .then(function(stats) {
          if (browserDetails.version < 48) {
            stats = makeMapStats(stats);
          }
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach(function(stat) {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach(function(stat, i) {
                stats.set(i, Object.assign({}, stat, {
                  type: modernStatsTypes[stat.type] || stat.type
                }));
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  },

  shimSenderGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
      return;
    }
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function() {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function() {
      return this.track ? this._pc.getStats(this.track) :
          Promise.resolve(new Map());
    };
  },

  shimReceiverGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
      return;
    }
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function() {
        var pc = this;
        var receivers = origGetReceivers.apply(pc, []);
        receivers.forEach(function(receiver) {
          receiver._pc = pc;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function(e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function() {
      return this._pc.getStats(this.track);
    };
  },

  shimRemoveStream: function(window) {
    if (!window.RTCPeerConnection ||
        'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      utils.deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach(function(sender) {
        if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {
          pc.removeTrack(sender);
        }
      });
    };
  },

  shimRTCDataChannel: function(window) {
    // rename DataChannel to RTCDataChannel (native fix in FF60):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
    if (window.DataChannel && !window.RTCDataChannel) {
      window.RTCDataChannel = window.DataChannel;
    }
  },
};

},{"../utils":100,"./getusermedia":98}],98:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  var shimError_ = function(e) {
    return {
      name: {
        InternalError: 'NotReadableError',
        NotSupportedError: 'TypeError',
        PermissionDeniedError: 'NotAllowedError',
        SecurityError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  if (!(browserDetails.version > 55 &&
      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      if (typeof c === 'object' && typeof c.audio === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === 'audio' && typeof c === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":100}],99:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';
var utils = require('../utils');

module.exports = {
  shimLocalStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getStreamById = function(id) {
        var result = null;
        if (this._localStreams) {
          this._localStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        if (this._remoteStreams) {
          this._remoteStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        return result;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      var _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (this._localStreams.indexOf(stream) === -1) {
          this._localStreams.push(stream);
        }
        var pc = this;
        stream.getTracks().forEach(function(track) {
          _addTrack.call(pc, track, stream);
        });
      };

      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
        if (stream) {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (this._localStreams.indexOf(stream) === -1) {
            this._localStreams.push(stream);
          }
        }
        return _addTrack.call(this, track, stream);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        var index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        var pc = this;
        var tracks = stream.getTracks();
        this.getSenders().forEach(function(sender) {
          if (tracks.indexOf(sender.track) !== -1) {
            pc.removeTrack(sender);
          }
        });
      };
    }
  },
  shimRemoteStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get: function() {
          return this._onaddstream;
        },
        set: function(f) {
          var pc = this;
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
            this.removeEventListener('track', this._onaddstreampoly);
          }
          this.addEventListener('addstream', this._onaddstream = f);
          this.addEventListener('track', this._onaddstreampoly = function(e) {
            e.streams.forEach(function(stream) {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              var event = new Event('addstream');
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
      });
    }
  },
  shimCallbacksAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    var prototype = window.RTCPeerConnection.prototype;
    var createOffer = prototype.createOffer;
    var createAnswer = prototype.createAnswer;
    var setLocalDescription = prototype.setLocalDescription;
    var setRemoteDescription = prototype.setRemoteDescription;
    var addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    prototype.createAnswer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    var withCallback = function(description, successCallback, failureCallback) {
      var promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function(description, successCallback, failureCallback) {
      var promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function(candidate, successCallback, failureCallback) {
      var promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  },
  shimGetUserMedia: function(window) {
    var navigator = window && window.navigator;

    if (!navigator.getUserMedia) {
      if (navigator.webkitGetUserMedia) {
        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
      } else if (navigator.mediaDevices &&
          navigator.mediaDevices.getUserMedia) {
        navigator.getUserMedia = function(constraints, cb, errcb) {
          navigator.mediaDevices.getUserMedia(constraints)
          .then(cb, errcb);
        }.bind(navigator);
      }
    }
  },
  shimRTCIceServerUrls: function(window) {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in window.RTCPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  },
  shimTrackEventTransceiver: function(window) {
    // Add event.transceiver member over deprecated event.receiver
    if (typeof window === 'object' && window.RTCPeerConnection &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
        // defined for some reason even when window.RTCTransceiver is not.
        !window.RTCTransceiver) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimCreateOfferLegacy: function(window) {
    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {
      var pc = this;
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'audio';
        });
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true &&
            !audioTransceiver) {
          pc.addTransceiver('audio');
        }


        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'video';
        });
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            videoTransceiver.setDirection('sendonly');
          } else if (videoTransceiver.direction === 'recvonly') {
            videoTransceiver.setDirection('inactive');
          }
        } else if (offerOptions.offerToReceiveVideo === true &&
            !videoTransceiver) {
          pc.addTransceiver('video');
        }
      }
      return origCreateOffer.apply(pc, arguments);
    };
  }
};

},{"../utils":100}],100:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logDisabled_ = true;
var deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object.
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function(e) {
      cb(wrapper(e));
    };
    this._eventMap = this._eventMap || {};
    this._eventMap[cb] = wrappedCallback;
    return nativeAddEventListener.apply(this, [nativeEventName,
      wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap
        || !this._eventMap[cb]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[cb];
    delete this._eventMap[cb];
    return nativeRemoveEventListener.apply(this, [nativeEventName,
      unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function() {
      return this['_on' + eventNameToWrap];
    },
    set: function(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
}

// Utility methods.
module.exports = {
  extractVersion: extractVersion,
  wrapPeerConnectionEvent: wrapPeerConnectionEvent,
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  disableWarnings: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  deprecated: function(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
        ' instead.');
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function(window) {
    var navigator = window && window.navigator;

    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    if (navigator.mozGetUserMedia) { // Firefox.
      result.browser = 'firefox';
      result.version = extractVersion(navigator.userAgent,
          /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      result.browser = 'chrome';
      result.version = extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) { // Edge.
      result.browser = 'edge';
      result.version = extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);
    } else if (window.RTCPeerConnection &&
        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
      result.browser = 'safari';
      result.version = extractVersion(navigator.userAgent,
          /AppleWebKit\/(\d+)\./, 1);
    } else { // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }
};

},{}],101:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

var _memberships = require('./memberships');

var _memberships2 = _interopRequireDefault(_memberships);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

(0, _sparkCore.registerPlugin)('memberships', _memberships2.default);

exports.default = _memberships2.default;


},{"./memberships":102,"@ciscospark/spark-core":132}],102:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

/**
 * @typedef {Object} MembershipObject
 * @property {string} id - Unique identifier for the membership
 * @property {string} roomId - The room ID
 * @property {string} personId - The person ID
 * @property {email} personEmail - The email address of the person / room member
 * @property {boolean} isModerator - Indicates whether the specified person should be a room moderator
 * @property {boolean} isMonitor - Indicates whether the specified member is a room monitor
 * @property {isoDate} created - The date and time that this membership was created
 */

/**
 * Memberships represent a person's relationship to a room. Use this API to list
 * members of any room that you're in or create memberships to invite someone
 * to a room. Memberships can also be updated to make someone a moderator
 * or deleted to remove them from the room.
 * @class
 * @name Memberships
 */
var Memberships = _sparkCore.SparkPlugin.extend({
  /**
   * Adds a person to a room. The person can be added by ID (`personId`) or by
   * Email Address (`personEmail`). The person can be optionally added to the room
   * as a moderator.
   * @instance
   * @memberof Memberships
   * @param {MembershipObject} membership
   * @returns {Promise<MembershipObject>}
   * @example
   * ciscospark.rooms.create({title: 'Create Membership Example'})
   *   .then(function(room) {
   *     return ciscospark.memberships.create({
   *      personEmail: 'alice@example.com',
   *      roomId: room.id
   *    });
   *   })
   *   .then(function(membership) {
   *     var assert = require('assert');
   *     assert(membership.id);
   *     assert(membership.roomId);
   *     assert(membership.personId);
   *     assert(membership.personEmail);
   *     assert('isModerator' in membership);
   *     assert('isMonitor' in membership);
   *     assert(membership.created);
   *     return 'success';
   *   });
   *   // => success
   */
  create: function create(membership) {
    return this.request({
      method: 'POST',
      service: 'hydra',
      resource: 'memberships',
      body: membership
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Returns a single membership.
   * @instance
   * @memberof Memberships
   * @param {MembershipObject|uuid} membership
   * @returns {Promise<MembershipObject>}
   * @example
   * var membership;
   * ciscospark.rooms.create({title: 'Get Membership Example'})
   *   .then(function(room) {
   *     return ciscospark.memberships.create({
   *       personEmail: 'alice@example.com',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     membership = m;
   *     return ciscospark.memberships.get(m.id);
   *   })
   *   .then(function(m) {
   *     var assert = require('assert');
   *     assert.deepEqual(m, membership);
   *     return 'success';
   *   });
   *   // => success
   */
  get: function get(membership) {
    var id = membership.id || membership;
    return this.request({
      service: 'hydra',
      resource: 'memberships/' + id
    }).then(function (res) {
      return res.body.items || res.body;
    });
  },


  /**
   * Returns a list of memberships. In most cases the results will only contain
   * rooms that the authentiated user is a member of. You can filter the results
   * by room to list people in a room or by person to find rooms that a
   * specific person is a member of.
   * @instance
   * @memberof Memberships
   * @param {Object} options
   * @param {string} options.personId
   * @param {string} options.personEmail
   * @param {string} options.roomId
   * @param {number} options.max
   * @returns {Promise<Page<MembershipObject>>}
   * @example
   * var room;
   * ciscospark.rooms.create({title: 'List Membership Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.memberships.create({
   *      personEmail: 'alice@example.com',
   *      roomId: room.id
   *     });
   *   })
   *   .then(function() {
   *     return ciscospark.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     var assert = require('assert');
   *     assert.equal(memberships.length, 2);
   *     for (var i = 0; i < memberships.length; i+= 1) {
   *       assert.equal(memberships.items[i].roomId, room.id);
   *     }
   *     return 'success';
   *   });
   *   // => success
   */
  list: function list(options) {
    var _this = this;

    return this.request({
      service: 'hydra',
      resource: 'memberships',
      qs: options
    }).then(function (res) {
      return new _sparkCore.Page(res, _this.spark);
    });
  },


  /**
   * Deletes a single membership.
   * @instance
   * @memberof Memberships
   * @param {MembershipObject|uuid} membership
   * @returns {Promise}
   * @example
   * var membership, room;
   * ciscospark.rooms.create({title: 'Remove Membership Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.memberships.create({
   *      personEmail: 'alice@example.com',
   *      roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     membership = m;
   *     return ciscospark.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     var assert = require('assert');
   *     assert.equal(memberships.length, 2);
   *     return ciscospark.memberships.remove(membership);
   *   })
   *   .then(function() {
   *     return ciscospark.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     var assert = require('assert');
   *     assert.equal(memberships.length, 1);
   *     return 'success';
   *   });
   *   // => success
   */
  remove: function remove(membership) {
    var id = membership.id || membership;

    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: 'memberships/' + id
    }).then(function (res) {
      // Firefox has some issues with 204s and/or DELETE. This should move to
      // http-core
      if (res.statusCode === 204) {
        return undefined;
      }
      return res.body;
    });
  },


  /**
   * Used to update a single membership's properties
   * @instance
   * @memberof Memberships
   * @param {MembershipObject|uuid} membership
   * @returns {Promise<MembershipObject>}
   * @example
   * var membership, room;
   * ciscospark.rooms.create({title: 'Memberships Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     membership = memberships.items[0];
   *     var assert = require('assert');
   *     assert.equal(membership.isModerator, false);
   *     membership.isModerator = true;
   *     return ciscospark.memberships.update(membership);
   *   })
   *   .then(function() {
   *     return ciscospark.memberships.get(membership.id);
   *   })
   *   .then(function(membership) {
   *     var assert = require('assert');
   *     assert.equal(membership.isModerator, true);
   *     return 'success';
   *   });
   *   // => success
   */
  update: function update(membership) {
    var id = membership.id || membership;
    return this.request({
      method: 'PUT',
      service: 'hydra',
      resource: 'memberships/' + id,
      body: membership
    }).then(function (res) {
      return res.body;
    });
  },
  version: '1.32.5'
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = Memberships;


},{"@ciscospark/spark-core":132}],103:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"buffer":1735,"dup":3,"urlsafe-base64":1730}],104:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":4}],105:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],106:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":6}],107:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"_process":1743,"core-decorators":168,"dup":7}],108:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":8,"lodash/isArray":1648}],109:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"babel-runtime/core-js/array/from":678,"babel-runtime/core-js/object/create":685,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/set-prototype-of":692,"babel-runtime/core-js/reflect/construct":696,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":9}],110:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],111:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./node":110,"dup":11}],112:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./base64":103,"./capped-debounce":104,"./check-required":105,"./defer":106,"./deprecated":107,"./events":108,"./exception":109,"./in-browser":111,"./make-state-datatype":113,"./one-flight":114,"./patterns.js":115,"./resolve-with":116,"./retry":117,"./tap":118,"./template-container":119,"./while-in-flight":120,"dup":12}],113:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],114:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./template-container":119,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/typeof":711,"dup":14,"lodash/wrap":1715}],115:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],116:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":16}],117:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/typeof":711,"backoff":712,"dup":17,"events":1737,"lodash/defaults":1618,"lodash/isFunction":1656,"lodash/wrap":1715}],118:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":18}],119:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":19,"util":1769}],120:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./tap":118,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":20,"lodash/wrap":1715}],121:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

exports.default = makeSubTypes;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * @param {Error} Base
 * @returns {undefined}
 */
function makeSubTypes(Base) {
  /**
   * NetworkOrCORSError
   */
  var NetworkOrCORSError = function (_Base) {
    (0, _inherits3.default)(NetworkOrCORSError, _Base);

    function NetworkOrCORSError() {
      (0, _classCallCheck3.default)(this, NetworkOrCORSError);
      return (0, _possibleConstructorReturn3.default)(this, (NetworkOrCORSError.__proto__ || (0, _getPrototypeOf2.default)(NetworkOrCORSError)).apply(this, arguments));
    }

    return NetworkOrCORSError;
  }(Base);
  /**
   * BadRequest
   */


  var BadRequest = function (_Base2) {
    (0, _inherits3.default)(BadRequest, _Base2);

    function BadRequest() {
      (0, _classCallCheck3.default)(this, BadRequest);
      return (0, _possibleConstructorReturn3.default)(this, (BadRequest.__proto__ || (0, _getPrototypeOf2.default)(BadRequest)).apply(this, arguments));
    }

    return BadRequest;
  }(Base);
  /**
   * Unauthorized
   */


  var Unauthorized = function (_BadRequest) {
    (0, _inherits3.default)(Unauthorized, _BadRequest);

    function Unauthorized() {
      (0, _classCallCheck3.default)(this, Unauthorized);
      return (0, _possibleConstructorReturn3.default)(this, (Unauthorized.__proto__ || (0, _getPrototypeOf2.default)(Unauthorized)).apply(this, arguments));
    }

    return Unauthorized;
  }(BadRequest);
  /**
   * PaymentRequired
   */


  var PaymentRequired = function (_BadRequest2) {
    (0, _inherits3.default)(PaymentRequired, _BadRequest2);

    function PaymentRequired() {
      (0, _classCallCheck3.default)(this, PaymentRequired);
      return (0, _possibleConstructorReturn3.default)(this, (PaymentRequired.__proto__ || (0, _getPrototypeOf2.default)(PaymentRequired)).apply(this, arguments));
    }

    return PaymentRequired;
  }(BadRequest);
  /**
   * Forbidden
   */


  var Forbidden = function (_BadRequest3) {
    (0, _inherits3.default)(Forbidden, _BadRequest3);

    function Forbidden() {
      (0, _classCallCheck3.default)(this, Forbidden);
      return (0, _possibleConstructorReturn3.default)(this, (Forbidden.__proto__ || (0, _getPrototypeOf2.default)(Forbidden)).apply(this, arguments));
    }

    return Forbidden;
  }(BadRequest);
  /**
   * NotFound
   */


  var NotFound = function (_BadRequest4) {
    (0, _inherits3.default)(NotFound, _BadRequest4);

    function NotFound() {
      (0, _classCallCheck3.default)(this, NotFound);
      return (0, _possibleConstructorReturn3.default)(this, (NotFound.__proto__ || (0, _getPrototypeOf2.default)(NotFound)).apply(this, arguments));
    }

    return NotFound;
  }(BadRequest);
  /**
   * MethodNotAllowed
   */


  var MethodNotAllowed = function (_BadRequest5) {
    (0, _inherits3.default)(MethodNotAllowed, _BadRequest5);

    function MethodNotAllowed() {
      (0, _classCallCheck3.default)(this, MethodNotAllowed);
      return (0, _possibleConstructorReturn3.default)(this, (MethodNotAllowed.__proto__ || (0, _getPrototypeOf2.default)(MethodNotAllowed)).apply(this, arguments));
    }

    return MethodNotAllowed;
  }(BadRequest);
  /**
   * NotAcceptable
   */


  var NotAcceptable = function (_BadRequest6) {
    (0, _inherits3.default)(NotAcceptable, _BadRequest6);

    function NotAcceptable() {
      (0, _classCallCheck3.default)(this, NotAcceptable);
      return (0, _possibleConstructorReturn3.default)(this, (NotAcceptable.__proto__ || (0, _getPrototypeOf2.default)(NotAcceptable)).apply(this, arguments));
    }

    return NotAcceptable;
  }(BadRequest);
  /**
   * ProxyAuthenticationRequired
   */


  var ProxyAuthenticationRequired = function (_BadRequest7) {
    (0, _inherits3.default)(ProxyAuthenticationRequired, _BadRequest7);

    function ProxyAuthenticationRequired() {
      (0, _classCallCheck3.default)(this, ProxyAuthenticationRequired);
      return (0, _possibleConstructorReturn3.default)(this, (ProxyAuthenticationRequired.__proto__ || (0, _getPrototypeOf2.default)(ProxyAuthenticationRequired)).apply(this, arguments));
    }

    return ProxyAuthenticationRequired;
  }(BadRequest);
  /**
   * RequestTimeout
   */


  var RequestTimeout = function (_BadRequest8) {
    (0, _inherits3.default)(RequestTimeout, _BadRequest8);

    function RequestTimeout() {
      (0, _classCallCheck3.default)(this, RequestTimeout);
      return (0, _possibleConstructorReturn3.default)(this, (RequestTimeout.__proto__ || (0, _getPrototypeOf2.default)(RequestTimeout)).apply(this, arguments));
    }

    return RequestTimeout;
  }(BadRequest);
  /**
   * Conflict
   */


  var Conflict = function (_BadRequest9) {
    (0, _inherits3.default)(Conflict, _BadRequest9);

    function Conflict() {
      (0, _classCallCheck3.default)(this, Conflict);
      return (0, _possibleConstructorReturn3.default)(this, (Conflict.__proto__ || (0, _getPrototypeOf2.default)(Conflict)).apply(this, arguments));
    }

    return Conflict;
  }(BadRequest);
  /**
   * Gone
   */


  var Gone = function (_BadRequest10) {
    (0, _inherits3.default)(Gone, _BadRequest10);

    function Gone() {
      (0, _classCallCheck3.default)(this, Gone);
      return (0, _possibleConstructorReturn3.default)(this, (Gone.__proto__ || (0, _getPrototypeOf2.default)(Gone)).apply(this, arguments));
    }

    return Gone;
  }(BadRequest);
  /**
   * LengthRequired
   */


  var LengthRequired = function (_BadRequest11) {
    (0, _inherits3.default)(LengthRequired, _BadRequest11);

    function LengthRequired() {
      (0, _classCallCheck3.default)(this, LengthRequired);
      return (0, _possibleConstructorReturn3.default)(this, (LengthRequired.__proto__ || (0, _getPrototypeOf2.default)(LengthRequired)).apply(this, arguments));
    }

    return LengthRequired;
  }(BadRequest);
  /**
   * PreconditionFailed
   */


  var PreconditionFailed = function (_BadRequest12) {
    (0, _inherits3.default)(PreconditionFailed, _BadRequest12);

    function PreconditionFailed() {
      (0, _classCallCheck3.default)(this, PreconditionFailed);
      return (0, _possibleConstructorReturn3.default)(this, (PreconditionFailed.__proto__ || (0, _getPrototypeOf2.default)(PreconditionFailed)).apply(this, arguments));
    }

    return PreconditionFailed;
  }(BadRequest);
  /**
   * RequestEntityTooLarge
   */


  var RequestEntityTooLarge = function (_BadRequest13) {
    (0, _inherits3.default)(RequestEntityTooLarge, _BadRequest13);

    function RequestEntityTooLarge() {
      (0, _classCallCheck3.default)(this, RequestEntityTooLarge);
      return (0, _possibleConstructorReturn3.default)(this, (RequestEntityTooLarge.__proto__ || (0, _getPrototypeOf2.default)(RequestEntityTooLarge)).apply(this, arguments));
    }

    return RequestEntityTooLarge;
  }(BadRequest);
  /**
   * RequestUriTooLong
   */


  var RequestUriTooLong = function (_BadRequest14) {
    (0, _inherits3.default)(RequestUriTooLong, _BadRequest14);

    function RequestUriTooLong() {
      (0, _classCallCheck3.default)(this, RequestUriTooLong);
      return (0, _possibleConstructorReturn3.default)(this, (RequestUriTooLong.__proto__ || (0, _getPrototypeOf2.default)(RequestUriTooLong)).apply(this, arguments));
    }

    return RequestUriTooLong;
  }(BadRequest);
  /**
   * UnsupportedMediaType
   */


  var UnsupportedMediaType = function (_BadRequest15) {
    (0, _inherits3.default)(UnsupportedMediaType, _BadRequest15);

    function UnsupportedMediaType() {
      (0, _classCallCheck3.default)(this, UnsupportedMediaType);
      return (0, _possibleConstructorReturn3.default)(this, (UnsupportedMediaType.__proto__ || (0, _getPrototypeOf2.default)(UnsupportedMediaType)).apply(this, arguments));
    }

    return UnsupportedMediaType;
  }(BadRequest);
  /**
   * RequestRangeNotSatisfiable
   */


  var RequestRangeNotSatisfiable = function (_BadRequest16) {
    (0, _inherits3.default)(RequestRangeNotSatisfiable, _BadRequest16);

    function RequestRangeNotSatisfiable() {
      (0, _classCallCheck3.default)(this, RequestRangeNotSatisfiable);
      return (0, _possibleConstructorReturn3.default)(this, (RequestRangeNotSatisfiable.__proto__ || (0, _getPrototypeOf2.default)(RequestRangeNotSatisfiable)).apply(this, arguments));
    }

    return RequestRangeNotSatisfiable;
  }(BadRequest);
  /**
   * ExpectationFailed
   */


  var ExpectationFailed = function (_BadRequest17) {
    (0, _inherits3.default)(ExpectationFailed, _BadRequest17);

    function ExpectationFailed() {
      (0, _classCallCheck3.default)(this, ExpectationFailed);
      return (0, _possibleConstructorReturn3.default)(this, (ExpectationFailed.__proto__ || (0, _getPrototypeOf2.default)(ExpectationFailed)).apply(this, arguments));
    }

    return ExpectationFailed;
  }(BadRequest);
  /**
   * TooManyRequests
   */


  var TooManyRequests = function (_BadRequest18) {
    (0, _inherits3.default)(TooManyRequests, _BadRequest18);

    function TooManyRequests() {
      (0, _classCallCheck3.default)(this, TooManyRequests);
      return (0, _possibleConstructorReturn3.default)(this, (TooManyRequests.__proto__ || (0, _getPrototypeOf2.default)(TooManyRequests)).apply(this, arguments));
    }

    return TooManyRequests;
  }(BadRequest);
  /**
   * InternalServerError
   */


  var InternalServerError = function (_Base3) {
    (0, _inherits3.default)(InternalServerError, _Base3);

    function InternalServerError() {
      (0, _classCallCheck3.default)(this, InternalServerError);
      return (0, _possibleConstructorReturn3.default)(this, (InternalServerError.__proto__ || (0, _getPrototypeOf2.default)(InternalServerError)).apply(this, arguments));
    }

    return InternalServerError;
  }(Base);
  /**
   * NotImplemented
   */


  var NotImplemented = function (_InternalServerError) {
    (0, _inherits3.default)(NotImplemented, _InternalServerError);

    function NotImplemented() {
      (0, _classCallCheck3.default)(this, NotImplemented);
      return (0, _possibleConstructorReturn3.default)(this, (NotImplemented.__proto__ || (0, _getPrototypeOf2.default)(NotImplemented)).apply(this, arguments));
    }

    return NotImplemented;
  }(InternalServerError);
  /**
   * BadGateway
   */


  var BadGateway = function (_InternalServerError2) {
    (0, _inherits3.default)(BadGateway, _InternalServerError2);

    function BadGateway() {
      (0, _classCallCheck3.default)(this, BadGateway);
      return (0, _possibleConstructorReturn3.default)(this, (BadGateway.__proto__ || (0, _getPrototypeOf2.default)(BadGateway)).apply(this, arguments));
    }

    return BadGateway;
  }(InternalServerError);
  /**
   * ServiceUnavailable
   */


  var ServiceUnavailable = function (_InternalServerError3) {
    (0, _inherits3.default)(ServiceUnavailable, _InternalServerError3);

    function ServiceUnavailable() {
      (0, _classCallCheck3.default)(this, ServiceUnavailable);
      return (0, _possibleConstructorReturn3.default)(this, (ServiceUnavailable.__proto__ || (0, _getPrototypeOf2.default)(ServiceUnavailable)).apply(this, arguments));
    }

    return ServiceUnavailable;
  }(InternalServerError);
  /**
   * GatewayTimeout
   */


  var GatewayTimeout = function (_InternalServerError4) {
    (0, _inherits3.default)(GatewayTimeout, _InternalServerError4);

    function GatewayTimeout() {
      (0, _classCallCheck3.default)(this, GatewayTimeout);
      return (0, _possibleConstructorReturn3.default)(this, (GatewayTimeout.__proto__ || (0, _getPrototypeOf2.default)(GatewayTimeout)).apply(this, arguments));
    }

    return GatewayTimeout;
  }(InternalServerError);
  /**
   * HttpVersionNotSupported
   */


  var HttpVersionNotSupported = function (_InternalServerError5) {
    (0, _inherits3.default)(HttpVersionNotSupported, _InternalServerError5);

    function HttpVersionNotSupported() {
      (0, _classCallCheck3.default)(this, HttpVersionNotSupported);
      return (0, _possibleConstructorReturn3.default)(this, (HttpVersionNotSupported.__proto__ || (0, _getPrototypeOf2.default)(HttpVersionNotSupported)).apply(this, arguments));
    }

    return HttpVersionNotSupported;
  }(InternalServerError);

  (0, _assign2.default)(Base, {
    0: NetworkOrCORSError,
    NetworkOrCORSError: NetworkOrCORSError,
    400: BadRequest,
    BadRequest: BadRequest,
    401: Unauthorized,
    Unauthorized: Unauthorized,
    402: PaymentRequired,
    PaymentRequired: PaymentRequired,
    403: Forbidden,
    Forbidden: Forbidden,
    404: NotFound,
    NotFound: NotFound,
    405: MethodNotAllowed,
    MethodNotAllowed: MethodNotAllowed,
    406: NotAcceptable,
    NotAcceptable: NotAcceptable,
    407: ProxyAuthenticationRequired,
    ProxyAuthenticationRequired: ProxyAuthenticationRequired,
    408: RequestTimeout,
    RequestTimeout: RequestTimeout,
    409: Conflict,
    Conflict: Conflict,
    410: Gone,
    Gone: Gone,
    411: LengthRequired,
    LengthRequired: LengthRequired,
    412: PreconditionFailed,
    PreconditionFailed: PreconditionFailed,
    413: RequestEntityTooLarge,
    RequestEntityTooLarge: RequestEntityTooLarge,
    414: RequestUriTooLong,
    RequestUriTooLong: RequestUriTooLong,
    415: UnsupportedMediaType,
    UnsupportedMediaType: UnsupportedMediaType,
    416: RequestRangeNotSatisfiable,
    RequestRangeNotSatisfiable: RequestRangeNotSatisfiable,
    417: ExpectationFailed,
    ExpectationFailed: ExpectationFailed,
    429: TooManyRequests,
    TooManyRequests: TooManyRequests,
    500: InternalServerError,
    InternalServerError: InternalServerError,
    501: NotImplemented,
    NotImplemented: NotImplemented,
    502: BadGateway,
    BadGateway: BadGateway,
    503: ServiceUnavailable,
    ServiceUnavailable: ServiceUnavailable,
    504: GatewayTimeout,
    GatewayTimeout: GatewayTimeout,
    505: HttpVersionNotSupported,
    HttpVersionNotSupported: HttpVersionNotSupported,
    select: function select(statusCode) {
      if (typeof statusCode === 'undefined' || statusCode === null) {
        return Base;
      }

      statusCode = statusCode.statusCode || statusCode;
      var E = Base[statusCode];
      if (E) {
        return E;
      }

      // Fallback to the default for the category (e.g. BadRequest for 429)
      statusCode = statusCode.toString().split('').shift() + '00';
      statusCode = parseInt(statusCode, 10);

      return Base[statusCode] || Base;
    }
  });
}


},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],122:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _class, _temp; /*!
                    * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                    */

var _common = require('@ciscospark/common');

var _httpErrorSubtypes = require('./http-error-subtypes');

var _httpErrorSubtypes2 = _interopRequireDefault(_httpErrorSubtypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base HttpError class. Unlikely to be thrown directly, but handy for general
 * type comparison.
 */
var HttpError = (_temp = _class = function (_Exception) {
  (0, _inherits3.default)(HttpError, _Exception);

  function HttpError() {
    (0, _classCallCheck3.default)(this, HttpError);
    return (0, _possibleConstructorReturn3.default)(this, (HttpError.__proto__ || (0, _getPrototypeOf2.default)(HttpError)).apply(this, arguments));
  }

  (0, _createClass3.default)(HttpError, [{
    key: 'parse',


    /**
     * Parses HttpResponse objects for useful information (status, headers, etc)
     * as well as attempting to extract a useful error message.
     * @param {HttpResponse} res
     * @returns {string}
     */

    /**
     * @example Extend via
     * MyError extends HttpError {
     *  static errorKeys = HttpError.errorKeys.concat([
     *    `key1`,
     *    `key2`
     *  ])
     * }
     *
     * @type {Array}
     */
    value: function parse(res) {
      // complexity is high here because of all the default values below.
      /* eslint complexity: [0] */
      var body = res.body;
      var message = void 0;

      switch (typeof body === 'undefined' ? 'undefined' : (0, _typeof3.default)(body)) {
        case 'string':
          try {
            body = JSON.parse(body);
            message = this.parseObject(body);
          } catch (err) {
            message = body;
          }
          break;
        case 'object':
          message = this.parseObject(body);
          break;
        default:
      }

      if (!message) {
        message = this.defaultMessage;
      }

      (0, _defineProperties2.default)(this, {
        body: {
          enumerable: false,
          value: body
        },
        httpVersion: {
          enumerable: false,
          value: res.httpVersion
        },
        headers: {
          enumerable: false,
          value: res.headers || {}
        },
        rawHeaders: {
          enumerable: false,
          value: res.rawHeaders || []
        },
        trailers: {
          enumerable: false,
          value: res.trailers || {}
        },
        rawTrailers: {
          enumerable: false,
          value: res.rawTrailers || []
        },
        method: {
          enumerable: false,
          value: res.method
        },
        url: {
          enumerable: false,
          value: res.url
        },
        statusCode: {
          enumerable: false,
          value: res.statusCode
        },
        statusMessage: {
          enumerable: false,
          value: res.statusMessage
        },
        socket: {
          enumerable: false,
          value: res.socket
        },
        _res: {
          enumerable: false,
          value: res
        }
      });

      return message;
    }

    /**
     * Recursively parses an error body looking for a likely error candidate
     * @param {object} body
     * @returns {string}
     */


    /**
     * Default error string if no error can be extracted from the http response
     * @type {string}
     */

  }, {
    key: 'parseObject',
    value: function parseObject(body) {
      // Search body for common names of error strings
      var messages = (0, _values2.default)((0, _pick3.default)(body, HttpError.errorKeys));

      // If no error candidate was found, stringify the entire body
      if (messages.length === 0) {
        return (0, _stringify2.default)(body, null, 2);
      }

      // Assume the first key found was the error explanation
      var message = messages[0];

      // If the explanation is an object, recurse and try again
      if ((typeof message === 'undefined' ? 'undefined' : (0, _typeof3.default)(message)) === 'object') {
        return this.parseObject(message);
      }

      // Return the first key
      return message;
    }
  }]);
  return HttpError;
}(_common.Exception), _class.errorKeys = ['error', 'errorString', 'response', 'errorResponse', 'message', 'msg'], _class.defaultMessage = 'An error was received while trying to fulfill the request', _temp);
exports.default = HttpError;


(0, _httpErrorSubtypes2.default)(HttpError);
HttpError.makeSubTypes = _httpErrorSubtypes2.default;


},{"./http-error-subtypes":121,"@ciscospark/common":112,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/values":693,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"lodash/pick":1685}],123:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detectSync = exports.detect = exports.HttpStatusInterceptor = exports.HttpError = exports.Interceptor = exports.ProgressEvent = exports.request = exports.defaults = undefined;

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _defineProperty = require('babel-runtime/core-js/reflect/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/reflect/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _curry2 = require('lodash/curry');

var _curry3 = _interopRequireDefault(_curry2);

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

var _progressEvent = require('./progress-event');

Object.defineProperty(exports, 'ProgressEvent', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_progressEvent).default;
  }
});

var _interceptor = require('./lib/interceptor');

Object.defineProperty(exports, 'Interceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_interceptor).default;
  }
});

var _httpError = require('./http-error');

Object.defineProperty(exports, 'HttpError', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_httpError).default;
  }
});

var _httpStatus = require('./interceptors/http-status');

Object.defineProperty(exports, 'HttpStatusInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_httpStatus).default;
  }
});

var _detect = require('./lib/detect');

Object.defineProperty(exports, 'detect', {
  enumerable: true,
  get: function get() {
    return _detect.detect;
  }
});
Object.defineProperty(exports, 'detectSync', {
  enumerable: true,
  get: function get() {
    return _detect.detectSync;
  }
});

var _httpStatus2 = _interopRequireDefault(_httpStatus);

var _request2 = require('./request');

var _request3 = _interopRequireDefault(_request2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Curry protorequest so we generate a function with default options built in.
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var protorequest = (0, _curry3.default)(function protorequest(defaultOptions, options) {
  // allow for options to be a string (and therefore expect options in the third
  // position) to match request's api.
  if ((0, _isString3.default)(options)) {
    var uri = options;
    /* eslint prefer-rest-params: [0] */
    options = arguments[2] || {};
    options.uri = uri;
  }

  // Hide useless elements from logs
  ['download', 'interceptors', 'logger', 'upload'].forEach(function (prop) {
    var descriptor = (0, _getOwnPropertyDescriptor2.default)(options, prop);
    descriptor = (0, _assign3.default)({}, descriptor, {
      enumerable: false,
      writable: true
    });
    (0, _defineProperty2.default)(options, prop, descriptor);
  });

  (0, _defaults3.default)(options, defaultOptions);

  if (!options.json) {
    (0, _deleteProperty2.default)(options, 'json');
  }

  options.logger = options.logger || console;

  return (0, _request3.default)(options);
});

var defaultOptions = {
  json: true,
  interceptors: [
  // Reminder: this is supposed to be an instantiated interceptor.
  _httpStatus2.default.create()]
};

var defaults = exports.defaults = protorequest;
var request = exports.request = protorequest(defaultOptions);


},{"./http-error":122,"./interceptors/http-status":124,"./lib/detect":125,"./lib/interceptor":126,"./progress-event":128,"./request":129,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/reflect/get-own-property-descriptor":699,"lodash/assign":1606,"lodash/curry":1615,"lodash/defaults":1618,"lodash/isString":1662}],124:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _httpError = require('../http-error');

var _httpError2 = _interopRequireDefault(_httpError);

var _interceptor = require('../lib/interceptor');

var _interceptor2 = _interopRequireDefault(_interceptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var HttpStatusInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(HttpStatusInterceptor, _Interceptor);

  /**
   * @param {Object} spark
   * @param {Object} options
   * @returns {HttpStatusInterceptor}
   */
  function HttpStatusInterceptor(spark, options) {
    (0, _classCallCheck3.default)(this, HttpStatusInterceptor);

    var _this = (0, _possibleConstructorReturn3.default)(this, (HttpStatusInterceptor.__proto__ || (0, _getPrototypeOf2.default)(HttpStatusInterceptor)).call(this, spark));

    var ErrorConstructor = options && (options.error || options.ErrorConstructor) || _httpError2.default;

    (0, _defineProperties2.default)(_this, {
      ErrorConstructor: {
        value: ErrorConstructor
      }
    });
    return _this;
  }

  /**
   * @param {Object} options
   * @returns {HttpStatusInterceptor}
   */


  (0, _createClass3.default)(HttpStatusInterceptor, [{
    key: 'onResponse',


    /**
     * @param {Object} options
     * @param {HttpResponse} response
     * @returns {Promise}
     */
    value: function onResponse(options, response) {
      if (response.statusCode && response.statusCode < 400) {
        return _promise2.default.resolve(response);
      }
      // Note: the extra parenthesis below are required to make sure `new` is
      // applied to the correct method (i.e., the result of `select()`, not
      // `select()` itself).
      return _promise2.default.reject(new (this.ErrorConstructor.select(response.statusCode))(response));
    }
  }], [{
    key: 'create',
    value: function create(options) {
      return new HttpStatusInterceptor(this, options);
    }
  }]);
  return HttpStatusInterceptor;
}(_interceptor2.default);

exports.default = HttpStatusInterceptor;


},{"../http-error":122,"../lib/interceptor":126,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],125:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detect = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

exports.default = detect;
exports.detectSync = detectSync;

var _fileType = require('file-type');

var _fileType2 = _interopRequireDefault(_fileType);

var _common = require('@ciscospark/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Determine mimeType for the specified buffer;
 * @param {Buffer} buffer
 * @returns {Promise<string>}
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

function detect(buffer) {
  return new _promise2.default(function (resolve) {
    resolve(detectSync(buffer));
  });
}

exports.detect = detect;

/**
 * Synchronous implementation of {@link detect}
 * @param {Buffer} buffer
 * @returns {string}
 */

function detectSync(buffer) {
  /* global Blob */
  var b = buffer;
  if (_common.inBrowser) {
    if (buffer instanceof Blob) {
      return buffer.type;
    }
    if (buffer instanceof ArrayBuffer) {
      b = new Uint8Array(buffer);
    } else if (!(buffer instanceof Uint8Array)) {
      throw new Error('`detect` requires a buffer of type Blob, ArrayBuffer, or Uint8Array');
    }
  }

  var type = (0, _fileType2.default)(b);

  if (!type) {
    return 'application/octet-stream';
  }

  return type.mime;
}


},{"@ciscospark/common":112,"babel-runtime/core-js/promise":694,"file-type":1309}],126:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _defineProperty = require('babel-runtime/core-js/reflect/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * @class
 */
var Interceptor = function () {
  /**
   * @constructor
   * @param {Object} attrs
   * @returns {UrlInterceptor}
   */
  function Interceptor(attrs) {
    var _this = this;

    (0, _classCallCheck3.default)(this, Interceptor);

    if (attrs) {
      (0, _keys2.default)(attrs).forEach(function (key) {
        var value = attrs[key];
        (0, _defineProperty2.default)(_this, key, {
          enumerable: true,
          value: value
        });
      });
    }
  }

  /**
   * @abstract
   * @returns {Interceptor}
   */


  (0, _createClass3.default)(Interceptor, [{
    key: 'onRequest',


    /**
     * Transform request options before sending them
     * @param {Object} options
     * @returns {Promise<Object>}
     */
    value: function onRequest(options) {
      return _promise2.default.resolve(options);
    }

    /**
     * Handle request failures
     * @param {Object} options
     * @param {Error} reason
     * @returns {RejectedPromise<Error>}
     */

  }, {
    key: 'onRequestError',
    value: function onRequestError(options, reason) {
      return _promise2.default.reject(reason);
    }

    /**
     * Transform response before returning it
     * @param {Object} options
     * @param {HttpResponse} response
     * @returns {Promise<HttpResponse>}
     */

  }, {
    key: 'onResponse',
    value: function onResponse(options, response) {
      return _promise2.default.resolve(response);
    }

    /**
     * Handle response errors
     * @param {Object} options
     * @param {SparkHttpError} reason
     * @returns {Promise<SparkHttpError>}
     */

  }, {
    key: 'onResponseError',
    value: function onResponseError(options, reason) {
      return _promise2.default.reject(reason);
    }
  }], [{
    key: 'create',
    value: function create() {
      throw new Error('`Interceptor.create()` must be defined');
    }
  }]);
  return Interceptor;
}();

exports.default = Interceptor;


},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705}],127:[function(require,module,exports){
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

// Need to fork xhr to support environments with full object freezing; namely,
// SalesForce's Aura and Locker environment.

// See https://github.com/naugtur/xhr for license information

// Maintain the original code style of https://github.com/naugtur/xhr since
// we're trying to diverge as little as possible.
/* eslint-disable */

"use strict";

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = require("global/window");
var isFunction = require("is-function");
var parseHeaders = require("parse-headers");
var xtend = require("xtend");

module.exports = createXHR;
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop;
createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window.XDomainRequest;

forEachArray(["get", "put", "post", "patch", "head", "delete"], function (method) {
    createXHR[method === "delete" ? "del" : method] = function (uri, options, callback) {
        options = initParams(uri, options, callback);
        options.method = method.toUpperCase();
        return _createXHR(options);
    };
});

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i += 1) {
        iterator(array[i]);
    }
}

function isEmpty(obj) {
    for (var i in obj) {
        if (obj.hasOwnProperty(i)) return false;
    }
    return true;
}

function initParams(uri, options, callback) {
    var params = uri;

    if (isFunction(options)) {
        callback = options;
        if (typeof uri === "string") {
            params = { uri: uri };
        }
    } else {
        params = xtend(options, { uri: uri });
    }

    params.callback = callback;
    return params;
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback);
    return _createXHR(options);
}

function _createXHR(options) {
    if (typeof options.callback === "undefined") {
        throw new Error("callback argument missing");
    }

    var called = false;
    var callback = function cbOnce(err, response, body) {
        if (!called) {
            called = true;
            options.callback(err, response, body);
        }
    };

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0);
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined;

        if (xhr.response) {
            body = xhr.response;
        } else {
            body = xhr.responseText || getXml(xhr);
        }

        if (isJson) {
            try {
                body = JSON.parse(body);
            } catch (e) {}
        }

        return body;
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer);
        if (!(evt instanceof Error)) {
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
        }
        evt.statusCode = 0;
        return callback(evt, failureResponse);
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return;
        var status;
        clearTimeout(timeoutTimer);
        if (options.useXDR && xhr.status === undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200;
        } else {
            status = xhr.status === 1223 ? 204 : xhr.status;
        }
        var response = failureResponse;
        var err = null;

        if (status !== 0) {
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            };
            if (xhr.getAllResponseHeaders) {
                //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders());
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error");
        }
        return callback(err, response, response.body);
    }

    var xhr = options.xhr || null;

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest();
        } else {
            xhr = new createXHR.XMLHttpRequest();
        }
    }

    var key;
    var aborted;
    var uri = options.uri || options.url;
    var method = options.method || "GET";
    var body = options.body || options.data;
    var headers = options.headers || {};
    var sync = !!options.sync;
    var isJson = false;
    var timeoutTimer;
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    };

    if ("json" in options && options.json !== false) {
        isJson = true;
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json"); //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"); //Don't override existing accept header declared by user
            body = (0, _stringify2.default)(options.json === true ? body : options.json);
        }
    }

    xhr.onreadystatechange = readystatechange;
    xhr.onload = loadFunc;
    xhr.onerror = errorFunc;
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    };
    xhr.onabort = function () {
        aborted = true;
    };
    xhr.ontimeout = errorFunc;
    xhr.open(method, uri, !sync, options.username, options.password);
    //has to be after open
    if (!sync) {
        xhr.withCredentials = !!options.withCredentials;
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0) {
        timeoutTimer = setTimeout(function () {
            if (aborted) return;
            aborted = true; //IE9 may still call readystatechange
            xhr.abort("timeout");
            var e = new Error("XMLHttpRequest timeout");
            e.code = "ETIMEDOUT";
            errorFunc(e);
        }, options.timeout);
    }

    if (xhr.setRequestHeader) {
        for (key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object");
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType;
    }

    if ("beforeSend" in options && typeof options.beforeSend === "function") {
        options.beforeSend(xhr);
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null);

    return xhr;
}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML;
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML;
    }

    return null;
}

function noop() {}


},{"babel-runtime/core-js/json/stringify":681,"global/window":1311,"is-function":1312,"parse-headers":1717,"xtend":1732}],128:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isNan = require('babel-runtime/core-js/number/is-nan');

var _isNan2 = _interopRequireDefault(_isNan);

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _isNumber2 = require('lodash/isNumber');

var _isNumber3 = _interopRequireDefault(_isNumber2);

exports.default = ProgressEvent;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Object of the same shape as web browser ProgressEvents
 * @class ProgressEvent
 * @param {integer} loaded
 * @param {integer} total
 * @returns {ProgressEvent}
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

function ProgressEvent(loaded, total) {
  (0, _defineProperties2.default)(this, {
    loaded: {
      enumerable: true,
      value: loaded,
      writable: false
    },
    total: {
      enumerable: true,
      value: total,
      writable: false
    },
    lengthComputable: {
      enumerable: true,
      value: (0, _isNumber3.default)(loaded) && !(0, _isNan2.default)(loaded) && (0, _isNumber3.default)(total) && !(0, _isNan2.default)(total) && total > 0,
      writable: false
    }
  });
}


},{"babel-runtime/core-js/number/is-nan":683,"babel-runtime/core-js/object/define-properties":686,"lodash/isNumber":1658}],129:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

exports.default = request;

var _request2 = require('./request');

var _request3 = _interopRequireDefault(_request2);

var _common = require('@ciscospark/common');

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {Object} options
 * @returns {Promise}
 */
function request(options) {
  if (options.url) {
    options.uri = options.url;
    options.url = null;
  }

  options.headers = options.headers || {};
  if (!_common.inBrowser && !options.headers['user-agent']) {
    options.headers['user-agent'] = '@ciscospark/http-core';
  }

  options.download = new _events.EventEmitter();
  options.upload = new _events.EventEmitter();

  return intercept(options.interceptors, 'Request').then(function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _request3.default.apply(undefined, [options].concat(args));
  }).then(function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return intercept.apply(undefined, [options.interceptors.slice().reverse(), 'Response'].concat(args));
  });

  /**
   * @param {Array} interceptors
   * @param {string} key
   * @param {Object} res
   * @private
   * @returns {Promise}
   */
  function intercept(interceptors, key, res) {
    var successKey = 'on' + key;
    var errorKey = 'on' + key + 'Error';

    return interceptors.reduce(function (promise, interceptor) {
      return promise.then(function (result) {
        if (interceptor[successKey]) {
          return interceptor[successKey](options, result);
        }
        return _promise2.default.resolve(result);
      }, function (reason) {
        if (interceptor[errorKey]) {
          return interceptor[errorKey](options, reason);
        }
        return _promise2.default.reject(reason);
      });
    }, _promise2.default.resolve(res));
  }
} /*!
   * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
   */


},{"./request":130,"@ciscospark/common":112,"babel-runtime/core-js/promise":694,"events":1737}],130:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

exports.default = _request;

var _qs = require('qs');

var _qs2 = _interopRequireDefault(_qs);

var _xhr = require('../lib/xhr');

var _xhr2 = _interopRequireDefault(_xhr);

var _detect = require('../lib/detect');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @name request
 * @param {Object} options
 * @returns {Promise}
 */
function _request(options) {
  return new _promise2.default(function (resolve) {
    var params = (0, _pick3.default)(options, 'method', 'uri', 'withCredentials', 'headers', 'timeout', 'responseType');

    // Set `response` to `true` to approximate an `HttpResponse` object
    params.response = true;

    bindProgressEvents(params, options);
    setAuth(params, options);
    setCookies(params, options);
    setDefaults(params, options);
    setResponseType(params, options);
    setContentType(params, options);
    setPayload(params, options);
    setQs(params, options);

    var x = (0, _xhr2.default)(params, function (error, response) {
      /* istanbul ignore next */
      if (error) {
        options.logger.warn(error);
      }

      /* istanbul ignore else */
      if (response) {
        response.options = options;
        processResponseJson(response, params);
        resolve(response);
      } else {
        resolve({
          statusCode: 0,
          options: options,
          headers: options.headers,
          method: options.method,
          url: options.uri,
          body: error
        });
      }
    });

    x.onprogress = options.download.emit.bind(options.download, 'progress');
  }).catch(function (error) {
    /* eslint arrow-body-style: [0] */
    /* istanbul ignore next */
    return {
      statusCode: 0,
      options: options,
      headers: options.headers,
      method: options.method,
      url: options.uri,
      body: error
    };
  });

  /**
   * @param {Object} params
   * @param {Object} o
   * @private
   * @returns {undefined}
   */
  function bindProgressEvents(params, o) {
    if (params.method && ['PATCH', 'POST', 'PUT'].includes(params.method.toUpperCase())) {
      params.xhr = new XMLHttpRequest();
      params.xhr.upload.onprogress = o.upload.emit.bind(o.upload, 'progress');
    }
  }

  /**
   * @param {Object} params
   * @param {Object} o
   * @private
   * @returns {undefined}
   */
  function setAuth(params, o) {
    if (o.auth) {
      if (o.auth.bearer) {
        params.headers.authorization = 'Bearer ' + o.auth.bearer;
      } else {
        var user = o.auth.user || o.auth.username;
        var pass = o.auth.pass || o.auth.password;

        var token = btoa(user + ':' + pass);
        params.headers.authorization = 'Basic ' + token;
      }
    }
  }

  /**
   * @param {Object} params
   * @param {Object} o
   * @private
   * @returns {undefined}
   */
  function setCookies(params, o) {
    if (o.jar) {
      params.withCredentials = true;
    }
  }

  /**
   * @param {Object} params
   * @param {Object} o
   * @private
   * @returns {undefined}
   */
  function setDefaults(params, o) {
    var defs = {
      cors: true,
      // raynos/xhr defaults withCredentials to true if cors is true, so we need
      // to make it explicitly false by default
      withCredentials: false,
      timeout: 0
    };

    (0, _defaults3.default)(params, (0, _pick3.default)(o, (0, _keys2.default)(defs)), defs);
  }

  /**
   * @param {Object} params
   * @param {Object} o
   * @private
   * @returns {undefined}
   */
  function setResponseType(params, o) {
    if (o.responseType === 'buffer') {
      params.responseType = 'arraybuffer';
    }
  }

  /**
   * @param {Object} params
   * @param {Object} o
   * @private
   * @returns {undefined}
   */
  function setContentType(params, o) {
    if (o.body instanceof Blob || o.body instanceof ArrayBuffer) {
      o.json = params.json = false;
      params.headers['content-type'] = params.headers['content-type'] || (0, _detect.detectSync)(o.body);
    }
  }

  /**
   * @param {Object} params
   * @param {Object} o
   * @private
   * @returns {undefined}
   */
  function setQs(params, o) {
    if (o.qs) {
      params.uri += '?' + _qs2.default.stringify(o.qs);
    }
  }

  /**
   * Converts arraybuffers to blobs before uploading them
   * @param {mixed} file
   * @private
   * @returns {mixed}
   */
  function ensureBlob(file) {
    if (file instanceof ArrayBuffer) {
      var ret = file.type ? new Blob([file], { type: file.type }) : new Blob([file]);
      ret.filename = file.filename || file.name || 'untitled';
      return ret;
    }

    return file;
  }

  /**
   * Appends an item to a form
   * @param {FormData} form
   * @param {string} key
   * @param {mixed} value
   * @returns {undefined}
   */
  function append(form, key, value) {
    if ((0, _isArray3.default)(value)) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(value), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var v = _step.value;

          append(form, key, v);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return;
    }

    value = ensureBlob(value);
    if (value.name) {
      value.filename = value.name;
      form.append(key, value, value.name);
    } else {
      form.append(key, value);
    }
  }

  /**
   * @param {Object} params
   * @param {Object} o
   * @private
   * @returns {undefined}
   */
  function setPayload(params, o) {
    if ((!('json' in o) || o.json === true) && o.body) {
      params.json = o.body;
    } else if (o.form) {
      params.headers['Content-Type'] = 'application/x-www-form-urlencoded';
      params.body = _qs2.default.stringify(o.form);
      (0, _deleteProperty2.default)(params, 'json');
    } else if (o.formData) {
      params.body = (0, _keys2.default)(o.formData).reduce(function (fd, key) {
        var value = o.formData[key];
        append(fd, key, value);
        return fd;
      }, new FormData());
    } else {
      params.body = o.body;
      (0, _deleteProperty2.default)(params, 'json');
    }
  }

  /**
   * @param {Object} response
   * @param {Object} params
   * @private
   * @returns {undefined}
   */
  function processResponseJson(response, params) {
    // If params.json is not defined, xhr won't deserialize the response
    // so we should give it a shot just in case.
    if (!params.json && (0, _typeof3.default)(response.body) !== 'object') {
      try {
        response.body = JSON.parse(response.body);
      } catch (e) {
        /* eslint no-empty: [0] */
      }
    }
  }
} /*!
   * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
   */

/* eslint-env browser */

// Note: several code paths are ignored in this file. As far as I can tell, any
// error conditions that would provoke those paths are otherwise prevented and
// reported.


},{"../lib/detect":125,"../lib/xhr":127,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/typeof":711,"lodash/defaults":1618,"lodash/isArray":1648,"lodash/pick":1685,"qs":187}],131:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _storage = require('./lib/storage');

var IDBROKER_BASE_URL = process.env.IDBROKER_BASE_URL || 'https://idbroker.webex.com'; /*!
                                                                                        * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                                                                        */

/* eslint camelcase: [0] */

exports.default = {
  maxAppLevelRedirects: 10,
  maxAuthenticationReplays: 1,
  maxReconnectAttempts: 1,
  onBeforeLogout: [],
  trackingIdPrefix: 'spark-js-sdk',
  trackingIdSuffix: '',
  AlternateLogger: undefined,
  credentials: {
    /**
     * This is the authorization url displayed on the
     * {@link developer portal|https://developer.ciscospark.com}
     * @type {string}
     */
    authorizationString: process.env.CISCOSPARK_AUTHORIZATION_STRING || process.env.AUTHORIZATION_STRING,
    /**
     * Authorization URL which prompts for user's password. Inferred from
     * {@link config.credentials.authorizationString}
     * @type {string}
     */
    authorizeUrl: process.env.AUTHORIZE_URL || IDBROKER_BASE_URL + '/idb/oauth2/v1/authorize',
    // TODO does hydra also have an access_token endpoint?
    /**
     * Token URL used for token refresh and auth code exchange
     * @type {string}
     */
    tokenUrl: process.env.TOKEN_URL || IDBROKER_BASE_URL + '/idb/oauth2/v1/access_token',
    revokeUrl: process.env.REVOKE_URL || IDBROKER_BASE_URL + '/idb/oauth2/v1/revoke',
    /**
     * URL to load when the app logs out
     * @type {string}
     */
    logoutUrl: IDBROKER_BASE_URL + '/idb/oauth2/v1/logout',
    /**
     * {@see https://tools.ietf.org/html/rfc6749#section-4.1.4}
     * @type {string}
     */
    client_id: "C48d6efedc4f30ed7c38892ccfbfaf83656b803ae2d23f6108b335711a1e6f14c" || process.env.COMMON_IDENTITY_CLIENT_ID || process.env.CLIENT_ID,
    /**
     * {@see https://tools.ietf.org/html/rfc6749#section-4.1.4}
     * @type {string}
     */
    client_secret: "78e4579b570cd1f25758a18af18fb6dcdad271436776acbd419ce6239e31a838" || process.env.COMMON_IDENTITY_CLIENT_SECRET || process.env.CLIENT_SECRET,
    /**
     * {@see https://tools.ietf.org/html/rfc6749#section-4.1.4}
     * @type {string}
     */
    redirect_uri: "https://snow-sforce.herokuapp.com/callback" || process.env.COMMON_IDENTITY_REDIRECT_URI || process.env.REDIRECT_URI,
    /**
     * {@see https://tools.ietf.org/html/rfc6749#section-4.1.4}
     * @type {string}
     */
    scope: "spark:all" || process.env.CISCOSPARK_SCOPES || process.env.COMMON_IDENTITY_SCOPE || process.env.SCOPE,
    /**
     * Controls the UI of the CI login page.
     * @private
     * @type {string}
     */
    cisService: 'spark'
  },
  device: {
    preDiscoveryServices: {
      hydraServiceUrl: process.env.HYDRA_SERVICE_URL || 'https://api.ciscospark.com/v1'
    }
  },
  payloadTransformer: {
    predicates: [],
    transforms: []
  },
  storage: {
    boundedAdapter: _storage.MemoryStoreAdapter,
    unboundedAdapter: _storage.MemoryStoreAdapter
  }
};


}).call(this,require('_process'))
},{"./lib/storage":158,"_process":1743}],132:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.config = exports.Page = exports.Batcher = exports.RateLimitInterceptor = exports.SparkUserAgentInterceptor = exports.SparkTrackingIdInterceptor = exports.RequestTimingInterceptor = exports.RequestLoggerInterceptor = exports.RequestEventInterceptor = exports.ResponseLoggerInterceptor = exports.RedirectInterceptor = exports.PayloadTransformerInterceptor = exports.NetworkTimingInterceptor = exports.AuthInterceptor = exports.SparkPlugin = exports.SparkHttpError = exports.registerInternalPlugin = exports.registerPlugin = exports.default = exports.children = exports.waitForValue = exports.StorageError = exports.persist = exports.NotFoundError = exports.MemoryStoreAdapter = exports.makeSparkPluginStore = exports.makeSparkStore = exports.Token = exports.sortScope = exports.grantErrors = exports.filterScope = exports.Credentials = undefined;

var _credentials = require('./lib/credentials');

Object.defineProperty(exports, 'Credentials', {
  enumerable: true,
  get: function get() {
    return _credentials.Credentials;
  }
});
Object.defineProperty(exports, 'filterScope', {
  enumerable: true,
  get: function get() {
    return _credentials.filterScope;
  }
});
Object.defineProperty(exports, 'grantErrors', {
  enumerable: true,
  get: function get() {
    return _credentials.grantErrors;
  }
});
Object.defineProperty(exports, 'sortScope', {
  enumerable: true,
  get: function get() {
    return _credentials.sortScope;
  }
});
Object.defineProperty(exports, 'Token', {
  enumerable: true,
  get: function get() {
    return _credentials.Token;
  }
});

var _storage = require('./lib/storage');

Object.defineProperty(exports, 'makeSparkStore', {
  enumerable: true,
  get: function get() {
    return _storage.makeSparkStore;
  }
});
Object.defineProperty(exports, 'makeSparkPluginStore', {
  enumerable: true,
  get: function get() {
    return _storage.makeSparkPluginStore;
  }
});
Object.defineProperty(exports, 'MemoryStoreAdapter', {
  enumerable: true,
  get: function get() {
    return _storage.MemoryStoreAdapter;
  }
});
Object.defineProperty(exports, 'NotFoundError', {
  enumerable: true,
  get: function get() {
    return _storage.NotFoundError;
  }
});
Object.defineProperty(exports, 'persist', {
  enumerable: true,
  get: function get() {
    return _storage.persist;
  }
});
Object.defineProperty(exports, 'StorageError', {
  enumerable: true,
  get: function get() {
    return _storage.StorageError;
  }
});
Object.defineProperty(exports, 'waitForValue', {
  enumerable: true,
  get: function get() {
    return _storage.waitForValue;
  }
});

var _sparkCore = require('./spark-core');

Object.defineProperty(exports, 'children', {
  enumerable: true,
  get: function get() {
    return _sparkCore.children;
  }
});
Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sparkCore).default;
  }
});
Object.defineProperty(exports, 'registerPlugin', {
  enumerable: true,
  get: function get() {
    return _sparkCore.registerPlugin;
  }
});
Object.defineProperty(exports, 'registerInternalPlugin', {
  enumerable: true,
  get: function get() {
    return _sparkCore.registerInternalPlugin;
  }
});

var _sparkHttpError = require('./lib/spark-http-error');

Object.defineProperty(exports, 'SparkHttpError', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sparkHttpError).default;
  }
});

var _sparkPlugin = require('./lib/spark-plugin');

Object.defineProperty(exports, 'SparkPlugin', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sparkPlugin).default;
  }
});

var _auth = require('./interceptors/auth');

Object.defineProperty(exports, 'AuthInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_auth).default;
  }
});

var _networkTiming = require('./interceptors/network-timing');

Object.defineProperty(exports, 'NetworkTimingInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_networkTiming).default;
  }
});

var _payloadTransformer = require('./interceptors/payload-transformer');

Object.defineProperty(exports, 'PayloadTransformerInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_payloadTransformer).default;
  }
});

var _redirect = require('./interceptors/redirect');

Object.defineProperty(exports, 'RedirectInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_redirect).default;
  }
});

var _responseLogger = require('./interceptors/response-logger');

Object.defineProperty(exports, 'ResponseLoggerInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_responseLogger).default;
  }
});

var _requestEvent = require('./interceptors/request-event');

Object.defineProperty(exports, 'RequestEventInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_requestEvent).default;
  }
});

var _requestLogger = require('./interceptors/request-logger');

Object.defineProperty(exports, 'RequestLoggerInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_requestLogger).default;
  }
});

var _requestTiming = require('./interceptors/request-timing');

Object.defineProperty(exports, 'RequestTimingInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_requestTiming).default;
  }
});

var _sparkTrackingId = require('./interceptors/spark-tracking-id');

Object.defineProperty(exports, 'SparkTrackingIdInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sparkTrackingId).default;
  }
});

var _sparkUserAgent = require('./interceptors/spark-user-agent');

Object.defineProperty(exports, 'SparkUserAgentInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sparkUserAgent).default;
  }
});

var _rateLimit = require('./interceptors/rate-limit');

Object.defineProperty(exports, 'RateLimitInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_rateLimit).default;
  }
});

var _batcher = require('./lib/batcher');

Object.defineProperty(exports, 'Batcher', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_batcher).default;
  }
});

var _page = require('./lib/page');

Object.defineProperty(exports, 'Page', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_page).default;
  }
});

var _config = require('./config');

Object.defineProperty(exports, 'config', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_config).default;
  }
});

require('./plugins/logger');

require('./lib/credentials');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


},{"./config":131,"./interceptors/auth":133,"./interceptors/network-timing":134,"./interceptors/payload-transformer":135,"./interceptors/rate-limit":136,"./interceptors/redirect":137,"./interceptors/request-event":138,"./interceptors/request-logger":139,"./interceptors/request-timing":140,"./interceptors/response-logger":141,"./interceptors/spark-tracking-id":142,"./interceptors/spark-user-agent":143,"./lib/batcher":144,"./lib/credentials":147,"./lib/page":151,"./lib/spark-http-error":153,"./lib/spark-plugin":155,"./lib/storage":158,"./plugins/logger":162,"./spark-core":163}],133:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
var AuthInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(AuthInterceptor, _Interceptor);

  function AuthInterceptor() {
    (0, _classCallCheck3.default)(this, AuthInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (AuthInterceptor.__proto__ || (0, _getPrototypeOf2.default)(AuthInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(AuthInterceptor, [{
    key: 'onRequest',


    /**
     * @see {@link Interceptor#onRequest}
     * @param {Object} options
     * @returns {Object}
     */
    value: function onRequest(options) {
      var _this2 = this;

      options.headers = options.headers || {};

      // If Authorizations is already set, don't overwrite it
      if ('authorization' in options.headers || 'auth' in options) {
        // If Authorization is set to null, false, or undefined, delete it to
        // prevent a CORS preflight.
        if (!options.headers.authorization) {
          (0, _deleteProperty2.default)(options.headers, 'authorization');
        }
        return _promise2.default.resolve(options);
      }

      return this.requiresCredentials(options).then(function (requires) {
        if (!requires) {
          return options;
        }

        return _this2.spark.credentials.getUserToken().then(function (token) {
          options.headers.authorization = token.toString();
          return options;
        });
      });
    }

    /**
     * Determines if the provided options object needs an auth header
     * @param {Object} options
     * @returns {Promise<boolean>}
     */

  }, {
    key: 'requiresCredentials',
    value: function requiresCredentials(options) {
      var _this3 = this;

      if (options.uri && options.uri.includes(this.spark.config.device.preDiscoveryServices.hydraServiceUrl)) {
        return _promise2.default.resolve(true);
      }

      if (!this.spark.internal.device) {
        return _promise2.default.resolve(false);
      }

      return this.spark.internal.device.isSpecificService('hydra', options.uri).then(function (isHydra) {
        if (isHydra) {
          return true;
        }

        if (options.service) {
          return _this3.spark.internal.device.isService(options.service);
        }

        if (options.uri) {
          return _this3.spark.internal.device.isServiceUrl(options.uri);
        }
        return false;
      });
    }

    /**
     * @see {@link Interceptor#onResponseError}
     * @param {Object} options
     * @param {Error} reason
     * @returns {Object}
     */

  }, {
    key: 'onResponseError',
    value: function onResponseError(options, reason) {
      var _this4 = this;

      return this.shouldAttemptReauth(reason, options).then(function (shouldAttemptReauth) {
        if (shouldAttemptReauth) {
          _this4.spark.logger.info('auth: received 401, attempting to reauthenticate');

          if (reason.options.headers) {
            (0, _deleteProperty2.default)(reason.options.headers, 'authorization');
          }

          if (_this4.spark.credentials.canRefresh) {
            return _this4.spark.credentials.refresh().then(function () {
              return _this4.replay(options);
            });
          }
        }

        return _promise2.default.reject(reason);
      });
    }

    /**
     * Replays the request
     * @param {Object} options
     * @returns {Object}
     */

  }, {
    key: 'replay',
    value: function replay(options) {
      if (options.replayCount) {
        options.replayCount += 1;
      } else {
        options.replayCount = 1;
      }

      if (options.replayCount > this.spark.config.maxAuthenticationReplays) {
        this.spark.logger.error('auth: failed after ' + this.spark.config.maxAuthenticationReplays + ' replay attempts');
        return _promise2.default.reject(new Error('Failed after ' + this.spark.config.maxAuthenticationReplays + ' replay attempts'));
      }

      this.spark.logger.info('auth: replaying request ' + options.replayCount + ' time');

      return this.spark.request(options);
    }

    /**
     * Indicates whether or not the current request should refresh its access
     * token in event of a 401
     * @param {Error} reason
     * @param {Object} options
     * @returns {Promise<boolean>}
     */

  }, {
    key: 'shouldAttemptReauth',
    value: function shouldAttemptReauth(reason, options) {
      if (options && options.shouldRefreshAccessToken === false) {
        return _promise2.default.resolve(false);
      }

      if (reason.statusCode === 401) {
        return _promise2.default.resolve(true);
      }

      return _promise2.default.resolve(false);
    }
  }], [{
    key: 'create',

    /**
     * @returns {AuthInterceptor}
     */
    value: function create() {
      return new AuthInterceptor({ spark: this });
    }
  }]);
  return AuthInterceptor;
}(_httpCore.Interceptor); /*!
                           * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                           */

exports.default = AuthInterceptor;


},{"@ciscospark/http-core":123,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],134:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
var NetworkTimingInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(NetworkTimingInterceptor, _Interceptor);

  function NetworkTimingInterceptor() {
    (0, _classCallCheck3.default)(this, NetworkTimingInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (NetworkTimingInterceptor.__proto__ || (0, _getPrototypeOf2.default)(NetworkTimingInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(NetworkTimingInterceptor, [{
    key: 'onRequest',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @returns {Object}
     */
    value: function onRequest(options) {
      options.$timings = options.$timings || {};
      options.$timings.networkStart = Date.now();
      return options;
    }

    /**
     * @see Interceptor#onResponse
     * @param {Object} options
     * @param {HttpResponse} response
     * @returns {Object}
     */

  }, {
    key: 'onResponse',
    value: function onResponse(options, response) {
      options.$timings.networkEnd = Date.now();
      return response;
    }

    /**
     * @see Interceptor#onResponseError
     * @param {Object} options
     * @param {Error} reason
     * @returns {Object}
     */

  }, {
    key: 'onResponseError',
    value: function onResponseError(options, reason) {
      options.$timings.networkEnd = Date.now();
      return _promise2.default.reject(reason);
    }
  }], [{
    key: 'create',

    /**
     * @param {Object} options
     * @returns {NetworkTimingInterceptor}
     */
    value: function create(options) {
      return new NetworkTimingInterceptor(this, options);
    }
  }]);
  return NetworkTimingInterceptor;
}(_httpCore.Interceptor); /*!
                           * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                           */

exports.default = NetworkTimingInterceptor;


},{"@ciscospark/http-core":123,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],135:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
var PayloadTransformerInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(PayloadTransformerInterceptor, _Interceptor);

  function PayloadTransformerInterceptor() {
    (0, _classCallCheck3.default)(this, PayloadTransformerInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (PayloadTransformerInterceptor.__proto__ || (0, _getPrototypeOf2.default)(PayloadTransformerInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(PayloadTransformerInterceptor, [{
    key: 'onRequest',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @returns {Object}
     */
    value: function onRequest(options) {
      if (options.noTransform) {
        return options;
      }
      return this.spark.transform('outbound', options);
    }

    /**
     * @see Interceptor#onResponse
     * @param {Object} options
     * @param {HttpResponse} response
     * @returns {Object}
     */

  }, {
    key: 'onResponse',
    value: function onResponse(options, response) {
      return this.spark.transform('inbound', response);
    }

    /**
     * @see Interceptor#onResponseError
     * @param {Object} options
     * @param {Error} reason
     * @returns {Object}
     */

  }, {
    key: 'onResponseError',
    value: function onResponseError(options, reason) {
      return this.spark.transform('inbound', reason).then(function (r) {
        return _promise2.default.reject(r || reason);
      });
    }
  }], [{
    key: 'create',

    /**
     * @param {Object} options
     * @returns {PayloadTransformerInterceptor}
     */
    value: function create() {
      return new PayloadTransformerInterceptor({ spark: this });
    }
  }]);
  return PayloadTransformerInterceptor;
}(_httpCore.Interceptor); /*!
                           * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                           */

exports.default = PayloadTransformerInterceptor;


},{"@ciscospark/http-core":123,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],136:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// contains the system time in milliseconds at which the retry after associated with a 429 expires
// mapped by the API name, e.g.: idbroker.webex.com/doStuff would be mapped as 'doStuff'
var rateLimitExpiryTime = new _weakMap2.default();

// extracts the common identity API being called
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var idBrokerRegex = /.*(idbroker|identity).webex.com\/([^/]+)/;

/**
 * @class
 */

var RateLimitInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(RateLimitInterceptor, _Interceptor);
  (0, _createClass3.default)(RateLimitInterceptor, null, [{
    key: 'create',

    /**
     * @returns {RateLimitInterceptor}
     */
    value: function create() {
      return new RateLimitInterceptor({ spark: this });
    }

    /**
    * constructor
    * @param {mixed} args
    * @returns {Exception}
    */

  }]);

  function RateLimitInterceptor() {
    var _ref;

    (0, _classCallCheck3.default)(this, RateLimitInterceptor);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = RateLimitInterceptor.__proto__ || (0, _getPrototypeOf2.default)(RateLimitInterceptor)).call.apply(_ref, [this].concat(args)));

    rateLimitExpiryTime.set(_this, new _map2.default());
    return _this;
  }

  /**
   * @see {@link Interceptor#onRequest}
   * @param {Object} options
   * @returns {Object}
   */


  (0, _createClass3.default)(RateLimitInterceptor, [{
    key: 'onRequest',
    value: function onRequest(options) {
      if (this.isRateLimited(options.uri)) {
        return _promise2.default.reject(new Error('API rate limited ' + options.uri));
      }
      return _promise2.default.resolve(options);
    }

    /**
     * @see {@link Interceptor#onResponseError}
     * @param {Object} options
     * @param {Error} reason
     * @returns {Object}
     */

  }, {
    key: 'onResponseError',
    value: function onResponseError(options, reason) {
      if (reason.statusCode === 429 && (options.uri.includes('idbroker') || options.uri.includes('identity'))) {
        // set the retry after in the map, setting to milliseconds
        this.setRateLimitExpiry(options.uri, this.extractRetryAfterTime(options));
      }
      return _promise2.default.reject(reason);
    }

    /**
     * @param {object} options associated with the request
     * @returns {number} retry after time in milliseconds
     */

  }, {
    key: 'extractRetryAfterTime',
    value: function extractRetryAfterTime(options) {
      // 1S * 1K === 1MS
      var milliMultiplier = 1000;
      var retryAfter = options.headers['retry-after'] || null;
      // set 60 retry if no usable time defined
      if (retryAfter === null || retryAfter <= 0) {
        return 60 * milliMultiplier;
      }
      // set max to 3600 S (1 hour) if greater than 1 hour
      if (retryAfter > 3600) {
        return 3600 * milliMultiplier;
      }
      return retryAfter * milliMultiplier;
    }

    /**
     * Set the system time at which the rate limiting
     * will expire in the rateLimitExpiryTime map.
     * Assumes retryAfter is in milliseconds
     * @param {string} uri API issuing the rate limiting
     * @param {number} retryAfter milliseconds until rate limiting expires
     * @returns {bool} true is value was successfully set
     */

  }, {
    key: 'setRateLimitExpiry',
    value: function setRateLimitExpiry(uri, retryAfter) {
      var apiName = this.getApiName(uri);

      if (!apiName) {
        return false;
      }

      var currTimeMilli = new Date().getTime();
      var expiry = currTimeMilli + retryAfter;
      var dict = rateLimitExpiryTime.get(this);
      return dict.set(apiName, expiry);
    }

    /**
     * returns true if the API is currently rate limited
     * @param {string} uri
     * @returns {Boolean} indicates whether or not the API is rate currently rate limited
     */

  }, {
    key: 'getRateLimitStatus',
    value: function getRateLimitStatus(uri) {
      var apiName = this.getApiName(uri);

      if (!apiName) {
        return false;
      }

      var currTimeMilli = new Date().getTime();
      var dict = rateLimitExpiryTime.get(this);
      var expiryTime = dict.get(apiName);

      // if no rate limit expiry has been registered in the map, return false.
      if (expiryTime === undefined) {
        return false;
      }
      // return true, indicating rate limiting, if the system time is less than the expiry time
      return currTimeMilli < dict.get(apiName);
    }

    /**
     * split the URI and returns the API name of idBroker
     * @param {string} uri
     * @returns {string}
     */

  }, {
    key: 'getApiName',
    value: function getApiName(uri) {
      if (!uri) {
        return null;
      }

      var results = uri.match(idBrokerRegex);

      if (!results) {
        return null;
      }
      // group 0 = full match of URL, group 1 = identity or idbroker base
      // group 2 = api name
      return results[2];
    }

    /**
     * check URI against list of currently rate limited
     * URIs, and determines if retry-after
     * @param {String} uri pattern to check
     * @returns {bool}
     */

  }, {
    key: 'isRateLimited',
    value: function isRateLimited(uri) {
      // determine if the URI is associated with a common identity API
      if (uri && (uri.includes('idbroker') || uri.includes('identity'))) {
        return this.getRateLimitStatus(uri);
      }
      return false;
    }
  }]);
  return RateLimitInterceptor;
}(_httpCore.Interceptor);

exports.default = RateLimitInterceptor;


},{"@ciscospark/http-core":123,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _clone2 = require('lodash/clone');

var _clone3 = _interopRequireDefault(_clone2);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var requestHeaderName = 'cisco-no-http-redirect'; /*!
                                                   * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                                   */

var responseHeaderName = 'cisco-location';

/**
 * @class
 */

var RedirectInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(RedirectInterceptor, _Interceptor);

  function RedirectInterceptor() {
    (0, _classCallCheck3.default)(this, RedirectInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (RedirectInterceptor.__proto__ || (0, _getPrototypeOf2.default)(RedirectInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(RedirectInterceptor, [{
    key: 'onRequest',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @returns {Object}
     */
    value: function onRequest(options) {
      if (options.uri.includes(this.spark.config.credentials.samlUrl) || options.uri.includes(this.spark.config.credentials.tokenUrl) || options.uri.includes(this.spark.config.credentials.authorizeUrl)) {
        return options;
      }

      // If cisco-no-http-redirect is already set, don't overwrite it
      if (requestHeaderName in options.headers) {
        // If cisco-no-http-redirect is set to null, false, or undefined, delete
        // it to prevent a CORS preflight.
        if (!options.headers[requestHeaderName]) {
          (0, _deleteProperty2.default)(options.headers, requestHeaderName);
        }
        return options;
      }
      options.headers[requestHeaderName] = true;
      options.$redirectCount = options.$redirectCount || 0;
      return options;
    }

    /**
     * @see Interceptor#onResponse
     * @param {Object} options
     * @param {HttpResponse} response
     * @returns {Object}
     */

  }, {
    key: 'onResponse',
    value: function onResponse(options, response) {
      if (response.headers && response.headers[responseHeaderName]) {
        options = (0, _clone3.default)(options);
        options.uri = response.headers[responseHeaderName];
        options.$redirectCount += 1;
        if (options.$redirectCount > this.spark.config.maxAppLevelRedirects) {
          return _promise2.default.reject(new Error('Maximum redirects exceeded'));
        }

        return this.spark.request(options);
      }

      return response;
    }
  }], [{
    key: 'create',

    /**
     * @returns {RedirectInterceptor}
     */
    value: function create() {
      return new RedirectInterceptor({ spark: this });
    }
  }]);
  return RedirectInterceptor;
}(_httpCore.Interceptor);

exports.default = RedirectInterceptor;


},{"@ciscospark/http-core":123,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"lodash/clone":1611}],138:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
var RequestEventInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(RequestEventInterceptor, _Interceptor);

  function RequestEventInterceptor() {
    (0, _classCallCheck3.default)(this, RequestEventInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (RequestEventInterceptor.__proto__ || (0, _getPrototypeOf2.default)(RequestEventInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(RequestEventInterceptor, [{
    key: 'onRequest',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @returns {Object}
     */
    value: function onRequest(options) {
      var logger = (0, _get3.default)(this, 'spark.logger', console);
      try {
        this.spark.trigger('request:start', options);
      } catch (error) {
        logger.warn('event handler for request:start failed ', error);
      }
      return _promise2.default.resolve(options);
    }

    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @param {Error} reason
     * @returns {Object}
     */

  }, {
    key: 'onRequestError',
    value: function onRequestError(options, reason) {
      // We need to do the normal onRequest logging, but then log how the request
      // failed since the response logger won't be called.
      var logger = (0, _get3.default)(this, 'spark.logger', console);
      try {
        this.spark.trigger('request:end', options, reason);
        this.spark.trigger('request:failure', options, reason);
      } catch (error) {
        logger.warn('event handler for request:end failed ', error);
      }
      return _promise2.default.reject(reason);
    }

    /**
     * @see Interceptor#onResponse
     * @param {Object} options
     * @param {HttpResponse} response
     * @returns {Object}
     */

  }, {
    key: 'onResponse',
    value: function onResponse(options, response) {
      var logger = (0, _get3.default)(this, 'spark.logger', console);
      try {
        this.spark.trigger('request:success', response.options, response);
      } catch (error) {
        logger.warn('event handler for request:success failed ', error);
      }
      return _promise2.default.resolve(response);
    }

    /**
     * @see Interceptor#onResponseError
     * @param {Object} options
     * @param {Error} reason
     * @returns {Object}
     */

  }, {
    key: 'onResponseError',
    value: function onResponseError(options, reason) {
      var logger = (0, _get3.default)(this, 'spark.logger', console);
      try {
        this.spark.trigger('request:end', options, reason);
        this.spark.trigger('request:failure', options, reason);
      } catch (error) {
        logger.warn('event handler for request:failure failed ', error);
      }
      return _promise2.default.reject(reason);
    }
  }], [{
    key: 'create',

    /**
     * @returns {RequestEventInterceptor}
     */
    value: function create() {
      return new RequestEventInterceptor({ spark: this });
    }
  }]);
  return RequestEventInterceptor;
}(_httpCore.Interceptor); /*!
                           * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                           */

exports.default = RequestEventInterceptor;


},{"@ciscospark/http-core":123,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"lodash/get":1636}],139:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var RequestLoggerInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(RequestLoggerInterceptor, _Interceptor);

  function RequestLoggerInterceptor() {
    (0, _classCallCheck3.default)(this, RequestLoggerInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (RequestLoggerInterceptor.__proto__ || (0, _getPrototypeOf2.default)(RequestLoggerInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(RequestLoggerInterceptor, [{
    key: 'onRequest',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @returns {Object}
     */
    value: function onRequest(options) {
      var logger = (0, _get3.default)(this, 'spark.logger', console);
      logger.info('/**********************************************************************\\ ');
      logger.info('Request:', options.method || 'GET', options.uri);
      logger.info('WEBEX_TRACKINGID: ', (0, _get3.default)(options, 'headers.trackingid'));
      /* istanbul ignore next */
      if ((0, _has3.default)(options, 'headers.x-trans-id')) {
        logger.info('X-Trans-ID: ', (0, _get3.default)(options, 'headers.x-trans-id'));
      }
      if ((0, _has3.default)(this, 'spark.internal.device.userId')) {
        logger.info('User ID:', (0, _get3.default)(this, 'spark.internal.device.userId'));
      }
      var now = new Date();
      if (process.env.ENABLE_VERBOSE_NETWORK_LOGGING) {
        logger.info('timestamp (start): ', now.getTime(), now.toISOString());
        try {
          // Determine if body is a buffer without relying on Buffer to avoid
          // node/browser conflicts.
          if (options.body && options.body.length && !(0, _isArray3.default)(options.body) && !(0, _isString3.default)(options.body)) {
            logger.info('Request Options:', _util2.default.inspect((0, _omit3.default)(options, 'body'), { depth: null }));
          } else {
            logger.info('Request Options:', _util2.default.inspect(options, { depth: null }));
          }
        } catch (e) {
          logger.warn('Could not stringify request options:', e);
        }
      }

      return _promise2.default.resolve(options);
    }

    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @param {Error} reason
     * @returns {Object}
     */

  }, {
    key: 'onRequestError',
    value: function onRequestError(options, reason) {
      // We need to do the normal onRequest logging, but then log how the request
      // failed since the response logger won't be called.
      this.onRequest(options);
      var logger = (0, _get3.default)(this, 'spark.logger', console);
      logger.error('Request Failed: ', reason.stack);
      logger.info('\\**********************************************************************/');

      return _promise2.default.reject(reason);
    }
  }], [{
    key: 'create',

    /**
     * @returns {RequestLoggerInterceptor}
     */
    value: function create() {
      return new RequestLoggerInterceptor({ spark: this });
    }
  }]);
  return RequestLoggerInterceptor;
}(_httpCore.Interceptor);

exports.default = RequestLoggerInterceptor;


}).call(this,require('_process'))
},{"@ciscospark/http-core":123,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isString":1662,"lodash/omit":1679,"util":1769}],140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
var RequestTimingInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(RequestTimingInterceptor, _Interceptor);

  function RequestTimingInterceptor() {
    (0, _classCallCheck3.default)(this, RequestTimingInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (RequestTimingInterceptor.__proto__ || (0, _getPrototypeOf2.default)(RequestTimingInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(RequestTimingInterceptor, [{
    key: 'onRequest',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @returns {Object}
     */
    value: function onRequest(options) {
      options.$timings = options.$timings || {};
      options.$timings.requestStart = Date.now();
      return options;
    }

    /**
     * @see Interceptor#onRequestError
     * @param {Object} options
     * @returns {Object}
     */

  }, {
    key: 'onRequestError',
    value: function onRequestError(options) {
      options.$timings.requestEnd = options.$timings.requestFail = Date.now();
      return _promise2.default.reject(options);
    }

    /**
     * @see Interceptor#onResponse
     * @param {Object} options
     * @param {HttpResponse} response
     * @returns {Object}
     */

  }, {
    key: 'onResponse',
    value: function onResponse(options, response) {
      options.$timings.requestEnd = Date.now();
      return _promise2.default.resolve(response);
    }

    /**
     * @see Interceptor#onResponseError
     * @param {Object} options
     * @param {Error} reason
     * @returns {Object}
     */

  }, {
    key: 'onResponseError',
    value: function onResponseError(options, reason) {
      options.$timings.requestEnd = options.$timings.requestFail = Date.now();
      return _promise2.default.reject(reason);
    }
  }], [{
    key: 'create',

    /**
     * @param {Object} options
     * @returns {RequestTimingInterceptor}
     */
    value: function create(options) {
      return new RequestTimingInterceptor(this, options);
    }
  }]);
  return RequestTimingInterceptor;
}(_httpCore.Interceptor); /*!
                           * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                           */

exports.default = RequestTimingInterceptor;


},{"@ciscospark/http-core":123,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],141:[function(require,module,exports){
(function (Buffer,process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var ResponseLoggerInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(ResponseLoggerInterceptor, _Interceptor);

  function ResponseLoggerInterceptor() {
    (0, _classCallCheck3.default)(this, ResponseLoggerInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (ResponseLoggerInterceptor.__proto__ || (0, _getPrototypeOf2.default)(ResponseLoggerInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(ResponseLoggerInterceptor, [{
    key: 'onResponse',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @param {HttpResponse} response
     * @returns {Object}
     */
    value: function onResponse(options, response) {
      var now = new Date();
      this.printResponseHeader(options, response);

      var logger = (0, _get3.default)(this, 'spark.logger', console);
      if (process.env.ENABLE_VERBOSE_NETWORK_LOGGING) {
        logger.info('timestamp (end): ', now.getTime(), now.toISOString());
        if (typeof response.body === 'string' || Buffer.isBuffer(response.body)) {
          logger.info('Response: ', 'Not printed, it`s probably a file');
        } else if ((0, _typeof3.default)(response.body) === 'object') {
          try {
            logger.info('Response: ', _util2.default.inspect((0, _omit3.default)(response.body, 'features'), { depth: null }));
          } catch (err) {
            logger.info('Response: ', '[Not Serializable]', err);
          }
        }
      }
      logger.info('\\**********************************************************************/');

      return response;
    }

    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @param {Object} reason
     * @returns {Object}
     */

  }, {
    key: 'onResponseError',
    value: function onResponseError(options, reason) {
      var now = new Date();
      this.printResponseHeader(options, reason);

      var logger = (0, _get3.default)(this, 'spark.logger', console);
      if (process.env.ENABLE_VERBOSE_NETWORK_LOGGING) {
        logger.info('timestamp (end): ', now.getTime(), now.toISOString());
        try {
          logger.error('Response: ', _util2.default.inspect(reason.body, { depth: null }));
        } catch (err) {
          logger.error('Response: ', reason.body);
        }
      }
      logger.info('\\**********************************************************************/');

      return _promise2.default.reject(reason);
    }

    /**
     * Prints the basic header
     * @param {Object} options
     * @param {HttpResponse|SparkHttpError} response
     * @returns {undefined}
     */

  }, {
    key: 'printResponseHeader',
    value: function printResponseHeader(options, response) {
      var logger = (0, _get3.default)(this, 'spark.logger', console);
      logger.info('Status Code:', response.statusCode);
      logger.info('WEBEX_TRACKINGID:', (0, _get3.default)(options, 'headers.trackingid') || (0, _get3.default)(response, 'headers.trackingid'));
      logger.info('Network duration:', options.$timings.networkEnd - options.$timings.networkStart);
      logger.info('Processing duration:', options.$timings.requestEnd - options.$timings.requestStart);
    }
  }], [{
    key: 'create',

    /**
     * @returns {ResponseLoggerInterceptor}
     */
    value: function create() {
      return new ResponseLoggerInterceptor({ spark: this });
    }
  }]);
  return ResponseLoggerInterceptor;
}(_httpCore.Interceptor);

exports.default = ResponseLoggerInterceptor;


}).call(this,{"isBuffer":require("../../../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")},require('_process'))
},{"../../../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":1740,"@ciscospark/http-core":123,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"lodash/get":1636,"lodash/omit":1679,"util":1769}],142:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sequenceNumbers = new _weakMap2.default();

/**
 * @class
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var SparkTrackingIdInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(SparkTrackingIdInterceptor, _Interceptor);

  function SparkTrackingIdInterceptor() {
    (0, _classCallCheck3.default)(this, SparkTrackingIdInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (SparkTrackingIdInterceptor.__proto__ || (0, _getPrototypeOf2.default)(SparkTrackingIdInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(SparkTrackingIdInterceptor, [{
    key: 'onRequest',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @returns {Object}
     */
    value: function onRequest(options) {
      options.headers = options.headers || {};
      // If trackingid is already set, don't overwrite it
      if ('trackingid' in options.headers) {
        // If trackingid is set to null, false, or undefined, delete it to
        // prevent a CORS preflight.
        if (!options.headers.trackingid) {
          (0, _deleteProperty2.default)(options.headers, 'trackingid');
        }
        return options;
      }

      if (this.requiresTrackingId(options)) {
        options.headers.trackingid = this.spark.sessionId + '_' + this.sequence;
      }

      if (options.headers.trackingid && options.replayCount) {
        var tid = options.headers.trackingid.split('+');
        tid[1] = options.replayCount;
        options.headers.trackingid = tid.join('+');
      }

      return options;
    }

    /**
     * Determines whether or not include a tracking id
     * @param {Object} options
     * @returns {boolean}
     */

  }, {
    key: 'requiresTrackingId',
    value: function requiresTrackingId(options) {
      return !options.headers.trackingid;
    }
  }, {
    key: 'sequence',

    /**
     * Sequence number; increments on access
     * @type {Number}
     */
    get: function get() {
      var sq = sequenceNumbers.get(this) || 0;
      sq += 1;
      sequenceNumbers.set(this, sq);
      return sq;
    }

    /**
     * @returns {SparkTrackingIdInterceptor}
     */

  }], [{
    key: 'create',
    value: function create() {
      return new SparkTrackingIdInterceptor({ spark: this });
    }
  }]);
  return SparkTrackingIdInterceptor;
}(_httpCore.Interceptor);

exports.default = SparkTrackingIdInterceptor;


},{"@ciscospark/http-core":123,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],143:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _common = require('@ciscospark/common');

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var strings = new _weakMap2.default();
/**
 * @class
 */

var SparkUserAgentInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(SparkUserAgentInterceptor, _Interceptor);

  /**
   * @param {Object} [options={}]
   * @param {SparkCore} [options.spark]
   * @private
   * @returns {SparkUserAgentInterceptor}
   */
  function SparkUserAgentInterceptor() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SparkUserAgentInterceptor);

    var appName = (0, _get3.default)(options, 'spark.config.appName');
    var appVersion = (0, _get3.default)(options, 'spark.config.appVersion');

    var libName = (0, _get3.default)(options, 'spark.ciscospark', false) ? 'ciscospark' : 'spark-js-sdk';
    var libVersion = (0, _get3.default)(options, 'spark.version', 'development');

    var _this = (0, _possibleConstructorReturn3.default)(this, (SparkUserAgentInterceptor.__proto__ || (0, _getPrototypeOf2.default)(SparkUserAgentInterceptor)).call(this, options));

    if (appName && appVersion) {
      strings.set(_this, appName + '/' + appVersion + ' (' + (_common.inBrowser ? 'web' : 'node') + ') ' + libName + '/' + libVersion);
    } else {
      strings.set(_this, libName + '/' + libVersion + ' (' + (_common.inBrowser ? 'web' : 'node') + ')');
    }
    return _this;
  }

  /**
   * @returns {SparkUserAgentInterceptor}
   */


  (0, _createClass3.default)(SparkUserAgentInterceptor, [{
    key: 'onRequest',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @returns {Object}
     */
    value: function onRequest(options) {
      options.headers = options.headers || {};

      if (options.uri && (options.uri.includes(this.spark.config.credentials.samlUrl) || options.uri.includes(this.spark.config.credentials.tokenUrl) || options.uri.includes(this.spark.config.credentials.authorizeUrl))) {
        return options;
      }

      if ('spark-user-agent' in options.headers) {
        if (!options.headers['spark-user-agent']) {
          (0, _deleteProperty2.default)(options.headers, 'spark-user-agent');
        }
        return options;
      }

      options.headers['spark-user-agent'] = strings.get(this);

      return options;
    }
  }], [{
    key: 'create',
    value: function create() {
      return new SparkUserAgentInterceptor({ spark: this });
    }
  }]);
  return SparkUserAgentInterceptor;
}(_httpCore.Interceptor);

exports.default = SparkUserAgentInterceptor;


},{"@ciscospark/common":112,"@ciscospark/http-core":123,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"lodash/get":1636}],144:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _sparkPlugin = require('./spark-plugin');

var _sparkPlugin2 = _interopRequireDefault(_sparkPlugin);

var _common = require('@ciscospark/common');

var _sparkHttpError = require('./spark-http-error');

var _sparkHttpError2 = _interopRequireDefault(_sparkHttpError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base class for coalescing requests to batched APIs
 * @class Batcher
 */
var Batcher = _sparkPlugin2.default.extend({
  session: {
    deferreds: {
      type: 'object',
      default: function _default() {
        return new _map2.default();
      }
    },
    queue: {
      type: 'array',
      default: function _default() {
        return [];
      }
    }
  },

  derived: {
    bounce: {
      fn: function fn() {
        var _this = this;

        return (0, _common.cappedDebounce)(function () {
          return _this.executeQueue.apply(_this, arguments);
        }, this.config.batcherWait, {
          maxCalls: this.config.batcherMaxCalls,
          maxWait: this.config.batcherMaxWait
        });
      }
    }
  },

  /**
   * Requests an item from a batched API
   * @param {Object} item
   * @returns {Promise<mixed>}
   */
  request: function request(item) {
    var _this2 = this;

    // So far, I can't find a way to avoid three layers of nesting here.
    /* eslint max-nested-callbacks: [0] */
    var defer = new _common.Defer();
    this.fingerprintRequest(item).then(function (idx) {
      if (_this2.deferreds.has(idx)) {
        defer.resolve(_this2.deferreds.get(idx).promise);
        return;
      }
      _this2.deferreds.set(idx, defer);
      _this2.prepareItem(item).then(function (req) {
        defer.promise = defer.promise.then((0, _common.tap)(function () {
          return _this2.deferreds.delete(idx);
        })).catch(function (reason) {
          _this2.deferreds.delete(idx);
          return _promise2.default.reject(reason);
        });

        _this2.enqueue(req).then(function () {
          return _this2.bounce();
        }).catch(function (reason) {
          return defer.reject(reason);
        });
      }).catch(function (reason) {
        return defer.reject(reason);
      });
    }).catch(function (reason) {
      return defer.reject(reason);
    });

    return defer.promise;
  },


  /**
   * Adds an item to the queue.
   * Intended to be overridden
   * @param {mixed} req
   * @returns {Promise<undefined>}
   */
  enqueue: function enqueue(req) {
    this.queue.push(req);
    return _promise2.default.resolve();
  },


  /**
   * Transform the item before adding it to the queue
   * Intended to be overridden
   * @param {mixed} item
   * @returns {Promise<mixed>}
   */
  prepareItem: function prepareItem(item) {
    return _promise2.default.resolve(item);
  },


  /**
   * Detaches the current queue, does any appropriate transforms, and submits it
   * to the API.
   * @returns {Promise<undefined>}
   */
  executeQueue: function executeQueue() {
    var _this3 = this;

    var queue = this.queue.splice(0, this.config.batcherMaxCalls);
    return new _promise2.default(function (resolve) {
      resolve(_this3.prepareRequest(queue).then(function (payload) {
        return _this3.submitHttpRequest(payload).then(function (res) {
          return _this3.handleHttpSuccess(res);
        });
      }).catch(function (reason) {
        if (reason instanceof _sparkHttpError2.default) {
          return _this3.handleHttpError(reason);
        }

        return _promise2.default.all(queue.map(function (item) {
          return _this3.getDeferredForRequest(item).then(function (defer) {
            defer.reject(reason);
          });
        }));
      }));
    }).catch(function (reason) {
      _this3.logger.error(process.env.NODE_ENV === 'production' ? reason : reason.stack);
      return _promise2.default.reject(reason);
    });
  },


  /**
   * Performs any final transforms on the queue before submitting it to the API
   * Intended to be overridden
   * @param {Object|Array} queue
   * @returns {Promise<Object>}
   */
  prepareRequest: function prepareRequest(queue) {
    return _promise2.default.resolve(queue);
  },


  /**
   * Submits the prepared request body to the API.
   * This method *must* be overridden
   * @param {Object} payload
   * @returns {Promise<HttpResponseObject>}
   */
  // eslint-disable-next-line no-unused-vars
  submitHttpRequest: function submitHttpRequest(payload) {
    throw new Error('request() must be implemented');
  },


  /**
   * Actions taken when the http request returns a success
   * Intended to be overridden
   * @param {Promise<HttpResponseObject>} res
   * @returns {Promise<undefined>}
   */
  handleHttpSuccess: function handleHttpSuccess(res) {
    var _this4 = this;

    return _promise2.default.all((res.body && res.body.items || res.body).map(function (item) {
      return _this4.acceptItem(item);
    }));
  },


  /**
   * Actions taken when the http request returns a failure. Typically, this
   * means failing the entire queue, but could be overridden in some
   * implementations to e.g. reenqueue.
   * Intended to be overridden
   * @param {SparkHttpError} reason
   * @returns {Promise<undefined>}
   */
  handleHttpError: function handleHttpError(reason) {
    var _this5 = this;

    if (reason instanceof _sparkHttpError2.default) {
      if ((0, _has3.default)(reason, 'options.body.map')) {
        return _promise2.default.all(reason.options.body.map(function (item) {
          return _this5.getDeferredForRequest(item).then(function (defer) {
            defer.reject(reason);
          });
        }));
      }
    }
    this.logger.error('http error handler called without a SparkHttpError object', reason);
    return _promise2.default.reject(reason);
  },


  /**
   * Determines if the item succeeded or failed and delegates accordingly
   * @param {Object} item
   * @returns {Promise<undefined>}
   */
  acceptItem: function acceptItem(item) {
    var _this6 = this;

    return this.didItemFail(item).then(function (didFail) {
      if (didFail) {
        return _this6.handleItemFailure(item);
      }
      return _this6.handleItemSuccess(item);
    });
  },


  /**
   * Indicates if the specified response item implies a success or a failure
   * Intended to be overridden
   * @param {Object} item
   * @returns {Promise<Boolean>}
   */
  // eslint-disable-next-line no-unused-vars
  didItemFail: function didItemFail(item) {
    return _promise2.default.resolve(false);
  },


  /**
   * Finds the Defer for the specified item and rejects its promise
   * Intended to be overridden
   * @param {Object} item
   * @returns {Promise<undefined>}
   */
  handleItemFailure: function handleItemFailure(item) {
    return this.getDeferredForResponse(item).then(function (defer) {
      defer.reject(item);
    });
  },


  /**
   * Finds the Defer for the specified item and resolves its promise
   * Intended to be overridden
   * @param {Object} item
   * @returns {Promise<undefined>}
   */
  handleItemSuccess: function handleItemSuccess(item) {
    return this.getDeferredForResponse(item).then(function (defer) {
      defer.resolve(item);
    });
  },


  /**
   * Returns the Deferred for the specified request item
   * @param {Object} item
   * @returns {Promise<Defer>}
   */
  getDeferredForRequest: function getDeferredForRequest(item) {
    var _this7 = this;

    return this.fingerprintRequest(item).then(function (idx) {
      var defer = _this7.deferreds.get(idx);
      /* istanbul ignore if */
      if (!defer) {
        throw new Error('Could not find pending request for received response');
      }
      return defer;
    });
  },


  /**
   * Returns the Deferred for the specified response item
   * @param {Object} item
   * @returns {Promise<Defer>}
   */
  getDeferredForResponse: function getDeferredForResponse(item) {
    var _this8 = this;

    return this.fingerprintResponse(item).then(function (idx) {
      var defer = _this8.deferreds.get(idx);
      /* istanbul ignore if */
      if (!defer) {
        throw new Error('Could not find pending request for received response');
      }
      return defer;
    });
  },


  /**
   * Generates a unique identifier for the item in a request payload
   * Intended to be overridden
   * Note that overrides must return a primitive.
   * @param {Object} item
   * @returns {Promise<primitive>}
   */
  // eslint-disable-next-line no-unused-vars
  fingerprintRequest: function fingerprintRequest(item) {
    throw new Error('fingerprintRequest() must be implemented');
  },


  /**
   * Generates a unique identifier for the item in a response payload
   * Intended to be overridden
   * Note that overrides must return a primitive.
   * @param {Object} item
   * @returns {Promise<primitive>}
   */
  // eslint-disable-next-line no-unused-vars
  fingerprintResponse: function fingerprintResponse(item) {
    throw new Error('fingerprintResponse() must be implemented');
  },
  version: '1.32.5'
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = Batcher;


}).call(this,require('_process'))
},{"./spark-http-error":153,"./spark-plugin":155,"@ciscospark/common":112,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"lodash/has":1638}],145:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _clone2 = require('lodash/clone');

var _clone3 = _interopRequireDefault(_clone2);

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _desc, _value, _obj; /*!
                                                                   * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                                                   */

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _common = require('@ciscospark/common');

var _commonTimers = require('@ciscospark/common-timers');

var _sparkPlugin = require('../spark-plugin');

var _sparkPlugin2 = _interopRequireDefault(_sparkPlugin);

var _decorators = require('../storage/decorators');

var _grantErrors = require('./grant-errors');

var _grantErrors2 = _interopRequireDefault(_grantErrors);

var _scope = require('./scope');

var _token = require('./token');

var _token2 = _interopRequireDefault(_token);

var _tokenCollection = require('./token-collection');

var _tokenCollection2 = _interopRequireDefault(_tokenCollection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @class
 */
var Credentials = _sparkPlugin2.default.extend((_dec = (0, _common.oneFlight)({ keyFactory: function keyFactory(scope) {
    return scope;
  } }), _dec2 = (0, _decorators.waitForValue)('@'), _dec3 = (0, _decorators.persist)('@'), _dec4 = (0, _decorators.waitForValue)('@'), _dec5 = (0, _common.whileInFlight)('isRefreshing'), _dec6 = (0, _decorators.waitForValue)('@'), (_obj = {
  collections: {
    userTokens: _tokenCollection2.default
  },

  dataTypes: {
    token: (0, _common.makeStateDataType)(_token2.default, 'token').dataType
  },

  derived: {
    canAuthorize: {
      deps: ['supertoken', 'supertoken.canAuthorize', 'canRefresh'],
      fn: function fn() {
        return Boolean(this.supertoken && this.supertoken.canAuthorize || this.canRefresh);
      }
    },
    canRefresh: {
      deps: ['supertoken', 'supertoken.canRefresh'],
      fn: function fn() {
        // If we're operating in JWT mode, we have to delegate to the consumer
        if (this.config.jwtRefreshCallback) {
          return true;
        }

        return Boolean(this.supertoken && this.supertoken.canRefresh);
      }
    }
  },

  props: {
    supertoken: (0, _common.makeStateDataType)(_token2.default, 'token').prop
  },

  namespace: 'Credentials',

  session: {
    isRefreshing: {
      default: false,
      type: 'boolean'
    },
    /**
     * Becomes `true` once the {@link loaded} event fires.
     * @see {@link SparkPlugin#ready}
     * @instance
     * @memberof Credentials
     * @type {boolean}
     */
    ready: {
      default: false,
      type: 'boolean'
    },
    refreshTimer: {
      default: undefined,
      type: 'any'
    }
  },

  /**
   * Generates an OAuth Login URL. Prefers the api.ciscospark.com proxy if the
   * instance is initialize with an authorizatUrl, but fallsback to idbroker
   * as the base otherwise.
   * @instance
   * @memberof Credentials
   * @param {Object} [options={}]
   * @returns {string}
   */
  buildLoginUrl: function buildLoginUrl() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { clientType: 'public' };

    /* eslint-disable camelcase */
    if (options.state && !(0, _isObject3.default)(options.state)) {
      throw new Error('if specified, `options.state` must be an object');
    }

    options.client_id = this.config.client_id;
    options.redirect_uri = this.config.redirect_uri;
    options.scope = this.config.scope;

    options = (0, _cloneDeep3.default)(options);

    if (!options.response_type) {
      options.response_type = options.clientType === 'public' ? 'token' : 'code';
    }
    (0, _deleteProperty2.default)(options, 'clientType');

    if (options.state) {
      if (!(0, _isEmpty3.default)(options.state)) {
        options.state = _common.base64.toBase64Url((0, _stringify2.default)(options.state));
      } else {
        delete options.state;
      }
    }
    return this.config.authorizeUrl + '?' + _querystring2.default.stringify(options);
    /* eslint-enable camelcase */
  },


  /**
   * Generates a Logout URL
   * @instance
   * @memberof Credentials
   * @param {Object} [options={}]
   * @returns {[type]}
   */
  buildLogoutUrl: function buildLogoutUrl() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return this.config.logoutUrl + '?' + _querystring2.default.stringify((0, _assign2.default)({
      cisService: this.config.service,
      goto: this.config.redirect_uri
    }, options));
  },


  /**
   * Generates a number between 60% - 90% of expired value
   * @instance
   * @memberof Credentials
   * @param {number} expiration
   * @private
   * @returns {number}
   */
  calcRefreshTimeout: function calcRefreshTimeout(expiration) {
    return Math.floor((Math.floor(Math.random() * 4) + 6) / 10 * expiration);
  },
  constructor: function constructor() {
    var _this = this;

    // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure
    // function.
    this._dataTypes = (0, _cloneDeep3.default)(this._dataTypes);
    (0, _keys2.default)(this._dataTypes).forEach(function (key) {
      if (_this._dataTypes[key].set) {
        _this._dataTypes[key].set = _this._dataTypes[key].set.bind(_this);
      }
    });
    // END HACK

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_sparkPlugin2.default, this, args);
  },


  /**
   * Downscopes a token
   * @instance
   * @memberof Credentials
   * @param {string} scope
   * @private
   * @returns {Promise<Token>}
   */
  downscope: function downscope(scope) {
    var _this2 = this;

    return this.supertoken.downscope(scope).catch(function (reason) {
      _this2.logger.error('credentials: failed to downscope supertoken to ' + scope, reason);
      _this2.logger.error('credentials: falling back to supertoken for ' + scope);
      return _promise2.default.resolve(new _token2.default((0, _assign2.default)({ scope: scope }, _this2.supertoken.serialize())), { parent: _this2 });
    });
  },


  /**
   * Requests a client credentials grant and returns the token. Given the
   * limited use for such tokens as this time, this method does not cache its
   * token.
   * @instance
   * @memberof Credentials
   * @param {Object} options
   * @returns {Promise<Token>}
   */
  getClientToken: function getClientToken() {
    var _this3 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this.logger.info('credentials: requesting client credentials grant');

    options = options || {};
    options.scope = options.scope || 'webexsquare:admin';

    return this.spark.request({
      /* eslint-disable camelcase */
      method: 'POST',
      uri: this.config.tokenUrl,
      form: {
        grant_type: 'client_credentials',
        scope: options.scope,
        self_contained_token: true
      },
      auth: {
        user: this.config.client_id,
        pass: this.config.client_secret,
        sendImmediately: true
      },
      shouldRefreshAccessToken: false
      /* eslint-enable camelcase */
    }).then(function (res) {
      return new _token2.default(res.body, { parent: _this3 });
    }).catch(function (res) {
      if (res.statusCode !== 400) {
        return _promise2.default.reject(res);
      }

      var ErrorConstructor = _grantErrors2.default.select(res.body.error);
      return _promise2.default.reject(new ErrorConstructor(res._res || res));
    });
  },

  /**
   * Resolves with a token with the specified scopes. If no scope is specified,
   * defaults to omit(spark.credentials.scope, 'spark:kms'). If no such token is
   * available, downscopes the supertoken to that scope.
   * @instance
   * @memberof Credentials
   * @param {string} scope
   * @returns {Promise<Token>}
   */
  getUserToken: function getUserToken(scope) {
    var _this4 = this;

    return _promise2.default.resolve(!this.isRefreshing || new _promise2.default(function (resolve) {
      _this4.logger.info('credentials: token refresh inflight; delaying getUserToken until refresh completes');
      _this4.once('change:isRefreshing', function () {
        _this4.logger.info('credentials: token refresh complete; reinvoking getUserToken');
        resolve();
      });
    })).then(function () {
      if (!_this4.canAuthorize) {
        _this4.logger.info('credentials: cannot produce an access token from current state');
        return _promise2.default.reject(new Error('Current state cannot produce an access token'));
      }

      if (!scope) {
        scope = (0, _scope.filterScope)('spark:kms', _this4.config.scope);
      }

      scope = (0, _scope.sortScope)(scope);

      if (scope === (0, _scope.sortScope)(_this4.config.scope)) {
        return _promise2.default.resolve(_this4.supertoken);
      }

      var token = _this4.userTokens.get(scope);

      // we should also check for the token.access_token since token object does
      // not get cleared on unsetting while logging out.
      if (!token || !token.access_token) {
        return _this4.downscope(scope).then((0, _common.tap)(function (t) {
          return _this4.userTokens.add(t);
        }));
      }

      return _promise2.default.resolve(token);
    });
  },

  /**
   * Initializer
   * @instance
   * @memberof Credentials
   * @param {Object} attrs
   * @param {Object} options
   * @private
   * @returns {Credentials}
   */
  initialize: function initialize(attrs, options) {
    var _this5 = this;

    if (attrs) {
      if (typeof attrs === 'string') {
        this.supertoken = attrs;
      }

      if (attrs.access_token) {
        this.supertoken = attrs;
      }

      if (attrs.authorization) {
        if (attrs.authorization.supertoken) {
          this.supertoken = attrs.authorization.supertoken;
        } else {
          this.supertoken = attrs.authorization;
        }
      }

      // schedule refresh
      if (this.supertoken && this.supertoken.expires) {
        this.scheduleRefresh(this.supertoken.expires);
      }
    }

    (0, _apply2.default)(_sparkPlugin2.default.prototype.initialize, this, [attrs, options]);

    this.listenToOnce(this.parent, 'change:config', function () {
      if (_this5.config.authorizationString) {
        var parsed = _url2.default.parse(_this5.config.authorizationString, true);
        /* eslint-disable camelcase */
        _this5.config.client_id = parsed.query.client_id;
        _this5.config.redirect_uri = parsed.query.redirect_uri;
        _this5.config.scope = parsed.query.scope;
        _this5.config.authorizeUrl = parsed.href.substr(0, parsed.href.indexOf('?'));
        /* eslint-enable camelcase */
      }
    });

    this.spark.once('loaded', function () {
      _this5.ready = true;
    });
  },

  /**
   * Clears all tokens from store them from the stores.
   *
   * This is no longer quite the right name for this method, but all of the
   * alternatives I'm coming up with are already taken.
   * @instance
   * @memberof Credentials
   * @returns {Promise}
   */
  invalidate: function invalidate() {
    this.logger.info('credentials: invalidating tokens');

    // clear refresh timer
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.unset('refreshTimer');
    }

    try {
      this.unset('supertoken');
    } catch (err) {
      this.logger.warn('credentials: failed to clear supertoken', err);
    }

    while (this.userTokens.models.length) {
      try {
        this.userTokens.remove(this.userTokens.models[0]);
      } catch (err) {
        this.logger.warn('credentials: failed to remove user token', err);
      }
    }

    this.logger.info('credentials: finished removing tokens');

    // Return a promise to give the storage layer a tick or two to clear
    // localStorage
    return _promise2.default.resolve();
  },

  /**
   * Removes the supertoken and child tokens, then refreshes the supertoken;
   * subsequent calls to {@link Credentials#getUserToken()} will re-downscope
   * child tokens. Enqueus revocation of previous previousTokens. Yes, that's
   * the correct number of "previous"es.
   * @instance
   * @memberof Credentials
   * @returns {Promise}
   */
  refresh: function refresh() {
    var _this6 = this;

    this.logger.info('credentials: refresh requested');

    var supertoken = this.supertoken;
    var tokens = (0, _clone3.default)(this.userTokens.models);

    // This is kind of a leaky abstraction, since it relies on the authorization
    // plugin, but the only alternatives I see are
    // 1. put all JWT support in core
    // 2. have separate jwt and non-jwt auth plugins
    // while I like #2 from a code simplicity standpoint, the third-party DX
    // isn't great
    if (this.config.jwtRefreshCallback) {
      return this.config.jwtRefreshCallback(this.spark).then(function (jwt) {
        return _this6.spark.authorization.requestAccessTokenFromJwt({ jwt: jwt });
      });
    }

    return supertoken.refresh().then(function (st) {
      // clear refresh timer
      if (_this6.refreshTimer) {
        clearTimeout(_this6.refreshTimer);
        _this6.unset('refreshTimer');
      }
      _this6.supertoken = st;
      return _promise2.default.all(tokens.map(function (token) {
        return _this6.downscope(token.scope)
        // eslint-disable-next-line max-nested-callbacks
        .then(function (t) {
          _this6.logger.info('credentials: revoking token for ' + token.scope);
          return token.revoke().catch(function (err) {
            _this6.logger.warn('credentials: failed to revoke user token', err);
          }).then(function () {
            _this6.userTokens.remove(token.scope);
            _this6.userTokens.add(t);
          });
        });
      }));
    }).then(function () {
      _this6.scheduleRefresh(_this6.supertoken.expires);
    });
  },


  /**
   * Schedules a token refresh or refreshes the token if token has expired
   * @instance
   * @memberof Credentials
   * @param {number} expires
   * @private
   * @returns {undefined}
   */
  scheduleRefresh: function scheduleRefresh(expires) {
    var _this7 = this;

    var expiresIn = expires - Date.now();
    if (expiresIn > 0) {
      var timeoutLength = this.calcRefreshTimeout(expiresIn);
      this.refreshTimer = (0, _commonTimers.safeSetTimeout)(function () {
        return _this7.refresh();
      }, timeoutLength);
    } else {
      this.refresh();
    }
  },
  version: '1.32.5'
}, (_applyDecoratedDescriptor(_obj, 'getUserToken', [_dec, _dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getUserToken'), _obj), _applyDecoratedDescriptor(_obj, 'initialize', [_dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initialize'), _obj), _applyDecoratedDescriptor(_obj, 'invalidate', [_common.oneFlight, _dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'invalidate'), _obj), _applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight, _dec5, _dec6], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj)), _obj)));

exports.default = Credentials;


},{"../spark-plugin":155,"../storage/decorators":156,"./grant-errors":146,"./scope":148,"./token":150,"./token-collection":149,"@ciscospark/common":112,"@ciscospark/common-timers":41,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"lodash/clone":1611,"lodash/cloneDeep":1612,"lodash/isEmpty":1653,"lodash/isObject":1659,"querystring":1747,"url":1765}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OAuthError = undefined;

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _common = require('@ciscospark/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Error thrown during oauth flow
 */
var OAuthError = exports.OAuthError = function (_Exception) {
  (0, _inherits3.default)(OAuthError, _Exception);

  function OAuthError() {
    (0, _classCallCheck3.default)(this, OAuthError);
    return (0, _possibleConstructorReturn3.default)(this, (OAuthError.__proto__ || (0, _getPrototypeOf2.default)(OAuthError)).apply(this, arguments));
  }

  (0, _createClass3.default)(OAuthError, [{
    key: 'parse',

    /**
     * @param {HttpResponse} res
     * @returns {string}
     */
    value: function parse(res) {
      // This error may be returned in an HTTPResponse or as part of a querystring
      var body = res.body || res;

      (0, _defineProperties2.default)(this, {
        error: {
          enumerable: true,
          value: body.error
        },
        errorDescription: {
          enumerable: true,
          value: body.error_description
        },
        errorUri: {
          enumerable: true,
          value: body.error_uri
        },
        res: {
          enumerable: false,
          value: res
        }
      });

      return this.errorDescription;
    }
  }]);
  return OAuthError;
}(_common.Exception);
/**
 * InvalidRequestError
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/* eslint camelcase: [0] */

var InvalidRequestError = function (_OAuthError) {
  (0, _inherits3.default)(InvalidRequestError, _OAuthError);

  function InvalidRequestError() {
    (0, _classCallCheck3.default)(this, InvalidRequestError);
    return (0, _possibleConstructorReturn3.default)(this, (InvalidRequestError.__proto__ || (0, _getPrototypeOf2.default)(InvalidRequestError)).apply(this, arguments));
  }

  return InvalidRequestError;
}(OAuthError);

/**
 * InvalidClientError
 */


var InvalidClientError = function (_OAuthError2) {
  (0, _inherits3.default)(InvalidClientError, _OAuthError2);

  function InvalidClientError() {
    (0, _classCallCheck3.default)(this, InvalidClientError);
    return (0, _possibleConstructorReturn3.default)(this, (InvalidClientError.__proto__ || (0, _getPrototypeOf2.default)(InvalidClientError)).apply(this, arguments));
  }

  return InvalidClientError;
}(OAuthError);

/**
 * InvalidGrantError
 */


var InvalidGrantError = function (_OAuthError3) {
  (0, _inherits3.default)(InvalidGrantError, _OAuthError3);

  function InvalidGrantError() {
    (0, _classCallCheck3.default)(this, InvalidGrantError);
    return (0, _possibleConstructorReturn3.default)(this, (InvalidGrantError.__proto__ || (0, _getPrototypeOf2.default)(InvalidGrantError)).apply(this, arguments));
  }

  return InvalidGrantError;
}(OAuthError);

/**
 * UnauthorizedClientError
 */


var UnauthorizedClientError = function (_OAuthError4) {
  (0, _inherits3.default)(UnauthorizedClientError, _OAuthError4);

  function UnauthorizedClientError() {
    (0, _classCallCheck3.default)(this, UnauthorizedClientError);
    return (0, _possibleConstructorReturn3.default)(this, (UnauthorizedClientError.__proto__ || (0, _getPrototypeOf2.default)(UnauthorizedClientError)).apply(this, arguments));
  }

  return UnauthorizedClientError;
}(OAuthError);

/**
 * UnsupportGrantTypeError
 */


var UnsupportGrantTypeError = function (_OAuthError5) {
  (0, _inherits3.default)(UnsupportGrantTypeError, _OAuthError5);

  function UnsupportGrantTypeError() {
    (0, _classCallCheck3.default)(this, UnsupportGrantTypeError);
    return (0, _possibleConstructorReturn3.default)(this, (UnsupportGrantTypeError.__proto__ || (0, _getPrototypeOf2.default)(UnsupportGrantTypeError)).apply(this, arguments));
  }

  return UnsupportGrantTypeError;
}(OAuthError);

/**
 * InvalidScopeError
 */


var InvalidScopeError = function (_OAuthError6) {
  (0, _inherits3.default)(InvalidScopeError, _OAuthError6);

  function InvalidScopeError() {
    (0, _classCallCheck3.default)(this, InvalidScopeError);
    return (0, _possibleConstructorReturn3.default)(this, (InvalidScopeError.__proto__ || (0, _getPrototypeOf2.default)(InvalidScopeError)).apply(this, arguments));
  }

  return InvalidScopeError;
}(OAuthError);

var errors = {
  OAuthError: OAuthError,
  InvalidRequestError: InvalidRequestError,
  InvalidClientError: InvalidClientError,
  InvalidGrantError: InvalidGrantError,
  UnauthorizedClientError: UnauthorizedClientError,
  UnsupportGrantTypeError: UnsupportGrantTypeError,
  InvalidScopeError: InvalidScopeError,
  invalid_request: InvalidRequestError,
  invalid_client: InvalidClientError,
  invalid_grant: InvalidGrantError,
  unauthorized_client: UnauthorizedClientError,
  unsupported_grant_type: UnsupportGrantTypeError,
  invalid_scope: InvalidScopeError,
  select: function select(errorString) {
    return errors[errorString] || OAuthError;
  }
};

exports.default = errors;


},{"@ciscospark/common":112,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],147:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.grantErrors = exports.Token = exports.sortScope = exports.filterScope = exports.Credentials = undefined;

var _credentials = require('./credentials');

Object.defineProperty(exports, 'Credentials', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_credentials).default;
  }
});

var _scope = require('./scope');

Object.defineProperty(exports, 'filterScope', {
  enumerable: true,
  get: function get() {
    return _scope.filterScope;
  }
});
Object.defineProperty(exports, 'sortScope', {
  enumerable: true,
  get: function get() {
    return _scope.sortScope;
  }
});

var _token = require('./token');

Object.defineProperty(exports, 'Token', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_token).default;
  }
});

var _grantErrors = require('./grant-errors');

Object.defineProperty(exports, 'grantErrors', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_grantErrors).default;
  }
});

var _credentials2 = _interopRequireDefault(_credentials);

var _sparkCore = require('../../spark-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

(0, _sparkCore.registerPlugin)('credentials', _credentials2.default, {
  proxies: ['canAuthorize', 'canRefresh']
});


},{"../../spark-core":163,"./credentials":145,"./grant-errors":146,"./scope":148,"./token":150}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sortScope = sortScope;
exports.filterScope = filterScope;
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * sorts a list of scopes
 * @param {string} scope
 * @returns {string}
 */
function sortScope(scope) {
  if (!scope) {
    return '';
  }

  return scope.split(' ').sort().join(' ');
}

/**
 * sorts a list of scopes and filters the specified scope
 * @param {string} toFilter
 * @param {string} scope
 * @returns {string}
 */
function filterScope(toFilter, scope) {
  if (!scope) {
    return '';
  }

  return scope.split(' ').filter(function (item) {
    return item !== toFilter;
  }).sort().join(' ');
}


},{}],149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ampersandCollection = require('ampersand-collection');

var _ampersandCollection2 = _interopRequireDefault(_ampersandCollection);

var _token = require('./token');

var _token2 = _interopRequireDefault(_token);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var TokenCollection = _ampersandCollection2.default.extend({
  mainIndex: 'scope',

  model: _token2.default,

  namespace: 'Credentials'
});

exports.default = TokenCollection;


},{"./token":150,"ampersand-collection":165}],150:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _dec, _desc, _value, _obj; /*!
                                * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                */

var _common = require('@ciscospark/common');

var _commonTimers = require('@ciscospark/common-timers');

var _sparkHttpError = require('../spark-http-error');

var _sparkHttpError2 = _interopRequireDefault(_sparkHttpError);

var _sparkPlugin = require('../spark-plugin');

var _sparkPlugin2 = _interopRequireDefault(_sparkPlugin);

var _scope = require('./scope');

var _grantErrors = require('./grant-errors');

var _grantErrors2 = _interopRequireDefault(_grantErrors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/* eslint-disable camelcase */

/**
 * Parse response from CI and converts to structured error when appropriate
 * @param {SparkHttpError} res
 * @private
 * @returns {GrantError}
 */
function processGrantError(res) {
  if (res.statusCode !== 400) {
    return _promise2.default.reject(res);
  }

  var ErrorConstructor = _grantErrors2.default.select(res.body.error);
  if (ErrorConstructor === _grantErrors.OAuthError && res instanceof _sparkHttpError2.default) {
    return _promise2.default.reject(res);
  }
  if (!ErrorConstructor) {
    return _promise2.default.reject(res);
  }
  return _promise2.default.reject(new ErrorConstructor(res._res || res));
}

/**
 * @class
 */
var Token = _sparkPlugin2.default.extend((_dec = (0, _common.oneFlight)({
  keyFactory: function keyFactory(scope) {
    return scope;
  }
}), (_obj = {
  derived: {
    /**
     * Indicates if this token can be used in an auth header. `true` iff
     * {@link Token#access_token} is defined and {@link Token#isExpired} is
     * false.
     * @instance
     * @memberof Token
     * @readonly
     * @type {boolean}
     */
    canAuthorize: {
      deps: ['access_token', 'isExpired'],
      fn: function fn() {
        return !!this.access_token && !this.isExpired;
      }
    },

    /**
     * Indicates that this token can be downscoped. `true` iff
     * {@link config.credentials.client_id} is defined and if
     * {@link Token#canAuthorize} is true
     *
     * Note: since {@link config} is not evented, we can't listen for changes to
     * {@link config.credentials.client_id}. As such,
     * {@link config.credentials.client_id} must always be set before
     * instantiating a {@link Token}
     * @instance
     * @memberof Token
     * @readonly
     * @type {boolean}
     */
    canDownscope: {
      deps: ['canAuthorize'],
      fn: function fn() {
        return this.canAuthorize && !!this.config.client_id;
      }
    },

    /**
     * Indicates if this token can be refreshed. `true` iff
     * {@link Token@refresh_token} is defined and
     * {@link config.credentials.refreshCallback()} is defined
     *
     * Note: since {@link config} is not evented, we can't listen for changes to
     * {@link config.credentials.refreshCallback()}. As such,
     * {@link config.credentials.refreshCallback()} must always be set before
     * instantiating a {@link Token}
     * @instance
     * @memberof Token
     * @readonly
     * @type {boolean}
     */
    canRefresh: {
      deps: ['refresh_token'],
      fn: function fn() {
        if (_common.inBrowser) {
          return !!this.refresh_token && !!this.config.refreshCallback;
        }

        return !!this.refresh_token && !!this.config.client_secret;
      }
    },

    /**
     * Indicates if this `Token` is expired. `true` iff {@link Token#expires} is
     * defined and is less than {@link Date.now()}.
     * @instance
     * @memberof Token
     * @readonly
     * @type {boolean}
     */
    isExpired: {
      deps: ['expires', '_isExpired'],
      fn: function fn() {
        // in order to avoid setting `cache:false`, we'll use a private property
        // and a timer rather than comparing to `Date.now()`;
        return !!this.expires && this._isExpired;
      }
    },

    /**
     * Cache for toString()
     * @instance
     * @memberof Token
     * @private
     * @readonly
     * @type {string}
     */
    _string: {
      deps: ['access_token', 'token_type'],
      fn: function fn() {
        if (!this.access_token || !this.token_type) {
          return '';
        }
        return this.token_type + ' ' + this.access_token;
      }
    }
  },

  namespace: 'Credentials',

  props: {
    /**
     * Used for indexing in the credentials userTokens collection
     * @instance
     * @memberof Token
     * @private
     * @type {string}
     */
    scope: 'string',
    /**
     * @instance
     * @memberof Token
     * @type {string}
     */
    access_token: 'string',
    /**
     * @instance
     * @memberof Token
     * @type {number}
     */
    expires: 'number',
    /**
     * @instance
     * @memberof Token
     * @type {number}
     */
    expires_in: 'number',
    /**
     * @instance
     * @memberof Token
     * @type {string}
     */
    refresh_token: 'string',
    /**
     * @instance
     * @memberof Token
     * @type {number}
     */
    refresh_token_expires: 'number',
    /**
     * @instance
     * @memberof Token
     * @type {number}
     */
    refresh_token_expires_in: 'number',
    /**
     * @default "Bearer"
     * @instance
     * @memberof Token
     * @type {string}
     */
    token_type: {
      default: 'Bearer',
      type: 'string'
    }
  },

  session: {
    /**
     * Used by {@link Token#isExpired} to avoid doing a Date comparison.
     * @instance
     * @memberof Token
     * @private
     * @type {boolean}
     */
    _isExpired: {
      default: false,
      type: 'boolean'
    },
    /**
     * Handle to the previous token that we'll revoke when we refresh this
     * token. The idea is to keep allow two valid tokens when a refresh occurs;
     * we don't want revoke a token that's in the middle of being used, so when
     * we do a token refresh, we won't revoke the token being refreshed, but
     * we'll revoke the previous one.
     * @instance
     * @memberof Token
     * @private
     * @type {Object}
     */
    previousToken: {
      type: 'state'
    }
  },

  /**
   * Uses this token to request a new Token with a subset of this Token's scopes
   * @instance
   * @memberof Token
   * @param {string} scope
   * @returns {Promise<Token>}
   */
  downscope: function downscope(scope) {
    var _this = this;

    this.logger.info('token: downscoping token to ' + scope);

    if (this.isExpired) {
      this.logger.info('token: request received to downscope expired access_token');
      return _promise2.default.reject(new Error('cannot downscope expired access token'));
    }

    if (!this.canDownscope) {
      if (this.config.client_id) {
        this.logger.info('token: request received to downscope invalid access_token');
      } else {
        this.logger.warn('token: cannot downscope without client_id');
      }
      return _promise2.default.reject(new Error('cannot downscope access token'));
    }

    // Since we're going to use scope as the index in our token collection, it's
    // important scopes are always deterministically specified.
    if (scope) {
      scope = (0, _scope.sortScope)(scope);
    }

    // Ideally, we could depend on the service to communicate this error, but
    // all we get is "invalid scope", which, to the lay person, implies
    // something wrong with *one* of the scopes, not the whole thing.
    if (scope === (0, _scope.sortScope)(this.config.scope)) {
      return _promise2.default.reject(new Error('token: scope reduction requires a reduced scope'));
    }

    return this.spark.request({
      method: 'POST',
      uri: this.config.tokenUrl,
      form: {
        grant_type: 'urn:cisco:oauth:grant-type:scope-reduction',
        token: this.access_token,
        scope: scope,
        client_id: this.config.client_id
      }
    }).then(function (res) {
      _this.logger.info('token: downscoped token to ' + scope);
      return new Token((0, _assign2.default)(res.body, { scope: scope }), { parent: _this.parent });
    });
  },


  /**
   * Initializer
   * @instance
   * @memberof Token
   * @param {Object} [attrs={}]
   * @param {Object} [options={}]
   * @see {@link SparkPlugin#initialize()}
   * @returns {Token}
   */
  initialize: function initialize() {
    var _this2 = this;

    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    (0, _apply2.default)(_sparkPlugin2.default.prototype.initialize, this, [attrs, options]);

    if (typeof attrs === 'string') {
      this.access_token = attrs;
    }

    if (!this.access_token) {
      throw new Error('`access_token` is required');
    }

    // We don't want the derived property `isExpired` to need {cache:false}, so
    // we'll set up a timer the runs when this token should expire.
    if (this.expires) {
      if (this.expires < Date.now()) {
        this._isExpired = true;
      } else {
        (0, _commonTimers.safeSetTimeout)(function () {
          _this2._isExpired = true;
        }, this.expires - Date.now());
      }
    }
  },

  /**
   * Refreshes this Token. Relies on
   * {@link config.credentials.refreshCallback()}
   * @instance
   * @memberof Token
   * @returns {Promise<Token>}
   */
  refresh: function refresh() {
    var _this3 = this;

    if (!this.canRefresh) {
      throw new Error('Not enough information available to refresh this access token');
    }

    var promise = void 0;

    if (_common.inBrowser) {
      if (!this.config.refreshCallback) {
        throw new Error('Cannot refresh access token without refreshCallback');
      }

      promise = _promise2.default.resolve(this.config.refreshCallback(this.spark, this));
    }

    return (promise || this.spark.request({
      method: 'POST',
      uri: this.config.tokenUrl,
      form: {
        grant_type: 'refresh_token',
        redirect_uri: this.config.redirect_uri,
        refresh_token: this.refresh_token
      },
      auth: {
        user: this.config.client_id,
        pass: this.config.client_secret,
        sendImmediately: true
      },
      shouldRefreshAccessToken: false
    }).then(function (res) {
      return res.body;
    })).then(function (obj) {
      if (!obj) {
        throw new Error('token: refreshCallback() did not produce an object');
      }
      // If the authentication server did not send back a refresh token, copy
      // the current refresh token and related values to the response (note:
      // at time of implementation, CI never sends a new refresh token)
      if (!obj.refresh_token) {
        (0, _assign2.default)(obj, (0, _pick3.default)(_this3, 'refresh_token', 'refresh_token_expires', 'refresh_token_expires_in'));
      }

      // If the new token is the same as the previous token, then we may have
      // found a bug in CI; log the details and reject the Promise
      if (_this3.access_token === obj.access_token) {
        _this3.logger.error('token: new token matches current token');
        // log the tokens if it is not production
        if (process.env.NODE_ENV !== 'production') {
          _this3.logger.error('token: current token:', _this3.access_token);
          _this3.logger.error('token: new token:', obj.access_token);
        }
        return _promise2.default.reject(new Error('new token matches current token'));
      }

      if (_this3.previousToken) {
        _this3.previousToken.revoke();
        _this3.unset('previousToken');
      }

      obj.previousToken = _this3;
      obj.scope = _this3.scope;

      return new Token(obj, { parent: _this3.parent });
    }).catch(processGrantError);
  },

  /**
   * Revokes this token and unsets its local properties
   * @instance
   * @memberof Token
   * @returns {Promise}
   */
  revoke: function revoke() {
    var _this4 = this;

    if (this.isExpired) {
      this.logger.info('token: already expired, not making making revocation request');
      return _promise2.default.resolve();
    }

    if (!this.canAuthorize) {
      this.logger.info('token: no longer valid, not making revocation request');
      return _promise2.default.resolve();
    }

    // FIXME we need to use the user token revocation endpoint to revoke a token
    // without a client_secret, but it doesn't current support using a token to
    // revoke itself
    // Note: I'm not making a canRevoke property because there should be changes
    // coming to the user token revocation endpoint that allow us to do this
    // correctly.
    if (!this.config.client_secret) {
      this.logger.info('token: no client secret available, not making revocation request');
      return _promise2.default.resolve();
    }

    this.logger.info('token: revoking access token');
    return this.spark.request({
      method: 'POST',
      uri: this.config.revokeUrl,
      form: {
        token: this.access_token,
        token_type_hint: 'access_token'
      },
      auth: {
        user: this.config.client_id,
        pass: this.config.client_secret,
        sendImmediately: true
      },
      shouldRefreshAccessToken: false
    }).then(function () {
      _this4.unset(['access_token', 'expires', 'expires_in', 'token_type']);
      _this4.logger.info('token: access token revoked');
    }).catch(processGrantError);
  },
  set: function set() {
    // eslint-disable-next-line prefer-const
    var _filterSetParameters = this._filterSetParameters.apply(this, arguments),
        _filterSetParameters2 = (0, _slicedToArray3.default)(_filterSetParameters, 2),
        attrs = _filterSetParameters2[0],
        options = _filterSetParameters2[1];

    if (!attrs.token_type && attrs.access_token && attrs.access_token.includes(' ')) {
      var _attrs$access_token$s = attrs.access_token.split(' '),
          _attrs$access_token$s2 = (0, _slicedToArray3.default)(_attrs$access_token$s, 2),
          token_type = _attrs$access_token$s2[0],
          access_token = _attrs$access_token$s2[1];

      attrs = (0, _assign2.default)({}, attrs, { access_token: access_token, token_type: token_type });
    }
    var now = Date.now();

    if (!attrs.expires && attrs.expires_in) {
      attrs.expires = now + attrs.expires_in * 1000;
    }

    if (!attrs.refresh_token_expires && attrs.refresh_token_expires_in) {
      attrs.refresh_token_expires = now + attrs.refresh_token_expires_in * 1000;
    }

    if (attrs.scope) {
      attrs.scope = (0, _scope.sortScope)(attrs.scope);
    }

    return (0, _apply2.default)(_sparkPlugin2.default.prototype.set, this, [attrs, options]);
  },


  /**
   * Renders the token object as an HTTP Header Value
   * @instance
   * @memberof Token
   * @returns {string}
   * @see {@link Object#toString()}
   */
  toString: function toString() {
    if (!this._string) {
      throw new Error('cannot stringify Token');
    }

    return this._string;
  },


  /**
   * Uses a non-producation api to return information about this token. This
   * method is primarily for tests and will throw if NODE_ENV === production
   * @instance
   * @memberof Token
   * @private
   * @returns {Promise}
   */
  validate: function validate() {
    var _this5 = this;

    if (process.env.NODE_ENV === 'production') {
      throw new Error('Token#validate() must not be used in production');
    }

    return this.spark.request({
      method: 'POST',
      service: 'conversation',
      resource: 'users/validateAuthToken',
      body: {
        token: this.access_token
      }
    }).catch(function (reason) {
      if ('statusCode' in reason) {
        return _promise2.default.reject(reason);
      }
      _this5.logger.info('REMINDER: If you\'re investigating a network error here, it\'s normal');

      // If we got an error that isn't a SparkHttpError, assume the problem is
      // that we don't have the wdm plugin loaded and service/resource isn't
      // a valid means of identifying a request.
      var convApi = process.env.CONVERSATION_SERVICE || process.env.CONVERSATION_SERVICE_URL || 'https://conv-a.wbx2.com/conversation/api/v1';
      return _this5.spark.request({
        method: 'POST',
        uri: convApi + '/users/validateAuthToken',
        body: {
          token: _this5.access_token
        },
        headers: {
          authorization: 'Bearer ' + _this5.access_token
        }
      });
    }).then(function (res) {
      return res.body;
    });
  },
  version: '1.32.5'
}, (_applyDecoratedDescriptor(_obj, 'downscope', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'downscope'), _obj), _applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj), _applyDecoratedDescriptor(_obj, 'revoke', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'revoke'), _obj)), _obj)));

exports.default = Token;


}).call(this,require('_process'))
},{"../spark-http-error":153,"../spark-plugin":155,"./grant-errors":146,"./scope":148,"@ciscospark/common":112,"@ciscospark/common-timers":41,"_process":1743,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/slicedToArray":709,"lodash/pick":1685}],151:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _iterator = require('babel-runtime/core-js/symbol/iterator');

var _iterator2 = _interopRequireDefault(_iterator);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var itemsMap = new _weakMap2.default();
var linksMap = new _weakMap2.default();
var sparksMap = new _weakMap2.default();

/**
 * @class Page
 */

var Page = function () {
  (0, _createClass3.default)(Page, [{
    key: 'items',

    /**
     * @type {Array}
     */
    get: function get() {
      return itemsMap.get(this);
    }

    /**
     * @type {number}
     */

  }, {
    key: 'length',
    get: function get() {
      return this.items.length;
    }

    /**
     * @private
     * @type {Object}
     */

  }, {
    key: 'links',
    get: function get() {
      return linksMap.get(this);
    }

    /**
     * @private
     * @type {ProxySpark}
     */

  }, {
    key: 'spark',
    get: function get() {
      return sparksMap.get(this);
    }

    /**
     * @constructs {Page}
     * @param {HttpResponse} res
     * @param {ProxySpark} spark
     * @returns {Page}
     */

  }]);

  function Page(res, spark) {
    (0, _classCallCheck3.default)(this, Page);

    itemsMap.set(this, res.body.items);
    linksMap.set(this, Page.parseLinkHeaders(res.headers.link));
    sparksMap.set(this, spark);

    return this;
  }

  /**
   * Separate a single link header string into an actionable object
   * @param {string} linkHeaders
   * @private
   * @returns {Object}
   */


  (0, _createClass3.default)(Page, [{
    key: 'next',


    /**
     * Get next page
     * @returns {Function}
     */
    value: function next() {
      return this.getLink('next');
    }

    /**
     * Indicates if there's another page
     * @returns {Boolean}
     */

  }, {
    key: 'hasNext',
    value: function hasNext() {
      return this.hasLink('next');
    }

    /**
     * Get previous page
     * @returns {Page}
     */

  }, {
    key: 'previous',
    value: function previous() {
      return this.getLink('previous');
    }

    /**
     * Indicates if there is a previous Page
     * @returns {Boolean}
     */

  }, {
    key: 'hasPrevious',
    value: function hasPrevious() {
      return this.hasLink('previous');
    }

    /**
     * Retrieves the `Page` at url specified by `link`
     * @param {string} link Specifies which link header to return
     * @private
     * @returns {Promise<Page>}
     */

  }, {
    key: 'getLink',
    value: function getLink(link) {
      var _this = this;

      return this.spark.request({
        uri: this.links[link]
      }).then(function (res) {
        return new Page(res, _this.spark);
      });
    }

    /**
     * Indicates if the specified link is in the link header
     * @param {string} link
     * @private
     * @returns {Boolean}
     */

  }, {
    key: 'hasLink',
    value: function hasLink(link) {
      return Boolean(this.links[link]);
    }

    /**
     * Iterator
     * @returns {Object}
     */

  }, {
    key: _iterator2.default,
    value: function value() {
      var _this2 = this;

      var i = -1;
      return {
        next: function next() {
          i += 1;
          if (i < _this2.length) {
            return {
              value: _this2.items[i]
            };
          }

          return { done: true };
        }
      };
    }
  }], [{
    key: 'parseLinkHeaders',
    value: function parseLinkHeaders(linkHeaders) {
      if (!linkHeaders) {
        return {};
      }

      linkHeaders = Array.isArray(linkHeaders) ? linkHeaders : [linkHeaders];
      return linkHeaders.reduce(function (links, linkHeader) {
        linkHeader = linkHeader.split(';');
        var link = linkHeader[0].replace('<', '').replace('>', '');
        var rel = linkHeader[1].split('=')[1].replace(/"/g, '');
        links[rel] = link;
        return links;
      }, {});
    }
  }]);
  return Page;
}();

exports.default = Page;


},{"babel-runtime/core-js/symbol/iterator":702,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705}],152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty = require('babel-runtime/core-js/reflect/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _union2 = require('lodash/union');

var _union3 = _interopRequireDefault(_union2);

var _merge2 = require('lodash/merge');

var _merge3 = _interopRequireDefault(_merge2);

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

exports.default = mixinSparkCorePlugins;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Mixes a plugin system into an AmpState object (specifically, into SparkCore)
 * @param {AmpState} State
 * @param {Object} config
 * @param {Object} interceptors
 * @returns {AmpState}
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

function mixinSparkCorePlugins(State, config, interceptors) {
  // eslint-disable-next-line complexity
  State.registerPlugin = function registerPlugin(name, constructor) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (State.prototype._children[name] && !options.replace) {
      return;
    }

    State.prototype._children[name] = constructor;

    if (options.proxies) {
      options.proxies.forEach(function (key) {
        createDerivedProperty(State.prototype, key, {
          deps: [name + '.' + key],
          fn: function fn() {
            return this[name][key];
          }
        });
      });
    }

    if (options.interceptors) {
      (0, _keys2.default)(options.interceptors).forEach(function (key) {
        interceptors[key] = options.interceptors[key];
      });
    }

    if (options.config) {
      (0, _merge3.default)(config, options.config);
    }

    if ((0, _has3.default)(options, 'payloadTransformer.predicates')) {
      config.payloadTransformer.predicates = config.payloadTransformer.predicates.concat((0, _get3.default)(options, 'payloadTransformer.predicates'));
    }

    if ((0, _has3.default)(options, 'payloadTransformer.transforms')) {
      config.payloadTransformer.transforms = config.payloadTransformer.transforms.concat((0, _get3.default)(options, 'payloadTransformer.transforms'));
    }

    if (options.onBeforeLogout) {
      config.onBeforeLogout = config.onBeforeLogout || [];
      var onBeforeLogout = (0, _isArray3.default)(options.onBeforeLogout) ? options.onBeforeLogout : [options.onBeforeLogout];
      onBeforeLogout.forEach(function (fn) {
        return config.onBeforeLogout.push({
          plugin: name,
          fn: fn
        });
      });
    }

    if (constructor.prototype._definition.ready) {
      var _State$prototype$_der = State.prototype._derived.ready,
          fn = _State$prototype$_der.fn,
          depList = _State$prototype$_der.depList;

      var def = {
        deps: depList.concat(name + '.ready'),
        fn: fn
      };

      createDerivedProperty(State.prototype, 'ready', def);
    }
  };

  return State;
}

/**
 * Extracted from ampersand-state
 * @param {Object} modelProto
 * @param {string} name
 * @param {Object} definition
 * @private
 * @returns {undefined}
 */
function createDerivedProperty(modelProto, name, definition) {
  var def = modelProto._derived[name] = {
    fn: (0, _isFunction3.default)(definition) ? definition : definition.fn,
    cache: definition.cache !== false,
    depList: definition.deps || []
  };

  // add to our shared dependency list
  def.depList.forEach(function (dep) {
    modelProto._deps[dep] = (0, _union3.default)(modelProto._deps[dep] || [], [name]);
  });

  // defined a top-level getter for derived names
  (0, _defineProperty2.default)(modelProto, name, {
    get: function get() {
      return this._getDerivedProperty(name);
    },
    set: function set() {
      throw new TypeError('`' + name + '` is a derived property, it can\'t be set directly.');
    }
  });
}


},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _defineProperty = require('babel-runtime/core-js/reflect/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Spark-specific http error class
 */
var SparkHttpError = function (_HttpError) {
  (0, _inherits3.default)(SparkHttpError, _HttpError);

  function SparkHttpError() {
    (0, _classCallCheck3.default)(this, SparkHttpError);
    return (0, _possibleConstructorReturn3.default)(this, (SparkHttpError.__proto__ || (0, _getPrototypeOf2.default)(SparkHttpError)).apply(this, arguments));
  }

  (0, _createClass3.default)(SparkHttpError, [{
    key: 'parse',

    /**
     * Very similar to {@link HttpError#parse()}, but additionally adds some
     * useful headers to the message string
     * @param {HttpResponse} res
     * @returns {string}
     */
    value: function parse(res) {
      var message = (0, _apply2.default)(_httpCore.HttpError.prototype.parse, this, [res]);

      (0, _defineProperty2.default)(this, 'options', {
        enumerable: false,
        value: res.options
      });

      if (this.options.url) {
        message += '\n' + this.options.method + ' ' + this.options.url;
      } else if (this.options.uri) {
        message += '\n' + this.options.method + ' ' + this.options.uri;
      } else {
        message += '\n' + this.options.method + ' ' + this.options.service.toUpperCase() + '/' + this.options.resource;
      }
      message += '\nWEBEX_TRACKING_ID: ' + this.options.headers.trackingid;
      if (this.options.headers && this.options.headers['x-trans-id']) {
        message += '\nX-Trans-Id: ' + this.options.headers['x-trans-id'];
      }
      if (this.headers['retry-after']) {
        (0, _defineProperty2.default)(this, 'retryAfter', {
          enumerable: true,
          value: this.headers['retry-after'],
          writeable: false
        });

        message += '\nRETRY-AFTER: ' + this.retryAfter;
      }
      message += '\n';

      return message;
    }
  }]);
  return SparkHttpError;
}(_httpCore.HttpError); /*!
                         * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                         */

exports.default = SparkHttpError;


_httpCore.HttpError.makeSubTypes(SparkHttpError);

/**
 * TooManyRequests
 */

var TooManyRequests = function (_HttpError$BadRequest) {
  (0, _inherits3.default)(TooManyRequests, _HttpError$BadRequest);

  function TooManyRequests() {
    (0, _classCallCheck3.default)(this, TooManyRequests);
    return (0, _possibleConstructorReturn3.default)(this, (TooManyRequests.__proto__ || (0, _getPrototypeOf2.default)(TooManyRequests)).apply(this, arguments));
  }

  return TooManyRequests;
}(_httpCore.HttpError.BadRequest);

_httpCore.HttpError[429] = TooManyRequests;
_httpCore.HttpError.TooManyRequests = TooManyRequests;


},{"@ciscospark/http-core":123,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],154:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty = require('babel-runtime/core-js/reflect/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _union2 = require('lodash/union');

var _union3 = _interopRequireDefault(_union2);

var _merge2 = require('lodash/merge');

var _merge3 = _interopRequireDefault(_merge2);

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

exports.default = mixinSparkInternalCorePlugins;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Mixes a plugin system into an AmpState object (specifically, into SparkCore)
 * @param {AmpState} State
 * @param {Object} config
 * @param {Object} interceptors
 * @returns {AmpState}
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

function mixinSparkInternalCorePlugins(State, config, interceptors) {
  // eslint-disable-next-line complexity
  State.registerPlugin = function registerPlugin(name, constructor) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (State.prototype._children[name] && !options.replace) {
      return;
    }

    State.prototype._children[name] = constructor;

    if (options.proxies) {
      throw new Error('Proxies are not currently supported for private plugins');
    }

    if (options.interceptors) {
      (0, _keys2.default)(options.interceptors).forEach(function (key) {
        interceptors[key] = options.interceptors[key];
      });
    }

    if (options.config) {
      (0, _merge3.default)(config, options.config);
    }

    if ((0, _has3.default)(options, 'payloadTransformer.predicates')) {
      config.payloadTransformer.predicates = config.payloadTransformer.predicates.concat((0, _get3.default)(options, 'payloadTransformer.predicates'));
    }

    if ((0, _has3.default)(options, 'payloadTransformer.transforms')) {
      config.payloadTransformer.transforms = config.payloadTransformer.transforms.concat((0, _get3.default)(options, 'payloadTransformer.transforms'));
    }

    if (options.onBeforeLogout) {
      config.onBeforeLogout = config.onBeforeLogout || [];
      var onBeforeLogout = (0, _isArray3.default)(options.onBeforeLogout) ? options.onBeforeLogout : [options.onBeforeLogout];
      onBeforeLogout.forEach(function (fn) {
        return config.onBeforeLogout.push({
          plugin: name,
          fn: fn
        });
      });
    }

    if (constructor.prototype._definition.ready) {
      var _State$prototype$_der = State.prototype._derived.ready,
          fn = _State$prototype$_der.fn,
          depList = _State$prototype$_der.depList;

      var def = {
        deps: depList.concat(name + '.ready'),
        fn: fn
      };

      createDerivedProperty(State.prototype, 'ready', def);
    }
  };

  return State;
}

/**
 * Extracted from ampersand-state
 * @param {Object} modelProto
 * @param {string} name
 * @param {Object} definition
 * @private
 * @returns {undefined}
 */
function createDerivedProperty(modelProto, name, definition) {
  var def = modelProto._derived[name] = {
    fn: (0, _isFunction3.default)(definition) ? definition : definition.fn,
    cache: definition.cache !== false,
    depList: definition.deps || []
  };

  // add to our shared dependency list
  def.depList.forEach(function (dep) {
    modelProto._deps[dep] = (0, _union3.default)(modelProto._deps[dep] || [], [name]);
  });

  // defined a top-level getter for derived names
  (0, _defineProperty2.default)(modelProto, name, {
    get: function get() {
      return this._getDerivedProperty(name);
    },
    set: function set() {
      throw new TypeError('`' + name + '` is a derived property, it can\'t be set directly.');
    }
  });
}


},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _ampersandState = require('ampersand-state');

var _ampersandState2 = _interopRequireDefault(_ampersandState);

var _storage = require('./storage');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
var SparkPlugin = _ampersandState2.default.extend({
  derived: {
    boundedStorage: {
      deps: [],
      fn: function fn() {
        return (0, _storage.makeSparkPluginStore)('bounded', this);
      }
    },
    unboundedStorage: {
      deps: [],
      fn: function fn() {
        return (0, _storage.makeSparkPluginStore)('unbounded', this);
      }
    },
    config: {
      // figure out why caching config breaks the refresh integration test
      // but not the refresh automation test.
      cache: false,
      deps: ['spark', 'spark.config'],
      fn: function fn() {
        if (this.spark && this.spark.config) {
          var namespace = this.getNamespace();
          if (namespace) {
            return this.spark.config[namespace.toLowerCase()];
          }

          return this.spark.config;
        }

        return {};
      }
    },

    logger: {
      deps: ['spark', 'spark.logger'],
      fn: function fn() {
        return this.spark.logger || console;
      }
    },

    spark: {
      deps: ['parent'],
      fn: function fn() {
        if (!this.parent && !this.collection) {
          throw new Error('Cannot determine `this.spark` without `this.parent` or `this.collection`. Please initialize `this` via `children` or `collection` or set `this.parent` manually');
        }

        /* eslint consistent-this: [0] */
        var parent = this;
        while (parent.parent || parent.collection) {
          parent = parent.parent || parent.collection;
        }

        return parent;
      }
    }
  },

  session: {
    parent: {
      type: 'any'
    },
    /**
     * Indicates this plugin is ready to be used. Defaults to true but can be
     * overridden by plugins as appropriate. Used by {@link SparkCore#read}
     * @instance
     * @memberof SparkPlugin
     * @type {boolean}
     */
    ready: {
      default: true,
      type: 'boolean'
    }
  },

  /**
   * Overrides AmpersandState#clear to make sure we never unset `parent` and
   * recursively visits children/collections.
   * @instance
   * @memberof SparkPlugin
   * @param {Object} options
   * @returns {SparkPlugin}
   */
  clear: function clear(options) {
    var _this = this;

    (0, _keys2.default)(this.attributes).forEach(function (key) {
      if (key !== 'parent') {
        _this.unset(key, options);
      }
    });

    (0, _keys2.default)(this._children).forEach(function (key) {
      _this[key].clear();
    });

    (0, _keys2.default)(this._collections).forEach(function (key) {
      _this[key].reset();
    });

    return this;
  },


  /**
   * Initializer
   * @private
   * @param {Object} attrs
   * @param {Object} options
   * @returns {undefined}
   */
  initialize: function initialize() {
    var _this2 = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_ampersandState2.default.prototype.initialize, this, args);

    // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure
    // function.
    this._dataTypes = (0, _cloneDeep3.default)(this._dataTypes);
    (0, _keys2.default)(this._dataTypes).forEach(function (key) {
      if (_this2._dataTypes[key].set) {
        _this2._dataTypes[key].set = _this2._dataTypes[key].set.bind(_this2);
      }
    });
    // END HACK

    // Propagate change:[attribute] events from children
    this.on('change', function (model, options) {
      if (_this2.parent) {
        _this2.parent.trigger('change:' + _this2.getNamespace().toLowerCase(), _this2.parent, _this2, options);
      }
    });
  },


  /**
   * @instance
   * @memberof SparkPlugin
   * @param {number} depth
   * @private
   * @returns {Object}
   */
  inspect: function inspect(depth) {
    return _util2.default.inspect((0, _omit3.default)(this.serialize({
      props: true,
      session: true,
      derived: true
    }), 'boundedStorage', 'unboundedStorage', 'config', 'logger', 'spark', 'parent'), { depth: depth });
  },
  request: function request() {
    var _spark;

    return (_spark = this.spark).request.apply(_spark, arguments);
  },
  upload: function upload() {
    var _spark2;

    return (_spark2 = this.spark).upload.apply(_spark2, arguments);
  },
  when: function when(eventName) {
    var _this3 = this;

    for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      rest[_key2 - 1] = arguments[_key2];
    }

    if (rest && rest.length > 0) {
      throw new Error('#when() does not accept a callback, you must attach to its promise');
    }
    return new _promise2.default(function (resolve) {
      _this3.once(eventName, function () {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return resolve(args);
      });
    });
  },


  /**
   * Helper function for dealing with both forms of {@link AmpersandState#set()}
   * @param {string} key
   * @param {mixed} value
   * @param {Object} options
   * @private
   * @returns {Array<Object, Object>}
   */
  _filterSetParameters: function _filterSetParameters(key, value, options) {
    var attrs = void 0;
    if ((0, _isObject3.default)(key) || key === null) {
      attrs = key;
      options = value;
    } else {
      attrs = {};
      attrs[key] = value;
    }

    options = options || {};

    return [attrs, options];
  }
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = SparkPlugin;


},{"./storage":158,"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"lodash/cloneDeep":1612,"lodash/isObject":1659,"lodash/omit":1679,"util":1769}],156:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _wrap2 = require('lodash/wrap');

var _wrap3 = _interopRequireDefault(_wrap2);

var _result2 = require('lodash/result');

var _result3 = _interopRequireDefault(_result2);

var _identity2 = require('lodash/identity');

var _identity3 = _interopRequireDefault(_identity2);

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _curry2 = require('lodash/curry');

var _curry3 = _interopRequireDefault(_curry2);

exports.persist = persist;
exports.waitForValue = waitForValue;

var _errors = require('./errors');

var _common = require('@ciscospark/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Stores the result of fn before returning it
 * @param  {string} key
 * @private
 * @returns {Promise} resolves with the result of fn
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/* eslint no-invalid-this: [0] */

function persist() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length === 3) {
    return persist('@').apply(undefined, args);
  }

  var key = args[0],
      decider = args[1];


  return function persistDecorator(target, prop, descriptor) {
    if (prop !== 'initialize') {
      // Once we have class-based alternative to AmpersandState, it should be
      // detected here.
      throw new TypeError('@persist can only currently be applied to AmpersandState objects or their derivatives and must be applied to the initialize method');
    }

    descriptor.value = (0, _wrap3.default)(descriptor.value, function persistExecutor(fn) {
      var _this = this;

      for (var _len2 = arguments.length, initializeArgs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        initializeArgs[_key2 - 1] = arguments[_key2];
      }

      var ret = (0, _apply2.default)(fn, this, initializeArgs);
      var changeEvent = key === '@' ? 'change' : 'change:' + key;

      // Some scenarios will lead to lots of change events on a single tick; we
      // really only care about writing once things have stopped changing. with
      // a debounce of zero, we're effectively coalescing all the changes
      // triggered by a single call to set() and commiting them on the next tick
      // eslint-disable-next-line no-invalid-this
      this.on(changeEvent, (0, _debounce3.default)(function () {
        var shouldPersist = !decider || _apply2.default.apply(Reflect, [decider, _this].concat(initializeArgs));
        if (!shouldPersist) {
          return _promise2.default.resolve();
        }
        if (key === '@') {
          // eslint-disable-next-line no-invalid-this
          return _this.boundedStorage.put(key, _this);
        }

        // eslint-disable-next-line no-invalid-this
        return _this.boundedStorage.put(key, _this[key]);
      }, 0));
      return ret;
    });

    prepareInitialize(target, prop);
  };
}

var M = _map2.default;
var S = _set2.default;
var BlockingKeyMap = (0, _common.make)(M, M, S);
var blockingKeys = new BlockingKeyMap();

/**
 * Prevents fn from executing until key has been (attempted to be) loaded
 * @param {string} key
 * @param {Function} fn
 * @private
 * @returns {Promise} result of fn
 */
function waitForValue(key) {
  if (!key) {
    throw new Error('`key` is required');
  }

  return function waitForValueDecorator(target, prop, descriptor) {
    blockingKeys.add(target, prop, key);
    descriptor.value = (0, _wrap3.default)(descriptor.value, function waitForValueExecutor(fn) {
      var _this2 = this;

      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      var keys = blockingKeys.get(target, prop);
      return _promise2.default.all([].concat((0, _toConsumableArray3.default)(keys)).map(function (k) {
        return _this2.boundedStorage.waitFor(k);
      })).then(function () {
        return (0, _apply2.default)(fn, _this2, args);
      });
    });

    // This *should* make decorators compatible with AmpersandState class
    // definitions
    if ((typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) === 'object' && !target.prototype) {
      target[prop] = descriptor.value;
    }

    prepareInitialize(target, prop);

    return descriptor;
  };
}

var inited = new _set2.default();

/**
 * finds a means of identitying the `target` param passed to
 * `prepareInitialize()`. When possible, avoids duplicate `init()` calls if
 * namespaces collide
 *
 * @param {Object|Constructor} target
 * @private
 * @returns {String|Constructor}
 */
function identifyTarget(target) {
  if (target.namespace) {
    return target.namespace;
  }

  return target;
}

var stack = new _set2.default();

/**
 * @param {Function} target
 * @param {string} prop
 * @private
 * @returns {undefined}
 */
function prepareInitialize(target, prop) {
  var id = identifyTarget(target);
  if (!inited.has(id)) {
    inited.add(id);
    if (target.initialize) {
      target.initialize = (0, _wrap3.default)(target.initialize, function applyInit(fn) {
        for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        var ret = (0, _apply2.default)(fn, this, args);
        (0, _apply2.default)(init, this, args);
        return ret;
      });
      return;
    }

    target.initialize = init;
  }

  /**
   * @private
   * @returns {undefined}
   */
  function init() {
    var self = this;
    var namespace = this.getNamespace();
    this.spark.initialize = (0, _wrap3.default)(this.spark.initialize || _identity3.default, function applyInit(fn) {
      var _this3 = this;

      // Call spark's initalize method first
      // Reminder: in order for MockSpark to accept initial storage data, the
      // wrapped initialize() must be invoked before attempting to load data.
      // Reminder: context here is `spark`, not `self`.
      stack.add(namespace);

      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }

      (0, _apply2.default)(fn, this, args);

      // Then prepare a function for setting values retrieved from storage
      var set = (0, _curry3.default)(function (key, value) {
        _this3.logger.debug('storage:(' + namespace + '): got `' + key + '` for first time');
        if (key === '@') {
          self.parent.set((0, _defineProperty3.default)({}, namespace.toLowerCase(), value));
        } else if ((0, _result3.default)(self[key], 'isState')) {
          self[key].set(value);
        } else {
          self.set(key, value);
        }
        _this3.logger.debug('storage:(' + namespace + '): set `' + key + '` for first time');
      });

      // And prepare an error handler for when those keys can't be found
      var handle = (0, _curry3.default)(function (key, reason) {
        if (reason instanceof _errors.NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {
          _this3.logger.debug('storage(' + namespace + '): no data for `' + key + '`, continuing');
          return _promise2.default.resolve();
        }
        _this3.logger.error('storage(' + namespace + '): failed to init `' + key + '`', reason);
        return _promise2.default.reject(reason);
      });

      // Iterate over the list of keys marked as blocking via `@waitForValue`
      var keys = blockingKeys.get(target, prop);
      var promises = [];
      keys.forEach(function (key) {
        promises.push(_this3.boundedStorage.get(namespace, key).then(set(key)).catch(handle(key)));
      });

      _promise2.default.all(promises).then(function () {
        stack.delete(namespace);
        if (stack.size === 0) {
          _this3.loaded = true;
        }
      });
    });
  }
}


}).call(this,require('_process'))
},{"./errors":157,"@ciscospark/common":112,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/set":700,"babel-runtime/helpers/defineProperty":706,"babel-runtime/helpers/toConsumableArray":710,"babel-runtime/helpers/typeof":711,"lodash/curry":1615,"lodash/debounce":1617,"lodash/identity":1641,"lodash/result":1692,"lodash/wrap":1715}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotFoundError = exports.StorageError = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _common = require('@ciscospark/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * General storage layer error
 */
var StorageError = exports.StorageError = function (_Exception) {
  (0, _inherits3.default)(StorageError, _Exception);

  function StorageError() {
    (0, _classCallCheck3.default)(this, StorageError);
    return (0, _possibleConstructorReturn3.default)(this, (StorageError.__proto__ || (0, _getPrototypeOf2.default)(StorageError)).apply(this, arguments));
  }

  return StorageError;
}(_common.Exception);

/**
 * StorageError thrown when the storage layer does not contain the request key
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var NotFoundError = exports.NotFoundError = function (_StorageError) {
  (0, _inherits3.default)(NotFoundError, _StorageError);

  function NotFoundError() {
    (0, _classCallCheck3.default)(this, NotFoundError);
    return (0, _possibleConstructorReturn3.default)(this, (NotFoundError.__proto__ || (0, _getPrototypeOf2.default)(NotFoundError)).apply(this, arguments));
  }

  return NotFoundError;
}(StorageError);


},{"@ciscospark/common":112,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],158:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _decorators = require('./decorators');

Object.defineProperty(exports, 'persist', {
  enumerable: true,
  get: function get() {
    return _decorators.persist;
  }
});
Object.defineProperty(exports, 'waitForValue', {
  enumerable: true,
  get: function get() {
    return _decorators.waitForValue;
  }
});

var _makeSparkStore = require('./make-spark-store.js');

Object.defineProperty(exports, 'makeSparkStore', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_makeSparkStore).default;
  }
});

var _makeSparkPluginStore = require('./make-spark-plugin-store.js');

Object.defineProperty(exports, 'makeSparkPluginStore', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_makeSparkPluginStore).default;
  }
});

var _memoryStoreAdapter = require('./memory-store-adapter');

Object.defineProperty(exports, 'MemoryStoreAdapter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_memoryStoreAdapter).default;
  }
});

var _errors = require('./errors');

Object.defineProperty(exports, 'StorageError', {
  enumerable: true,
  get: function get() {
    return _errors.StorageError;
  }
});
Object.defineProperty(exports, 'NotFoundError', {
  enumerable: true,
  get: function get() {
    return _errors.NotFoundError;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


},{"./decorators":156,"./errors":157,"./make-spark-plugin-store.js":159,"./make-spark-store.js":160,"./memory-store-adapter":161}],159:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _result2 = require('lodash/result');

var _result3 = _interopRequireDefault(_result2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

exports.default = makeSparkPluginStorage;

var _common = require('@ciscospark/common');

var _errors = require('./errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
} /*!
   * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
   */

var defers = new _weakMap2.default();

/**
 * Walks an object before writing it to the store and omits empty arrays
 * @private
 * @param {Object} value
 * @returns {Object}
 */
function serialize(value) {
  if (!(0, _isObject3.default)(value)) {
    return value;
  }

  var serialized = value.serialize ? value.serialize() : value;

  (0, _keys2.default)(serialized).forEach(function (key) {
    var val = serialized[key];
    if ((0, _isArray3.default)(val)) {
      if (val.length === 0) {
        serialized[key] = undefined;
      } else {
        serialized[key] = val.map(serialize);
      }
    } else if ((0, _isObject3.default)(val)) {
      (0, _keys2.default)(val).forEach(function (k) {
        val[k] = serialize(val[k]);
      });
    }
  });

  var empty = (0, _keys2.default)(serialized).reduce(function (acc, key) {
    return acc && !serialized[key];
  }, true);

  if (empty) {
    return undefined;
  }
  return serialized;
}

/**
 * [makeSparkPluginStorage description]
 * @param {[type]} type
 * @param {[type]} context
 * @private
 * @returns {[type]}
 */
function makeSparkPluginStorage(type, context) {
  var _dec, _desc, _value, _class;

  /**
   * Interface between SparkPlugin and Spark#boundeStorage or
   * Spark#unboundedStorage
   */
  var SparkPluginStorage = (_dec = (0, _common.oneFlight)({ keyFactory: function keyFactory(key) {
      return 'initValue-' + key;
    } }), (_class = function () {
    /**
     * @param {Object} attrs
     * @param {Object} options
     * @returns {SparkPluginStorage}
     */
    function SparkPluginStorage() {
      (0, _classCallCheck3.default)(this, SparkPluginStorage);

      defers.set(this, new _map2.default());
    }

    /**
     * Clears an entire namespace
     * @returns {Promise}
     */


    (0, _createClass3.default)(SparkPluginStorage, [{
      key: 'clear',
      value: function clear() {
        return context.spark[type + 'Storage'].del(context.getNamespace());
      }

      /**
       * Deletes the specified key from the store
       * @param {string} key
       * @returns {[type]}
       */

    }, {
      key: 'del',
      value: function del() {
        var _context$spark$;

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (_context$spark$ = context.spark[type + 'Storage']).del.apply(_context$spark$, [context.getNamespace()].concat(args));
      }

      /**
       * Retrieves the value specified by key from the store. Rejects with
       * NotFoundError if no value can be found
       * @param {string} key
       * @returns {Promise}
       */

    }, {
      key: 'get',
      value: function get(key) {
        var defer = defers.get(this).get(key);
        if (!defer) {
          defer = new _common.Defer();
          defers.get(this).set(key, defer);
        }

        return context.spark[type + 'Storage'].get(context.getNamespace(), key).then(function (res) {
          defer.resolve();
          return res;
        });
      }

      /**
       * Writes a value to the store
       * @param {string} key
       * @param {any} value
       * @returns {Promise}
       */

    }, {
      key: 'put',
      value: function put(key, value) {
        return context.spark[type + 'Storage'].put(context.getNamespace(), key, serialize(value));
      }

      /**
       * Returns a Promise that won't resolve until the value specified by key has
       * been attempted to be loaded from the store. This allows us to lazily
       * prevent certain method from executing until the specified keys have been
       * retrieved from the store.
       * @param {string} key
       * @returns {Promise}
       */

    }, {
      key: 'waitFor',
      value: function waitFor(key) {
        context.logger.debug('plugin-storage(' + context.getNamespace() + '): waiting to init key `' + key + '`');
        var defer = defers.get(this).get(key);
        if (defer) {
          context.logger.debug('plugin-storage(' + context.getNamespace() + '): already inited `' + key + '`');
          return defer.promise;
        }

        context.logger.debug('plugin-storage(' + context.getNamespace() + '): initing `' + key + '`');
        return this.initValue(key);
      }
    }, {
      key: 'initValue',

      /**
       * Attempts to load the specified key from the store and set it on the parent
       * object.
       * @param {string} key
       * @returns {Promise} Resolves (but not with the retrieved value) when
       * the value retrieval complete
       */
      // suppress doc warning because decorators confuse eslint
      // eslint-disable-next-line require-jsdoc
      value: function initValue(key) {
        var defer = new _common.Defer();
        defers.get(this).set(key, defer);

        // Intentionally bypasses this.get so we don't resolve the promise until
        // after the parent value is set.
        context.spark[type + 'Storage'].get(context.getNamespace(), key).then(function (value) {
          context.logger.debug('plugin-storage(' + context.getNamespace() + '): got `' + key + '` for first time');
          if (key === '@') {
            context.parent.set(value);
          } else if ((0, _result3.default)(context[key], 'isState')) {
            context[key].set(value);
          } else {
            context.set(key, value);
          }
          context.logger.debug('plugin-storage(' + context.getNamespace() + '): set `' + key + '` for first time');
          defer.resolve();
          context.logger.debug('plugin-storage(' + context.getNamespace() + '): inited `' + key + '`');
        }).catch(function (reason) {
          // The  next conditional is a bit of an unfortunate solution to deal
          // with circular dependencies in unit tests. It should not effect
          // integration tests or production code.
          if (reason instanceof _errors.NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {
            context.logger.debug('plugin-storage(' + context.getNamespace() + '): no data for `' + key + '`, continuing');
            return defer.resolve();
          }
          context.logger.warn('plugin-storage(' + context.getNamespace() + '): failed to init `' + key + '`', reason);
          return defer.reject(reason);
        });

        return defer.promise;
      }
    }]);
    return SparkPluginStorage;
  }(), (_applyDecoratedDescriptor(_class.prototype, 'initValue', [_dec], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'initValue'), _class.prototype)), _class));


  return new SparkPluginStorage();
}


}).call(this,require('_process'))
},{"./errors":157,"@ciscospark/common":112,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"lodash/isArray":1648,"lodash/isObject":1659,"lodash/result":1692}],160:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

exports.default = makeSparkStore;

var _ampersandEvents = require('ampersand-events');

var _ampersandEvents2 = _interopRequireDefault(_ampersandEvents);

var _common = require('@ciscospark/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
} /*!
   * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
   */

var bindings = new _weakMap2.default();

/**
 * Makes a SparkStore for the specified type bound to the specified spark instance
 * @param {string} type
 * @param {ProxySpark} spark
 * @private
 * @returns {SparkStore}
 */
function makeSparkStore(type, spark) {
  var _dec, _desc, _value, _class;

  /**
   * Lazy Key-Value Store Interface
   */
  var SparkStore = (_dec = (0, _common.oneFlight)({ keyFactory: function keyFactory(namespace) {
      return namespace;
    } }), (_class = function () {
    /**
     * @param {Object} attrs
     * @param {Object} options
     * @returns {Store}
     */
    function SparkStore() {
      (0, _classCallCheck3.default)(this, SparkStore);

      spark.logger.debug('spark-store: constructing ' + type + 'Storage');
      bindings.set(this, new _map2.default());
    }

    /**
     * Provides easy access to the storage adapter identified in config.
     * @returns {Object}
     */


    (0, _createClass3.default)(SparkStore, [{
      key: 'clear',


      /**
       * Clears the store
       * @returns {Promise}
       */
      value: function clear() {
        var promises = [];
        this.bindings.forEach(function (binding) {
          promises.push(binding.clear());
        });

        return _promise2.default.all(promises);
      }

      /**
       * Deletes the specified key from the store
       * @param {string} namespace
       * @param {string} key
       * @returns {[type]}
       */

    }, {
      key: 'del',
      value: function del(namespace, key) {
        spark.logger.debug('spark-store: removing ' + namespace + ':' + key);
        return this._getBinding(namespace).then(function (binding) {
          return binding.del(key);
        });
      }

      /**
       * Retrieves the value specified by key from the store. Rejects with
       * NotFoundError if no value can be found
       * @param {string} namespace
       * @param {string} key
       * @returns {Promise}
       */

    }, {
      key: 'get',
      value: function get(namespace, key) {
        spark.logger.debug('spark-store: retrieving ' + namespace + ':' + key);
        return this._getBinding(namespace).then(function (binding) {
          return binding.get(key);
        });
      }

      /**
       * Writes a value to the store. Deletes the specified key from the store
       * if passed `undefined`
       * @param {string} namespace
       * @param {string} key
       * @param {any} value
       * @returns {Promise} Resolves with value (to simplify write-through caching)
       */

    }, {
      key: 'put',
      value: function put(namespace, key, value) {
        if (typeof value === 'undefined') {
          return this.del(namespace, key);
        }
        spark.logger.debug('spark-store: setting ' + namespace + ':' + key);
        return this._getBinding(namespace).then(function (binding) {
          return binding.put(key, value.serialize ? value.serialize() : value);
        }).then(function () {
          return value;
        });
      }
    }, {
      key: '_getBinding',

      /**
       * Creates an interface bound to the specified namespace
       * @param {string} namespace
       * @private
       * @returns {Promise}
       */
      // suppress doc warning because decorators confuse eslint
      // eslint-disable-next-line require-jsdoc
      value: function _getBinding(namespace) {
        var _this = this;

        return new _promise2.default(function (resolve) {
          spark.logger.debug('storage: getting binding for `' + namespace + '`');
          var binding = _this.bindings.get(namespace);
          if (binding) {
            spark.logger.debug('storage: found binding for `' + namespace + '`');
            return resolve(binding);
          }

          return resolve(_this.adapter.bind(namespace, { logger: spark.logger }).then(function (_binding) {
            spark.logger.debug('storage: made binding for `' + namespace + '`');
            _this.bindings.set(namespace, _binding);
            return _binding;
          }));
        });
      }
    }, {
      key: 'adapter',
      get: function get() {
        return spark.config.storage[type + 'Adapter'];
      }

      /**
       * @returns {WeakMap}
       */

    }, {
      key: 'bindings',
      get: function get() {
        return bindings.get(this);
      }
    }]);
    return SparkStore;
  }(), (_applyDecoratedDescriptor(_class.prototype, '_getBinding', [_dec], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_getBinding'), _class.prototype)), _class));


  (0, _assign2.default)(SparkStore.prototype, _ampersandEvents2.default);

  return new SparkStore();
}


},{"@ciscospark/common":112,"ampersand-events":673,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705}],161:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _errors = require('./errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Binds a namespace
 * @param {string} namespace
 * @param {Object} options
 * @param {Object} options.data
 * @private
 * @returns {Promise<Object>}
 */
function _bind(namespace) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  options = options || {};
  if (!namespace) {
    return _promise2.default.reject(new Error('`namespace` is required'));
  }

  if (!options.logger) {
    return _promise2.default.reject(new Error('`options.logger` is required'));
  }

  var logger = options.logger;

  var map = new _map2.default();
  if (options.data) {
    (0, _keys2.default)(options.data).forEach(function (key) {
      map.set(key, options.data[key]);
    });
  }

  logger.debug('memory-store-adapter: returning binding');
  return _promise2.default.resolve({
    clear: function clear() {
      logger.debug('memory-store-adapter: clearing the binding');
      return _promise2.default.resolve(map.clear());
    },
    del: function del(key) {
      logger.debug('memory-store-adapter: deleting `' + key + '`');
      return _promise2.default.resolve(map.delete(key));
    },
    get: function get(key) {
      logger.debug('memory-store-adapter: reading `' + key + '`');
      var res = map.get(key);
      if (typeof res === 'undefined') {
        return _promise2.default.reject(new _errors.NotFoundError());
      }

      return _promise2.default.resolve(res);
    },
    put: function put(key, value) {
      logger.debug('memory-store-adapter: writing `' + key + '`');
      return _promise2.default.resolve(map.set(key, value));
    }
  });
} /*!
   * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
   */

exports.default = {
  bind: _bind,
  preload: function preload(data) {
    return {
      bind: function bind(namespace) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (data[namespace]) {
          options.data = data[namespace];
        }

        return _bind(namespace, options);
      }
    };
  }
};


},{"./errors":157,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694}],162:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkPlugin = require('../lib/spark-plugin');

var _sparkPlugin2 = _interopRequireDefault(_sparkPlugin);

var _sparkCore = require('../spark-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var precedence = {
  error: ['log'],
  warn: ['error', 'log'],
  info: ['log'],
  debug: ['info', 'log'],
  trace: ['debug', 'info', 'log']
};

/**
 * Assigns the specified console method to Logger; uses `precedence` to fallback
 * to other console methods if the current environment doesn't provide the
 * specified level.
 * @param {string} level
 * @returns {Function}
 */
function wrapConsoleMethod(level) {
  /* eslint no-console: [0] */
  var impls = precedence[level];
  if (impls) {
    impls = impls.slice();
    while (!console[level]) {
      level = impls.pop();
    }
  }

  return function wrappedConsoleMethod() {
    var _console;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /* eslint no-invalid-this: [0] */
    /* istanbul ignore if */
    if (process.env.NODE_ENV === 'test' && this.spark && this.spark.internal.device && this.spark.internal.device.url) {
      args.unshift(this.spark.internal.device.url.slice(-3));
    }
    (_console = console)[level].apply(_console, args);
  };
}

var Logger = _sparkPlugin2.default.extend({
  namespace: 'Logger',
  error: wrapConsoleMethod('error'),
  warn: wrapConsoleMethod('warn'),
  log: wrapConsoleMethod('log'),
  info: wrapConsoleMethod('info'),
  debug: wrapConsoleMethod('debug'),
  trace: wrapConsoleMethod('trace'),
  version: '1.32.5'
});

(0, _sparkCore.registerPlugin)('logger', Logger);

exports.default = Logger;


}).call(this,require('_process'))
},{"../lib/spark-plugin":155,"../spark-core":163,"_process":1743}],163:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _unset2 = require('lodash/unset');

var _unset3 = _interopRequireDefault(_unset2);

var _set2 = require('lodash/set');

var _set3 = _interopRequireDefault(_set2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _merge2 = require('lodash/merge');

var _merge3 = _interopRequireDefault(_merge2);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _desc, _value, _obj; /*!
                          * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                          */

exports.registerPlugin = registerPlugin;
exports.registerInternalPlugin = registerInternalPlugin;

var _common = require('@ciscospark/common');

var _httpCore = require('@ciscospark/http-core');

var _ampersandState = require('ampersand-state');

var _ampersandState2 = _interopRequireDefault(_ampersandState);

var _auth = require('./interceptors/auth');

var _auth2 = _interopRequireDefault(_auth);

var _networkTiming = require('./interceptors/network-timing');

var _networkTiming2 = _interopRequireDefault(_networkTiming);

var _payloadTransformer = require('./interceptors/payload-transformer');

var _payloadTransformer2 = _interopRequireDefault(_payloadTransformer);

var _redirect = require('./interceptors/redirect');

var _redirect2 = _interopRequireDefault(_redirect);

var _requestEvent = require('./interceptors/request-event');

var _requestEvent2 = _interopRequireDefault(_requestEvent);

var _requestLogger = require('./interceptors/request-logger');

var _requestLogger2 = _interopRequireDefault(_requestLogger);

var _requestTiming = require('./interceptors/request-timing');

var _requestTiming2 = _interopRequireDefault(_requestTiming);

var _responseLogger = require('./interceptors/response-logger');

var _responseLogger2 = _interopRequireDefault(_responseLogger);

var _sparkHttpError = require('./lib/spark-http-error');

var _sparkHttpError2 = _interopRequireDefault(_sparkHttpError);

var _sparkTrackingId = require('./interceptors/spark-tracking-id');

var _sparkTrackingId2 = _interopRequireDefault(_sparkTrackingId);

var _sparkUserAgent = require('./interceptors/spark-user-agent');

var _sparkUserAgent2 = _interopRequireDefault(_sparkUserAgent);

var _rateLimit = require('./interceptors/rate-limit');

var _rateLimit2 = _interopRequireDefault(_rateLimit);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _storage = require('./lib/storage');

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _events = require('events');

var _sparkCorePluginMixin = require('./lib/spark-core-plugin-mixin');

var _sparkCorePluginMixin2 = _interopRequireDefault(_sparkCorePluginMixin);

var _sparkInternalCorePluginMixin = require('./lib/spark-internal-core-plugin-mixin');

var _sparkInternalCorePluginMixin2 = _interopRequireDefault(_sparkInternalCorePluginMixin);

var _sparkInternalCore = require('./spark-internal-core');

var _sparkInternalCore2 = _interopRequireDefault(_sparkInternalCore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

// TODO replace the Interceptor.create with Reflect.construct (
// Interceptor.create exists because new was really hard to call on an array of
// constructors)
var interceptors = {
  SparkTrackingIdInterceptor: _sparkTrackingId2.default.create,
  RequestEventInterceptor: _requestEvent2.default.create,
  RateLimitInterceptor: _rateLimit2.default.create,
  /* eslint-disable no-extra-parens */
  RequestLoggerInterceptor: process.env.ENABLE_NETWORK_LOGGING || process.env.ENABLE_VERBOSE_NETWORK_LOGGING ? _requestLogger2.default.create : undefined,
  ResponseLoggerInterceptor: process.env.ENABLE_NETWORK_LOGGING || process.env.ENABLE_VERBOSE_NETWORK_LOGGING ? _responseLogger2.default.create : undefined,
  /* eslint-enable no-extra-parens */
  RequestTimingInterceptor: _requestTiming2.default.create,
  UrlInterceptor: undefined,
  SparkUserAgentInterceptor: _sparkUserAgent2.default.create,
  AuthInterceptor: _auth2.default.create,
  KmsDryErrorInterceptor: undefined,
  PayloadTransformerInterceptor: _payloadTransformer2.default.create,
  ConversationInterceptor: undefined,
  RedirectInterceptor: _redirect2.default.create,
  HttpStatusInterceptor: function HttpStatusInterceptor() {
    return _httpCore.HttpStatusInterceptor.create({
      error: _sparkHttpError2.default
    });
  },

  NetworkTimingInterceptor: _networkTiming2.default.create
};

var preInterceptors = ['ResponseLoggerInterceptor', 'RequestTimingInterceptor', 'RequestEventInterceptor', 'SparkTrackingIdInterceptor', 'RateLimitInterceptor'];

var postInterceptors = ['HttpStatusInterceptor', 'NetworkTimingInterceptor', 'RequestLoggerInterceptor', 'RateLimitInterceptor'];

/**
 * @class
 */
var SparkCore = _ampersandState2.default.extend((_obj = {
  version: '1.32.5',

  children: {
    internal: _sparkInternalCore2.default
  },

  constructor: function constructor() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments[1];

    if (typeof attrs === 'string') {
      attrs = {
        credentials: {
          supertoken: {
            // eslint-disable-next-line camelcase
            access_token: attrs
          }
        }
      };
    } else {
      // Reminder: order is important here
      ['credentials.authorization', 'authorization', 'credentials.supertoken.supertoken', 'supertoken', 'access_token', 'credentials.authorization.supertoken'].forEach(function (path) {
        var val = (0, _get3.default)(attrs, path);
        if (val) {
          (0, _unset3.default)(attrs, path);
          (0, _set3.default)(attrs, 'credentials.supertoken', val);
        }
      });

      ['credentials', 'credentials.authorization'].forEach(function (path) {
        var val = (0, _get3.default)(attrs, path);
        if (typeof val === 'string') {
          (0, _unset3.default)(attrs, path);
          (0, _set3.default)(attrs, 'credentials.supertoken', val);
        }
      });

      if (typeof (0, _get3.default)(attrs, 'credentials.access_token') === 'string') {
        (0, _set3.default)(attrs, 'credentials.supertoken', attrs.credentials);
      }
    }

    return (0, _apply2.default)(_ampersandState2.default, this, [attrs, options]);
  },


  derived: {
    boundedStorage: {
      deps: [],
      fn: function fn() {
        return (0, _storage.makeSparkStore)('bounded', this);
      }
    },
    unboundedStorage: {
      deps: [],
      fn: function fn() {
        return (0, _storage.makeSparkStore)('unbounded', this);
      }
    },
    ready: {
      deps: ['loaded', 'internal.ready'],
      fn: function fn() {
        var _this = this;

        return this.loaded && (0, _keys2.default)(this._children).reduce(function (ready, name) {
          return ready && _this[name] && _this[name].ready !== false;
        }, true);
      }
    }
  },

  session: {
    config: {
      type: 'object'
    },
    /**
     * When true, indicates that the initial load from the storage layer is
     * complete
     * @instance
     * @memberof SparkCore
     * @type {boolean}
     */
    loaded: {
      default: false,
      type: 'boolean'
    },
    request: {
      setOnce: true,
      // It's supposed to be a function, but that's not a type defined in
      // Ampersand
      type: 'any'
    },
    sessionId: {
      setOnce: true,
      type: 'string'
    }
  },

  /**
   * @instance
   * @memberof SparkCore
   * @param {[type]} args
   * @returns {[type]}
   */
  refresh: function refresh() {
    var _credentials;

    return (_credentials = this.credentials).refresh.apply(_credentials, arguments);
  },


  /**
   * Applies the directionally appropriate transforms to the specified object
   * @param {string} direction
   * @param {Object} object
   * @returns {Promise}
   */
  transform: function transform(direction, object) {
    var _this2 = this;

    var predicates = this.config.payloadTransformer.predicates.filter(function (p) {
      return !p.direction || p.direction === direction;
    });
    var ctx = {
      spark: this
    };
    return _promise2.default.all(predicates.map(function (p) {
      return p.test(ctx, object).then(function (shouldTransform) {
        if (!shouldTransform) {
          return undefined;
        }
        return p.extract(object)
        // eslint-disable-next-line max-nested-callbacks
        .then(function (target) {
          return {
            name: p.name,
            target: target
          };
        });
      });
    })).then(function (data) {
      return data.filter(function (d) {
        return Boolean(d);
      })
      // eslint-disable-next-line max-nested-callbacks
      .reduce(function (promise, _ref) {
        var name = _ref.name,
            target = _ref.target,
            alias = _ref.alias;
        return promise.then(function () {
          if (alias) {
            return _this2.applyNamedTransform(direction, alias, target);
          }
          return _this2.applyNamedTransform(direction, name, target);
        });
      }, _promise2.default.resolve());
    }).then(function () {
      return object;
    });
  },


  /**
   * Applies the directionally appropriate transform to the specified parameters
   * @param {string} direction
   * @param {Object} ctx
   * @param {string} name
   * @returns {Promise}
   */
  applyNamedTransform: function applyNamedTransform(direction, ctx, name) {
    for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest[_key - 3] = arguments[_key];
    }

    var _this3 = this;

    if ((0, _isString3.default)(ctx)) {
      rest.unshift(name);
      name = ctx;
      ctx = {
        spark: this,
        transform: function transform() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return _this3.applyNamedTransform.apply(_this3, [direction, ctx].concat(args));
        }
      };
    }

    var transforms = ctx.spark.config.payloadTransformer.transforms.filter(function (tx) {
      return tx.name === name && (!tx.direction || tx.direction === direction);
    });
    // too many implicit returns on the same line is difficult to interpret
    // eslint-disable-next-line arrow-body-style
    return transforms.reduce(function (promise, tx) {
      return promise.then(function () {
        if (tx.alias) {
          var _ctx;

          return (_ctx = ctx).transform.apply(_ctx, [tx.alias].concat((0, _toConsumableArray3.default)(rest)));
        }
        return _promise2.default.resolve(tx.fn.apply(tx, [ctx].concat((0, _toConsumableArray3.default)(rest))));
      });
    }, _promise2.default.resolve()).then(function () {
      return (0, _last3.default)(rest);
    });
  },


  /**
   * @private
   * @returns {Window}
   */
  getWindow: function getWindow() {
    // eslint-disable-next-line
    return window;
  },


  /**
   * Initializer
   *
   * @emits SparkCore#loaded
   * @emits SparkCore#ready
   * @instance
   * @memberof SparkCore
   * @param {Object} attrs
   * @returns {SparkCore}
   */
  initialize: function initialize() {
    var _this4 = this;

    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this.config = (0, _merge3.default)({}, _config2.default, attrs.config);

    // There's some unfortunateness with the way {@link AmpersandState#children}
    // get initialized. We'll fire the change:config event so that
    // {@link SparkPlugin#initialize()} can use
    // `this.listenToOnce(parent, 'change:config', () => {});` to act on config
    // during initialization
    this.trigger('change:config');

    var onLoaded = function onLoaded() {
      if (_this4.loaded) {
        /**
         * Fires when all data has been loaded from the storage layer
         * @event loaded
         * @instance
         * @memberof SparkCore
         */
        _this4.trigger('loaded');

        _this4.stopListening(_this4, 'change:loaded', onLoaded);
      }
    };

    // This needs to run on nextTick or we'll never be able to wire up listeners
    process.nextTick(function () {
      _this4.listenToAndRun(_this4, 'change:loaded', onLoaded);
    });

    var onReady = function onReady() {
      if (_this4.ready) {
        /**
         * Fires when all plugins have fully initialized
         * @event ready
         * @instance
         * @memberof SparkCore
         */
        _this4.trigger('ready');

        _this4.stopListening(_this4, 'change:ready', onReady);
      }
    };

    // This needs to run on nextTick or we'll never be able to wire up listeners
    process.nextTick(function () {
      _this4.listenToAndRun(_this4, 'change:ready', onReady);
    });

    // Make nested events propagate in a consistent manner
    (0, _keys2.default)(this.constructor.prototype._children).forEach(function (key) {
      _this4.listenTo(_this4[key], 'change', function () {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        args.unshift('change:' + key);
        _this4.trigger.apply(_this4, args);
      });
    });

    var addInterceptor = function addInterceptor(ints, key) {
      var interceptor = interceptors[key];

      if (!(0, _isFunction3.default)(interceptor)) {
        return ints;
      }

      ints.push((0, _apply2.default)(interceptor, _this4, []));

      return ints;
    };

    var ints = [];
    ints = preInterceptors.reduce(addInterceptor, ints);
    ints = (0, _keys2.default)(interceptors).filter(function (key) {
      return !(preInterceptors.includes(key) || postInterceptors.includes(key));
    }).reduce(addInterceptor, ints);
    ints = postInterceptors.reduce(addInterceptor, ints);

    this.request = (0, _httpCore.defaults)({
      json: true,
      interceptors: ints
    });

    var sessionId = (0, _get3.default)(this, 'config.trackingIdPrefix', 'spark-js-sdk') + '_' + (0, _get3.default)(this, 'config.trackingIdBase', _uuid2.default.v4());
    if ((0, _has3.default)(this, 'config.trackingIdPrefix')) {
      sessionId += '_' + (0, _get3.default)(this, 'config.trackingIdPrefix');
    }

    this.sessionId = sessionId;
  },


  /**
   * @instance
   * @memberof SparkPlugin
   * @param {number} depth
   * @private
   * @returns {Object}
   */
  inspect: function inspect(depth) {
    return _util2.default.inspect((0, _omit3.default)(this.serialize({
      props: true,
      session: true,
      derived: true
    }), 'boundedStorage', 'unboundedStorage', 'request', 'config'), { depth: depth });
  },


  /**
   * Invokes all `onBeforeLogout` handlers in the scope of their plugin, clears
   * all stores, and revokes the access token
   * Note: If you're using the sdk in a server environment, you may be more
   * interested in {@link `spark.internal.mercury.disconnect()`| Mercury#disconnect()}
   * and {@link `spark.internal.device.unregister()`|Device#unregister()}
   * or {@link `spark.phone.unregister()`|Phone#unregister}
   * @instance
   * @memberof SparkCore
   * @param {Object} options Passed as the first argument to all
   * `onBeforeLogout` handlers
   * @returns {Promise}
   */
  logout: function logout(options) {
    var _this5 = this;

    for (var _len4 = arguments.length, rest = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      rest[_key4 - 1] = arguments[_key4];
    }

    // prefer the refresh token, but for clients that don't have one, fallback
    // to the access token
    var token = this.credentials.supertoken && (this.credentials.supertoken.refresh_token || this.credentials.supertoken.access_token);
    options = (0, _assign2.default)({ token: token }, options);
    // onBeforeLogout should be executed in the opposite order in which handlers
    // were registered. In that way, wdm unregister() will be above mercury
    // disconnect(), but disconnect() will execute first.
    // eslint-disable-next-line arrow-body-style
    return this.config.onBeforeLogout.reverse().reduce(function (promise, _ref2) {
      var plugin = _ref2.plugin,
          fn = _ref2.fn;
      return promise.then(function () {
        return _promise2.default.resolve((0, _apply2.default)(fn, _this5[plugin] || _this5.internal[plugin], [options].concat((0, _toConsumableArray3.default)(rest))))
        // eslint-disable-next-line max-nested-callbacks
        .catch(function (err) {
          _this5.logger.warn('onBeforeLogout from plugin ' + plugin + ': failed', err);
        });
      });
    }, _promise2.default.resolve()).then(function () {
      return _promise2.default.all([_this5.boundedStorage.clear(), _this5.unboundedStorage.clear()]);
    }).then(function () {
      var _credentials2;

      return (_credentials2 = _this5.credentials).invalidate.apply(_credentials2, (0, _toConsumableArray3.default)(rest));
    }).then(function () {
      var _authorization;

      return _this5.authorization && _this5.authorization.logout && (_authorization = _this5.authorization).logout.apply(_authorization, [options].concat((0, _toConsumableArray3.default)(rest)));
    }).then(function () {
      return _this5.trigger('client:logout');
    });
  },


  /**
   * General purpose wrapper to submit metrics via the metrics plugin (if the
   * metrics plugin is installed)
   * @instance
   * @memberof SparkCore
   * @returns {Promise}
   */
  measure: function measure() {
    if (this.metrics) {
      var _metrics;

      return (_metrics = this.metrics).sendUnstructured.apply(_metrics, arguments);
    }

    return _promise2.default.resolve();
  },
  upload: function upload(options) {
    var _this6 = this;

    if (!options.file) {
      return _promise2.default.reject(new Error('`options.file` is required'));
    }

    options.phases = options.phases || {};
    options.phases.initialize = options.phases.initialize || {};
    options.phases.upload = options.phases.upload || {};
    options.phases.finalize = options.phases.finalize || {};

    (0, _defaults3.default)(options.phases.initialize, {
      method: 'POST'
    }, (0, _omit3.default)(options, 'file', 'phases'));

    (0, _defaults3.default)(options.phases.upload, {
      method: 'PUT',
      json: false,
      withCredentials: false,
      body: options.file,
      headers: {
        'x-trans-id': _uuid2.default.v4(),
        authorization: undefined
      }
    });

    (0, _defaults3.default)(options.phases.finalize, {
      method: 'POST'
    }, (0, _omit3.default)(options, 'file', 'phases'));

    var shunt = new _events.EventEmitter();

    var promise = this._uploadPhaseInitialize(options).then(function () {
      var p = _this6._uploadPhaseUpload(options);
      (0, _common.transferEvents)('progress', p, shunt);
      return p;
    }).then(function () {
      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return _this6._uploadPhaseFinalize.apply(_this6, [options].concat(args));
    }).then(function (res) {
      return res.body;
    });

    (0, _common.proxyEvents)(shunt, promise);

    return promise;
  },


  _uploadPhaseInitialize: function _uploadPhaseInitialize(options) {
    var _this7 = this;

    this.logger.debug('client: initiating upload session');

    return this.request(options.phases.initialize).then(function () {
      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return _this7._uploadApplySession.apply(_this7, [options].concat(args));
    }).then(function (res) {
      _this7.logger.debug('client: initiated upload session');
      return res;
    });
  },

  _uploadApplySession: function _uploadApplySession(options, res) {
    var session = res.body;
    ['upload', 'finalize'].reduce(function (opts, key) {
      opts[key] = (0, _keys2.default)(opts[key]).reduce(function (phaseOptions, phaseKey) {
        if (phaseKey.startsWith('$')) {
          phaseOptions[phaseKey.substr(1)] = phaseOptions[phaseKey](session);
          (0, _deleteProperty2.default)(phaseOptions, phaseKey);
        }

        return phaseOptions;
      }, opts[key]);

      return opts;
    }, options.phases);
  },
  _uploadPhaseUpload: function _uploadPhaseUpload(options) {
    var _this8 = this;

    this.logger.debug('client: uploading file');

    var promise = this.request(options.phases.upload).then(function (res) {
      _this8.logger.debug('client: uploaded file');
      return res;
    });

    (0, _common.proxyEvents)(options.phases.upload.upload, promise);

    /* istanbul ignore else */
    if (process.env.NODE_ENV === 'test') {
      promise.on('progress', function (event) {
        _this8.logger.info('upload progress', event.loaded, event.total);
      });
    }

    return promise;
  },


  _uploadPhaseFinalize: function _uploadPhaseFinalize(options) {
    var _this9 = this;

    this.logger.debug('client: finalizing upload session');

    return this.request(options.phases.finalize).then(function (res) {
      _this9.logger.debug('client: finalized upload session');
      return res;
    });
  }
}, (_applyDecoratedDescriptor(_obj, '_uploadPhaseUpload', [_common.retry], (0, _getOwnPropertyDescriptor2.default)(_obj, '_uploadPhaseUpload'), _obj)), _obj));

SparkCore.version = '1.32.5';

(0, _sparkInternalCorePluginMixin2.default)(_sparkInternalCore2.default, _config2.default, interceptors);
(0, _sparkCorePluginMixin2.default)(SparkCore, _config2.default, interceptors);

exports.default = SparkCore;

/**
 * @method registerPlugin
 * @param {string} name
 * @param {function} constructor
 * @param {Object} options
 * @param {Array<string>} options.proxies
 * @param {Object} options.interceptors
 * @returns {null}
 */

function registerPlugin(name, constructor, options) {
  SparkCore.registerPlugin(name, constructor, options);
}

/**
 * Registers plugins used by internal products that do not talk to public APIs.
 * @method registerInternalPlugin
 * @param {string} name
 * @param {function} constructor
 * @param {Object} options
 * @param {Object} options.interceptors
 * @private
 * @returns {null}
 */
function registerInternalPlugin(name, constructor, options) {
  _sparkInternalCore2.default.registerPlugin(name, constructor, options);
}


}).call(this,require('_process'))
},{"./config":131,"./interceptors/auth":133,"./interceptors/network-timing":134,"./interceptors/payload-transformer":135,"./interceptors/rate-limit":136,"./interceptors/redirect":137,"./interceptors/request-event":138,"./interceptors/request-logger":139,"./interceptors/request-timing":140,"./interceptors/response-logger":141,"./interceptors/spark-tracking-id":142,"./interceptors/spark-user-agent":143,"./lib/spark-core-plugin-mixin":152,"./lib/spark-http-error":153,"./lib/spark-internal-core-plugin-mixin":154,"./lib/storage":158,"./spark-internal-core":164,"@ciscospark/common":112,"@ciscospark/http-core":123,"_process":1743,"ampersand-state":675,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/toConsumableArray":710,"events":1737,"lodash/defaults":1618,"lodash/get":1636,"lodash/has":1638,"lodash/isFunction":1656,"lodash/isString":1662,"lodash/last":1669,"lodash/merge":1674,"lodash/omit":1679,"lodash/set":1694,"lodash/unset":1712,"util":1769,"uuid":191}],164:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _ampersandState = require('ampersand-state');

var _ampersandState2 = _interopRequireDefault(_ampersandState);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SparkInternalCore is an extra layer of nesting to make it blatantly clear that
 * private plugins are, in fact, private.
 * @class
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var SparkInternalCore = _ampersandState2.default.extend({
  derived: {
    ready: {
      deps: [],
      fn: function fn() {
        var _this = this;

        return (0, _keys2.default)(this._children).reduce(function (ready, name) {
          return ready && _this[name] && _this[name].ready !== false;
        }, true);
      }
    }
  },

  /**
   * @instance
   * @memberof SparkPlugin
   * @param {number} depth
   * @private
   * @returns {Object}
   */
  inspect: function inspect(depth) {
    return _util2.default.inspect(this.serialize({
      props: true,
      session: true,
      derived: true
    }), { depth: depth });
  }
});

exports.default = SparkInternalCore;


},{"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"util":1769}],165:[function(require,module,exports){
var AmpersandEvents = require('ampersand-events');
var classExtend = require('ampersand-class-extend');
var isArray = require('lodash/isArray');
var bind = require('lodash/bind');
var assign = require('lodash/assign');
var slice = [].slice;

function Collection(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator) this.comparator = options.comparator;
    if (options.parent) this.parent = options.parent;
    if (!this.mainIndex) {
        var idAttribute = this.model && this.model.prototype && this.model.prototype.idAttribute;
        this.mainIndex = idAttribute || 'id';
    }
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, assign({silent: true}, options));
}

assign(Collection.prototype, AmpersandEvents, {
    initialize: function () {},

    isModel: function (model) {
        return this.model && model instanceof this.model;
    },

    add: function (models, options) {
        return this.set(models, assign({merge: false, add: true, remove: false}, options));
    },

    // overridable parse method
    parse: function (res, options) {
        return res;
    },

    // overridable serialize method
    serialize: function () {
        return this.map(function (model) {
            if (model.serialize) {
                return model.serialize();
            } else {
                var out = {};
                assign(out, model);
                delete out.collection;
                return out;
            }
        });
    },

    toJSON: function () {
        return this.serialize();
    },

    set: function (models, options) {
        options = assign({add: true, remove: true, merge: true}, options);
        if (options.parse) models = this.parse(models, options);
        var singular = !isArray(models);
        models = singular ? (models ? [models] : []) : models.slice();
        var id, model, attrs, existing, sort, i, length;
        var at = options.at;
        var sortable = this.comparator && (at == null) && options.sort !== false;
        var sortAttr = ('string' === typeof this.comparator) ? this.comparator : null;
        var toAdd = [], toRemove = [], modelMap = {};
        var add = options.add, merge = options.merge, remove = options.remove;
        var order = !sortable && add && remove ? [] : false;
        var targetProto = this.model && this.model.prototype || Object.prototype;

        // Turn bare objects into model references, and prevent invalid models
        // from being added.
        for (i = 0, length = models.length; i < length; i++) {
            attrs = models[i] || {};
            if (this.isModel(attrs)) {
                id = model = attrs;
            } else if (targetProto.generateId) {
                id = targetProto.generateId(attrs);
            } else {
                id = attrs[this.mainIndex];
                if (id === undefined && this._isDerivedIndex(targetProto)) {
                    id = targetProto._derived[this.mainIndex].fn.call(attrs);
                }
            }

            // If a duplicate is found, prevent it from being added and
            // optionally merge it into the existing model.
            if (existing = this.get(id)) {
                if (remove) modelMap[existing.cid || existing[this.mainIndex]] = true;
                if (merge) {
                    attrs = attrs === model ? model.attributes : attrs;
                    if (options.parse) attrs = existing.parse(attrs, options);
                    // if this is model
                    if (existing.set) {
                        existing.set(attrs, options);
                        if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
                    } else {
                        // if not just update the properties
                        assign(existing, attrs);
                    }
                }
                models[i] = existing;

            // If this is a new, valid model, push it to the `toAdd` list.
            } else if (add) {
                model = models[i] = this._prepareModel(attrs, options);
                if (!model) continue;
                toAdd.push(model);
                this._addReference(model, options);
            }

            // Do not add multiple models with the same `id`.
            model = existing || model;
            if (!model) continue;
            if (order && ((model.isNew && model.isNew() || !model[this.mainIndex]) || !modelMap[model.cid || model[this.mainIndex]])) order.push(model);
            modelMap[model[this.mainIndex]] = true;
        }

        // Remove nonexistent models if appropriate.
        if (remove) {
            for (i = 0, length = this.length; i < length; i++) {
                model = this.models[i];
                if (!modelMap[model.cid || model[this.mainIndex]]) toRemove.push(model);
            }
            if (toRemove.length) this.remove(toRemove, options);

            // Add indexes again to make sure they were not removed above.
            for (i = 0, length = toAdd.length; i < length; i++) {
                this._index(toAdd[i]);
            }
        }

        // See if sorting is needed, update `length` and splice in new models.
        if (toAdd.length || (order && order.length)) {
            if (sortable) sort = true;
            if (at != null) {
                for (i = 0, length = toAdd.length; i < length; i++) {
                    this.models.splice(at + i, 0, toAdd[i]);
                }
            } else {
                var orderedModels = order || toAdd;
                for (i = 0, length = orderedModels.length; i < length; i++) {
                    this.models.push(orderedModels[i]);
                }
            }
        }

        // Silently sort the collection if appropriate.
        if (sort) this.sort({silent: true});

        // Unless silenced, it's time to fire all appropriate add/sort events.
        if (!options.silent) {
            for (i = 0, length = toAdd.length; i < length; i++) {
                model = toAdd[i];
                if (model.trigger) {
                    model.trigger('add', model, this, options);
                } else {
                    this.trigger('add', model, this, options);
                }
            }
            if (sort || (order && order.length)) this.trigger('sort', this, options);
        }

        // Return the added (or merged) model (or models).
        return singular ? models[0] : models;
    },

    get: function (query, indexName) {
        if (query == null) return;

        var collectionMainIndex = this.mainIndex;
        var index = this._indexes[indexName || collectionMainIndex];

        return (
            (
                index && (
                    index[query] || (
                        query[collectionMainIndex] !== undefined &&
                        index[query[collectionMainIndex]]
                    )
                )
            ) ||
            this._indexes.cid[query] ||
            this._indexes.cid[query.cid]
        );
    },

    // Get the model at the given index.
    at: function (index) {
        return this.models[index];
    },

    remove: function (models, options) {
        var singular = !isArray(models);
        var i, length, model, index;

        models = singular ? [models] : slice.call(models);
        options || (options = {});
        for (i = 0, length = models.length; i < length; i++) {
            model = models[i] = this.get(models[i]);
            if (!model) continue;
            this._deIndex(model);
            index = this.models.indexOf(model);
            this.models.splice(index, 1);
            if (!options.silent) {
                options.index = index;
                if (model.trigger) {
                    model.trigger('remove', model, this, options);
                } else {
                    this.trigger('remove', model, this, options);
                }
            }
            this._removeReference(model, options);
        }
        return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function (models, options) {
        options || (options = {});
        for (var i = 0, length = this.models.length; i < length; i++) {
            this._removeReference(this.models[i], options);
        }
        options.previousModels = this.models;
        this._reset();
        models = this.add(models, assign({silent: true}, options));
        if (!options.silent) this.trigger('reset', this, options);
        return models;
    },

    sort: function (options) {
        var self = this;
        if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
        options || (options = {});

        if (typeof this.comparator === 'string') {
            this.models.sort(function (left, right) {
                if (left.get) {
                    left = left.get(self.comparator);
                    right = right.get(self.comparator);
                } else {
                    left = left[self.comparator];
                    right = right[self.comparator];
                }
                if (left > right || left === void 0) return 1;
                if (left < right || right === void 0) return -1;
                return 0;
            });
        } else if (this.comparator.length === 1) {
            this.models.sort(function (left, right) {
                left = self.comparator(left);
                right = self.comparator(right);
                if (left > right || left === void 0) return 1;
                if (left < right || right === void 0) return -1;
                return 0;
            });
        } else {
            this.models.sort(bind(this.comparator,this));
        }

        if (!options.silent) this.trigger('sort', this, options);
        return this;
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function () {
        var list = slice.call(this.indexes || []);
        var i = 0;
        list.push(this.mainIndex);
        list.push('cid');
        var l = list.length;
        this.models = [];
        this._indexes = {};
        for (; i < l; i++) {
            this._indexes[list[i]] = {};
        }
    },

    _prepareModel: function (attrs, options) {
        // if we haven't defined a constructor, skip this
        if (!this.model) return attrs;

        if (this.isModel(attrs)) {
            if (!attrs.collection) attrs.collection = this;
            return attrs;
        } else {
            options = options ? assign({}, options) : {};
            options.collection = this;
            var model = new this.model(attrs, options);
            if (!model.validationError) return model;
            this.trigger('invalid', this, model.validationError, options);
            return false;
        }
    },

    _deIndex: function (model, attribute, value) {
        var indexVal;
        if (attribute !== undefined) {
            if (undefined === this._indexes[attribute]) throw new Error('Given attribute is not an index');
            delete this._indexes[attribute][value];
            return;
        }
        // Not a specific attribute
        for (var indexAttr in this._indexes) {
            indexVal = model.hasOwnProperty(indexAttr) ? model[indexAttr] : (model.get && model.get(indexAttr));
            delete this._indexes[indexAttr][indexVal];
        }
    },

    _index: function (model, attribute) {
        var indexVal;
        if (attribute !== undefined) {
            if (undefined === this._indexes[attribute]) throw new Error('Given attribute is not an index');
            indexVal = model[attribute] || (model.get && model.get(attribute));
            if (indexVal) this._indexes[attribute][indexVal] = model;
            return;
        }
        // Not a specific attribute
        for (var indexAttr in this._indexes) {
            indexVal = model.hasOwnProperty(indexAttr) ? model[indexAttr] : (model.get && model.get(indexAttr));
            if (indexVal != null) this._indexes[indexAttr][indexVal] = model;
        }
    },

    _isDerivedIndex: function(proto) {
        if (!proto || typeof proto._derived !== 'object') {
            return false;
        }
        return Object.keys(proto._derived).indexOf(this.mainIndex) >= 0;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function (model, options) {
        this._index(model);
        if (!model.collection) model.collection = this;
        if (model.on) model.on('all', this._onModelEvent, this);
    },

        // Internal method to sever a model's ties to a collection.
    _removeReference: function (model, options) {
        if (this === model.collection) delete model.collection;
        this._deIndex(model);
        if (model.off) model.off('all', this._onModelEvent, this);
    },

    _onModelEvent: function (event, model, collection, options) {
        var eventName = event.split(':')[0];
        var attribute = event.split(':')[1];

        if ((eventName === 'add' || eventName === 'remove') && collection !== this) return;
        if (eventName === 'destroy') this.remove(model, options);
        if (model && eventName === 'change' && attribute && this._indexes[attribute]) {
            this._deIndex(model, attribute, model.previousAttributes()[attribute]);
            this._index(model, attribute);
        }
        this.trigger.apply(this, arguments);
    }
});

Object.defineProperties(Collection.prototype, {
    length: {
        get: function () {
            return this.models.length;
        }
    },
    isCollection: {
        get: function () {
            return true;
        }
    }
});

var arrayMethods = [
    'indexOf',
    'lastIndexOf',
    'every',
    'some',
    'forEach',
    'map',
    'filter',
    'reduce',
    'reduceRight'
];

arrayMethods.forEach(function (method) {
    Collection.prototype[method] = function () {
        return this.models[method].apply(this.models, arguments);
    };
});

// alias each/forEach for maximum compatibility
Collection.prototype.each = Collection.prototype.forEach;

Collection.extend = classExtend;

module.exports = Collection;

},{"ampersand-class-extend":671,"ampersand-events":673,"lodash/assign":1606,"lodash/bind":1610,"lodash/isArray":1648}],166:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],167:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./private/utils":180,"dup":22}],168:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./applyDecorators":166,"./autobind":167,"./debounce":169,"./decorate":170,"./deprecate":171,"./enumerable":172,"./extendDescriptor":173,"./lazy-initialize":174,"./memoize":175,"./mixin":176,"./nonconfigurable":177,"./nonenumerable":178,"./override":179,"./profile":181,"./readonly":182,"./suppress-warnings":183,"./throttle":184,"./time":185,"dup":23}],169:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./private/utils":180,"dup":24}],170:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"./private/utils":180,"dup":25}],171:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./private/utils":180,"dup":26}],172:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./private/utils":180,"dup":27}],173:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./private/utils":180,"dup":28}],174:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./private/utils":180,"dup":29}],175:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./private/utils":180,"dup":30}],176:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./private/utils":180,"dup":31}],177:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./private/utils":180,"dup":32}],178:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./private/utils":180,"dup":33}],179:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./private/utils":180,"dup":34}],180:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"../lazy-initialize":174,"dup":35}],181:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./private/utils":180,"dup":36}],182:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./private/utils":180,"dup":37}],183:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./private/utils":180,"dup":38}],184:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./private/utils":180,"dup":39}],185:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./private/utils":180,"dup":40}],186:[function(require,module,exports){
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

},{}],187:[function(require,module,exports){
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"./formats":186,"./parse":188,"./stringify":189}],188:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]') {
            obj = [];
            obj = obj.concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

},{"./utils":190}],189:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var formats = require('./formats');

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};

},{"./formats":186,"./utils":190}],190:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

var encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};

},{}],191:[function(require,module,exports){
var v1 = require('./v1');
var v4 = require('./v4');

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;

},{"./v1":194,"./v4":195}],192:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;

},{}],193:[function(require,module,exports){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));
if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

},{}],194:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

},{"./lib/bytesToUuid":192,"./lib/rng":193}],195:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"./lib/bytesToUuid":192,"./lib/rng":193}],196:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

var _messages = require('./messages');

var _messages2 = _interopRequireDefault(_messages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

(0, _sparkCore.registerPlugin)('messages', _messages2.default);

exports.default = _messages2.default;


},{"./messages":197,"@ciscospark/spark-core":227}],197:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _sparkCore = require('@ciscospark/spark-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} MessageObject
 * @property {string} id - (server generated) Unique identifier for the message
 * @property {string} personId - The ID for the author of the messasge
 * @property {email} personEmail - The email for the author of the messasge
 * @property {string} roomId - The ID for the room of the message
 * @property {string} text - The message posted to the room in plain text
 * @property {string} markdown - The message posted to the room in markdown
 * @property {Array<string>} files - The source URL(s) for the message attachment(s).
 * See the {@link https://developer.webex.com/attachments.html|Message Attachments}
 * Guide for a list of supported media types.
 * @property {isoDate} created - (server generated) The date and time that the message was created
 */

/**
 * Messages are how people communicate in rooms. Each message timestamped and
 * represented in Spark as a distinct block of content. Messages can contain
 * plain text and a single file attachment. See the
 * {@link https://developer.webex.com/attachments.html|Message Attachments} Guide
 * for a list of supported media types.
 * @class
 */
var Messages = _sparkCore.SparkPlugin.extend({
  /**
   * Post a new message and/or media content into a room.
   * @instance
   * @memberof Messages
   * @param {MessageObject} message
   * @returns {Promise<MessageObject>}
   * @example
   * ciscospark.rooms.create({title: 'Create Message Example'})
   *   .then(function(room) {
   *     return ciscospark.messages.create({
   *       text: 'Howdy!',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(message) {
   *     var assert = require('assert');
   *     assert(message.id);
   *     assert(message.personId);
   *     assert(message.personEmail);
   *     assert(message.roomId);
   *     assert(message.created);
   *     return 'success';
   *   });
   *   // => success
   */
  create: function create(message) {
    var key = 'body';
    if (message.file) {
      this.logger.warn('Supplying a single `file` property is deprecated; please supply a `files` array');
      message.files = [message.file];
      (0, _deleteProperty2.default)(message, 'file');
    }

    if ((0, _isArray3.default)(message.files) && message.files.reduce(function (type, file) {
      return type || typeof file !== 'string';
    }, false)) {
      key = 'formData';
    }

    var options = (0, _defineProperty3.default)({
      method: 'POST',
      service: 'hydra',
      resource: 'messages'
    }, key, message);

    return this.request(options).then(function (res) {
      return res.body;
    });
  },


  /**
   * Returns a single message.
   * @instance
   * @memberof Messages
   * @param {RoomObject|string} message
   * @returns {Promise<MessageObject>}
   * @example
   * var message;
   * ciscospark.rooms.create({title: 'Get Message Example'})
   *   .then(function(room) {
   *     return ciscospark.messages.create({
   *       text: 'Howdy!',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     message = m;
   *     return ciscospark.messages.get(message.id);
   *   })
   *   .then(function(message2) {
   *     var assert = require('assert');
   *     assert.deepEqual(message2, message);
   *     return 'success';
   *   });
   *   // => success
   */
  get: function get(message) {
    var id = message.id || message;

    return this.request({
      service: 'hydra',
      resource: 'messages/' + id
    }).then(function (res) {
      return res.body.items || res.body;
    });
  },


  /**
   * Returns a list of messages. In most cases the results will only contain
   * messages posted in rooms that the authentiated user is a member of.
   * @instance
   * @memberof Messages
   * @param {Object} options
   * @param {string} options.roomId
   * @param {number} options.max
   * @returns {Promise<Page<MessageObject>>}
   * @example
   * var message1, message2, room;
   * ciscospark.rooms.create({title: 'List Messages Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.messages.create({
   *       text: 'Howdy!',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     message1 = m;
   *     return ciscospark.messages.create({
   *       text: 'How are you?',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     message2 = m;
   *     return ciscospark.messages.list({roomId: room.id});
   *   })
   *   .then(function(messages) {
   *     var assert = require('assert');
   *     assert.equal(messages.length, 2);
   *     assert.equal(messages.items[0].id, message2.id);
   *     assert.equal(messages.items[1].id, message1.id);
   *     return 'success';
   *   });
   *   // => success
   */
  list: function list(options) {
    var _this = this;

    return this.request({
      service: 'hydra',
      resource: 'messages',
      qs: options
    }).then(function (res) {
      return new _sparkCore.Page(res, _this.spark);
    });
  },


  /**
   * Deletes a single message. Deleting a message will notify all members of the
   * room that the authenticated user deleted the message. Generally, users can
   * only delete their own messages except for the case of Moderated Rooms and
   * Org Administrators.
   * @instance
   * @memberof Messages
   * @param {MessageObject|uuid} message
   * @returns {Promise}}
   * @example
   * var message1, room;
   * ciscospark.rooms.create({title: 'Messages Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.messages.create({
   *       text: 'Howdy!',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     message1 = m;
   *     return ciscospark.messages.create({
   *       text: 'How are you?',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function() {
   *     return ciscospark.messages.remove(message1);
   *   })
   *   .then(function() {
   *     return ciscospark.messages.list({roomId: room.id});
   *   })
   *   .then(function(messages) {
   *     var assert = require('assert');
   *     assert.equal(messages.items.length, 1);
   *     assert(messages.items[0].id !== message1.id);
   *     return 'success';
   *   });
   *   // => success
   */
  remove: function remove(message) {
    var id = message.id || message;

    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: 'messages/' + id
    }).then(function (res) {
      // Firefox has some issues with 204s and/or DELETE. This should move to
      // http-core
      if (res.statusCode === 204) {
        return undefined;
      }
      return res.body;
    });
  },
  version: '1.32.5'
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = Messages;


},{"@ciscospark/spark-core":227,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/defineProperty":706,"lodash/isArray":1648}],198:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"buffer":1735,"dup":3,"urlsafe-base64":1730}],199:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":4}],200:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],201:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":6}],202:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"_process":1743,"core-decorators":263,"dup":7}],203:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":8,"lodash/isArray":1648}],204:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"babel-runtime/core-js/array/from":678,"babel-runtime/core-js/object/create":685,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/set-prototype-of":692,"babel-runtime/core-js/reflect/construct":696,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":9}],205:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],206:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./node":205,"dup":11}],207:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./base64":198,"./capped-debounce":199,"./check-required":200,"./defer":201,"./deprecated":202,"./events":203,"./exception":204,"./in-browser":206,"./make-state-datatype":208,"./one-flight":209,"./patterns.js":210,"./resolve-with":211,"./retry":212,"./tap":213,"./template-container":214,"./while-in-flight":215,"dup":12}],208:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],209:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./template-container":214,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/typeof":711,"dup":14,"lodash/wrap":1715}],210:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],211:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":16}],212:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/typeof":711,"backoff":712,"dup":17,"events":1737,"lodash/defaults":1618,"lodash/isFunction":1656,"lodash/wrap":1715}],213:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":18}],214:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":19,"util":1769}],215:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./tap":213,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":20,"lodash/wrap":1715}],216:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":121}],217:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"./http-error-subtypes":216,"@ciscospark/common":207,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/values":693,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":122,"lodash/pick":1685}],218:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./http-error":217,"./interceptors/http-status":219,"./lib/detect":220,"./lib/interceptor":221,"./progress-event":223,"./request":224,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/reflect/get-own-property-descriptor":699,"dup":123,"lodash/assign":1606,"lodash/curry":1615,"lodash/defaults":1618,"lodash/isString":1662}],219:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"../http-error":217,"../lib/interceptor":221,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":124}],220:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"@ciscospark/common":207,"babel-runtime/core-js/promise":694,"dup":125,"file-type":1309}],221:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":126}],222:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"babel-runtime/core-js/json/stringify":681,"dup":127,"global/window":1311,"is-function":1312,"parse-headers":1717,"xtend":1732}],223:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"babel-runtime/core-js/number/is-nan":683,"babel-runtime/core-js/object/define-properties":686,"dup":128,"lodash/isNumber":1658}],224:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"./request":225,"@ciscospark/common":207,"babel-runtime/core-js/promise":694,"dup":129,"events":1737}],225:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"../lib/detect":220,"../lib/xhr":222,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/typeof":711,"dup":130,"lodash/defaults":1618,"lodash/isArray":1648,"lodash/pick":1685,"qs":282}],226:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./lib/storage":253,"_process":1743,"dup":131}],227:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./config":226,"./interceptors/auth":228,"./interceptors/network-timing":229,"./interceptors/payload-transformer":230,"./interceptors/rate-limit":231,"./interceptors/redirect":232,"./interceptors/request-event":233,"./interceptors/request-logger":234,"./interceptors/request-timing":235,"./interceptors/response-logger":236,"./interceptors/spark-tracking-id":237,"./interceptors/spark-user-agent":238,"./lib/batcher":239,"./lib/credentials":242,"./lib/page":246,"./lib/spark-http-error":248,"./lib/spark-plugin":250,"./lib/storage":253,"./plugins/logger":257,"./spark-core":258,"dup":132}],228:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"@ciscospark/http-core":218,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":133}],229:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"@ciscospark/http-core":218,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":134}],230:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"@ciscospark/http-core":218,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":135}],231:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"@ciscospark/http-core":218,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":136}],232:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"@ciscospark/http-core":218,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":137,"lodash/clone":1611}],233:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"@ciscospark/http-core":218,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":138,"lodash/get":1636}],234:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"@ciscospark/http-core":218,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":139,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isString":1662,"lodash/omit":1679,"util":1769}],235:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"@ciscospark/http-core":218,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":140}],236:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"../../../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":1740,"@ciscospark/http-core":218,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":141,"lodash/get":1636,"lodash/omit":1679,"util":1769}],237:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"@ciscospark/http-core":218,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":142}],238:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"@ciscospark/common":207,"@ciscospark/http-core":218,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":143,"lodash/get":1636}],239:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"./spark-http-error":248,"./spark-plugin":250,"@ciscospark/common":207,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"dup":144,"lodash/has":1638}],240:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"../spark-plugin":250,"../storage/decorators":251,"./grant-errors":241,"./scope":243,"./token":245,"./token-collection":244,"@ciscospark/common":207,"@ciscospark/common-timers":41,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"dup":145,"lodash/clone":1611,"lodash/cloneDeep":1612,"lodash/isEmpty":1653,"lodash/isObject":1659,"querystring":1747,"url":1765}],241:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"@ciscospark/common":207,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":146}],242:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"../../spark-core":258,"./credentials":240,"./grant-errors":241,"./scope":243,"./token":245,"dup":147}],243:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"dup":148}],244:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"./token":245,"ampersand-collection":260,"dup":149}],245:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"../spark-http-error":248,"../spark-plugin":250,"./grant-errors":241,"./scope":243,"@ciscospark/common":207,"@ciscospark/common-timers":41,"_process":1743,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/slicedToArray":709,"dup":150,"lodash/pick":1685}],246:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"babel-runtime/core-js/symbol/iterator":702,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":151}],247:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":152,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],248:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"@ciscospark/http-core":218,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":153}],249:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":154,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],250:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"./storage":253,"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":155,"lodash/cloneDeep":1612,"lodash/isObject":1659,"lodash/omit":1679,"util":1769}],251:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"./errors":252,"@ciscospark/common":207,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/set":700,"babel-runtime/helpers/defineProperty":706,"babel-runtime/helpers/toConsumableArray":710,"babel-runtime/helpers/typeof":711,"dup":156,"lodash/curry":1615,"lodash/debounce":1617,"lodash/identity":1641,"lodash/result":1692,"lodash/wrap":1715}],252:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"@ciscospark/common":207,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":157}],253:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"./decorators":251,"./errors":252,"./make-spark-plugin-store.js":254,"./make-spark-store.js":255,"./memory-store-adapter":256,"dup":158}],254:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"./errors":252,"@ciscospark/common":207,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":159,"lodash/isArray":1648,"lodash/isObject":1659,"lodash/result":1692}],255:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"@ciscospark/common":207,"ampersand-events":673,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":160}],256:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"./errors":252,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"dup":161}],257:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"../lib/spark-plugin":250,"../spark-core":258,"_process":1743,"dup":162}],258:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./config":226,"./interceptors/auth":228,"./interceptors/network-timing":229,"./interceptors/payload-transformer":230,"./interceptors/rate-limit":231,"./interceptors/redirect":232,"./interceptors/request-event":233,"./interceptors/request-logger":234,"./interceptors/request-timing":235,"./interceptors/response-logger":236,"./interceptors/spark-tracking-id":237,"./interceptors/spark-user-agent":238,"./lib/spark-core-plugin-mixin":247,"./lib/spark-http-error":248,"./lib/spark-internal-core-plugin-mixin":249,"./lib/storage":253,"./spark-internal-core":259,"@ciscospark/common":207,"@ciscospark/http-core":218,"_process":1743,"ampersand-state":675,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/toConsumableArray":710,"dup":163,"events":1737,"lodash/defaults":1618,"lodash/get":1636,"lodash/has":1638,"lodash/isFunction":1656,"lodash/isString":1662,"lodash/last":1669,"lodash/merge":1674,"lodash/omit":1679,"lodash/set":1694,"lodash/unset":1712,"util":1769,"uuid":286}],259:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"dup":164,"util":1769}],260:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"ampersand-class-extend":671,"ampersand-events":673,"dup":165,"lodash/assign":1606,"lodash/bind":1610,"lodash/isArray":1648}],261:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],262:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./private/utils":275,"dup":22}],263:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./applyDecorators":261,"./autobind":262,"./debounce":264,"./decorate":265,"./deprecate":266,"./enumerable":267,"./extendDescriptor":268,"./lazy-initialize":269,"./memoize":270,"./mixin":271,"./nonconfigurable":272,"./nonenumerable":273,"./override":274,"./profile":276,"./readonly":277,"./suppress-warnings":278,"./throttle":279,"./time":280,"dup":23}],264:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./private/utils":275,"dup":24}],265:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"./private/utils":275,"dup":25}],266:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./private/utils":275,"dup":26}],267:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./private/utils":275,"dup":27}],268:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./private/utils":275,"dup":28}],269:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./private/utils":275,"dup":29}],270:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./private/utils":275,"dup":30}],271:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./private/utils":275,"dup":31}],272:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./private/utils":275,"dup":32}],273:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./private/utils":275,"dup":33}],274:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./private/utils":275,"dup":34}],275:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"../lazy-initialize":269,"dup":35}],276:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./private/utils":275,"dup":36}],277:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./private/utils":275,"dup":37}],278:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./private/utils":275,"dup":38}],279:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./private/utils":275,"dup":39}],280:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./private/utils":275,"dup":40}],281:[function(require,module,exports){
arguments[4][186][0].apply(exports,arguments)
},{"dup":186}],282:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./formats":281,"./parse":283,"./stringify":284,"dup":187}],283:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"./utils":285,"dup":188}],284:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"./formats":281,"./utils":285,"dup":189}],285:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],286:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"./v1":289,"./v4":290,"dup":191}],287:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"dup":192}],288:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"dup":193}],289:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./lib/bytesToUuid":287,"./lib/rng":288,"dup":194}],290:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"./lib/bytesToUuid":287,"./lib/rng":288,"dup":195}],291:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

var _rooms = require('./rooms');

var _rooms2 = _interopRequireDefault(_rooms);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

(0, _sparkCore.registerPlugin)('rooms', _rooms2.default);

exports.default = _rooms2.default;


},{"./rooms":292,"@ciscospark/spark-core":322}],292:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

/**
 * @typedef {Object} RoomObject
 * @property {string} id - (server generated) Unique identifier for the room
 * @property {string} title - The display name for the room. All room members
 * will see the title so make it something good
 * @property {string} teamId - (optional) The ID of the team to which the room
 * belongs
 * @property {isoDate} created - (server generated) The date and time that the
 * room was created
 */

/**
 * Rooms are virtual meeting places for getting stuff done. This resource
 * represents the room itself. Check out the {@link Memberships} API to learn
 * how to add and remove people from rooms and the {@link Messages} API for
 * posting and managing content.
 * @class
 * @name Rooms
 */
var Rooms = _sparkCore.SparkPlugin.extend({
  /**
   * Creates a new room. The authenticated user is automatically added as a
   * member of the room. See the {@link Memberships} API to learn how to add
   * more people to the room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject} room
   * @returns {Promise<RoomObject>}
   * @example
   * ciscospark.rooms.create({title: 'Create Room Example'})
   *   .then(function(room) {
   *     var assert = require('assert')
   *     assert(typeof room.created === 'string');
   *     assert(typeof room.id === 'string');
   *     assert(room.title === 'Create Room Example');
   *     console.log(room.title);
   *     return 'success';
   *   });
   *   // => success
   */
  create: function create(room) {
    return this.request({
      method: 'POST',
      service: 'hydra',
      resource: 'rooms',
      body: room
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Returns a single room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject|string} room
   * @param {Object} options
   * @returns {Promise<RoomObject>}
   * @example
   * var room;
   * ciscospark.rooms.create({title: 'Get Room Example'})
   *   .then(function(r) {
   *     room = r
   *     return ciscospark.rooms.get(room.id)
   *   })
   *   .then(function(r) {
   *     var assert = require('assert');
   *     assert.deepEqual(r, room);
   *     return 'success';
   *   });
   *   // => success
   */
  get: function get(room, options) {
    var id = room.id || room;

    return this.request({
      service: 'hydra',
      resource: 'rooms/' + id,
      qs: options
    }).then(function (res) {
      return res.body.items || res.body;
    });
  },


  /**
   * Returns a list of rooms. In most cases the results will only contain rooms
   * that the authentiated user is a member of.
   * @instance
   * @memberof Rooms
   * @param {Object} options
   * @param {Object} options.max Limit the maximum number of rooms in the
   * response.
   * @returns {Promise<Page<RoomObject>>}
   * @example
   * var createdRooms;
   * Promise.all([
   *   ciscospark.rooms.create({title: 'List Rooms Example 1'}),
   *   ciscospark.rooms.create({title: 'List Rooms Example 2'}),
   *   ciscospark.rooms.create({title: 'List Rooms Example 3'})
   * ])
   *   .then(function(r) {
   *     createdRooms = r;
   *     return ciscospark.rooms.list({max: 3})
   *       .then(function(rooms) {
   *         var assert = require('assert');
   *         assert(rooms.length === 3);
   *         for (var i = 0; i < rooms.items.length; i+= 1) {
   *           assert(createdRooms.filter(function(room) {
   *             return room.id === rooms.items[i].id;
   *           }).length === 1);
   *         }
   *         return 'success';
   *       });
   *   });
   *   // => success
   */
  list: function list(options) {
    var _this = this;

    return this.request({
      service: 'hydra',
      resource: 'rooms/',
      qs: options
    }).then(function (res) {
      return new _sparkCore.Page(res, _this.spark);
    });
  },


  /**
   * Deletes a single room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject|string} room
   * @returns {Promise}
   * @example
   * var room;
   * ciscospark.rooms.create({title: 'Remove Room Example'})
   *  .then(function(r) {
   *    room = r;
   *    return ciscospark.rooms.remove(room.id);
   *  })
   *  .then(function() {
   *    return ciscospark.rooms.get(room.id);
   *  })
   *  .then(function() {
   *    var assert = require('assert');
   *    assert(false, 'the previous get should have failed');
   *  })
   *  .catch(function(reason) {
   *    var assert = require('assert');
   *    assert.equal(reason.statusCode, 404);
   *    return 'success'
   *  });
   *  // => success
   */
  remove: function remove(room) {
    var id = room.id || room;
    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: 'rooms/' + id
    }).then(function (res) {
      // Firefox has some issues with 204s and/or DELETE. This should move to
      // http-core
      if (res.statusCode === 204) {
        return undefined;
      }
      return res.body;
    });
  },


  /**
   * Used to update a single room's properties.
   * @instance
   * @memberof Rooms
   * @param {RoomObject} room
   * @returns {Promise<RoomObject>}
   * @example
   * var room;
   * ciscospark.rooms.create({title: 'Update Room Example'})
   *   .then(function(r) {
   *     room = r;
   *     room.title = 'Update Room Example (Updated Title)';
   *     return ciscospark.rooms.update(room);
   *   })
   *   .then(function() {
   *     return ciscospark.rooms.get(room.id);
   *   })
   *   .then(function(room) {
   *    var assert = require('assert');
   *     assert.equal(room.title, 'Update Room Example (Updated Title)');
   *     return 'success';
   *   });
   *   // => success
   */
  update: function update(room) {
    var id = room.id;
    return this.request({
      method: 'PUT',
      service: 'hydra',
      resource: 'rooms/' + id,
      body: room
    }).then(function (res) {
      return res.body;
    });
  },
  version: '1.32.5'
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = Rooms;


},{"@ciscospark/spark-core":322}],293:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"buffer":1735,"dup":3,"urlsafe-base64":1730}],294:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":4}],295:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],296:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":6}],297:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"_process":1743,"core-decorators":358,"dup":7}],298:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":8,"lodash/isArray":1648}],299:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"babel-runtime/core-js/array/from":678,"babel-runtime/core-js/object/create":685,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/set-prototype-of":692,"babel-runtime/core-js/reflect/construct":696,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":9}],300:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],301:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./node":300,"dup":11}],302:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./base64":293,"./capped-debounce":294,"./check-required":295,"./defer":296,"./deprecated":297,"./events":298,"./exception":299,"./in-browser":301,"./make-state-datatype":303,"./one-flight":304,"./patterns.js":305,"./resolve-with":306,"./retry":307,"./tap":308,"./template-container":309,"./while-in-flight":310,"dup":12}],303:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],304:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./template-container":309,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/typeof":711,"dup":14,"lodash/wrap":1715}],305:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],306:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":16}],307:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/typeof":711,"backoff":712,"dup":17,"events":1737,"lodash/defaults":1618,"lodash/isFunction":1656,"lodash/wrap":1715}],308:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":18}],309:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":19,"util":1769}],310:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./tap":308,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":20,"lodash/wrap":1715}],311:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":121}],312:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"./http-error-subtypes":311,"@ciscospark/common":302,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/values":693,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":122,"lodash/pick":1685}],313:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./http-error":312,"./interceptors/http-status":314,"./lib/detect":315,"./lib/interceptor":316,"./progress-event":318,"./request":319,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/reflect/get-own-property-descriptor":699,"dup":123,"lodash/assign":1606,"lodash/curry":1615,"lodash/defaults":1618,"lodash/isString":1662}],314:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"../http-error":312,"../lib/interceptor":316,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":124}],315:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"@ciscospark/common":302,"babel-runtime/core-js/promise":694,"dup":125,"file-type":1309}],316:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":126}],317:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"babel-runtime/core-js/json/stringify":681,"dup":127,"global/window":1311,"is-function":1312,"parse-headers":1717,"xtend":1732}],318:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"babel-runtime/core-js/number/is-nan":683,"babel-runtime/core-js/object/define-properties":686,"dup":128,"lodash/isNumber":1658}],319:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"./request":320,"@ciscospark/common":302,"babel-runtime/core-js/promise":694,"dup":129,"events":1737}],320:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"../lib/detect":315,"../lib/xhr":317,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/typeof":711,"dup":130,"lodash/defaults":1618,"lodash/isArray":1648,"lodash/pick":1685,"qs":377}],321:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./lib/storage":348,"_process":1743,"dup":131}],322:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./config":321,"./interceptors/auth":323,"./interceptors/network-timing":324,"./interceptors/payload-transformer":325,"./interceptors/rate-limit":326,"./interceptors/redirect":327,"./interceptors/request-event":328,"./interceptors/request-logger":329,"./interceptors/request-timing":330,"./interceptors/response-logger":331,"./interceptors/spark-tracking-id":332,"./interceptors/spark-user-agent":333,"./lib/batcher":334,"./lib/credentials":337,"./lib/page":341,"./lib/spark-http-error":343,"./lib/spark-plugin":345,"./lib/storage":348,"./plugins/logger":352,"./spark-core":353,"dup":132}],323:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"@ciscospark/http-core":313,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":133}],324:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"@ciscospark/http-core":313,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":134}],325:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"@ciscospark/http-core":313,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":135}],326:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"@ciscospark/http-core":313,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":136}],327:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"@ciscospark/http-core":313,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":137,"lodash/clone":1611}],328:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"@ciscospark/http-core":313,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":138,"lodash/get":1636}],329:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"@ciscospark/http-core":313,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":139,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isString":1662,"lodash/omit":1679,"util":1769}],330:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"@ciscospark/http-core":313,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":140}],331:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"../../../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":1740,"@ciscospark/http-core":313,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":141,"lodash/get":1636,"lodash/omit":1679,"util":1769}],332:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"@ciscospark/http-core":313,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":142}],333:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"@ciscospark/common":302,"@ciscospark/http-core":313,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":143,"lodash/get":1636}],334:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"./spark-http-error":343,"./spark-plugin":345,"@ciscospark/common":302,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"dup":144,"lodash/has":1638}],335:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"../spark-plugin":345,"../storage/decorators":346,"./grant-errors":336,"./scope":338,"./token":340,"./token-collection":339,"@ciscospark/common":302,"@ciscospark/common-timers":41,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"dup":145,"lodash/clone":1611,"lodash/cloneDeep":1612,"lodash/isEmpty":1653,"lodash/isObject":1659,"querystring":1747,"url":1765}],336:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"@ciscospark/common":302,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":146}],337:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"../../spark-core":353,"./credentials":335,"./grant-errors":336,"./scope":338,"./token":340,"dup":147}],338:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"dup":148}],339:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"./token":340,"ampersand-collection":355,"dup":149}],340:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"../spark-http-error":343,"../spark-plugin":345,"./grant-errors":336,"./scope":338,"@ciscospark/common":302,"@ciscospark/common-timers":41,"_process":1743,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/slicedToArray":709,"dup":150,"lodash/pick":1685}],341:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"babel-runtime/core-js/symbol/iterator":702,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":151}],342:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":152,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],343:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"@ciscospark/http-core":313,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":153}],344:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":154,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],345:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"./storage":348,"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":155,"lodash/cloneDeep":1612,"lodash/isObject":1659,"lodash/omit":1679,"util":1769}],346:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"./errors":347,"@ciscospark/common":302,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/set":700,"babel-runtime/helpers/defineProperty":706,"babel-runtime/helpers/toConsumableArray":710,"babel-runtime/helpers/typeof":711,"dup":156,"lodash/curry":1615,"lodash/debounce":1617,"lodash/identity":1641,"lodash/result":1692,"lodash/wrap":1715}],347:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"@ciscospark/common":302,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":157}],348:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"./decorators":346,"./errors":347,"./make-spark-plugin-store.js":349,"./make-spark-store.js":350,"./memory-store-adapter":351,"dup":158}],349:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"./errors":347,"@ciscospark/common":302,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":159,"lodash/isArray":1648,"lodash/isObject":1659,"lodash/result":1692}],350:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"@ciscospark/common":302,"ampersand-events":673,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":160}],351:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"./errors":347,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"dup":161}],352:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"../lib/spark-plugin":345,"../spark-core":353,"_process":1743,"dup":162}],353:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./config":321,"./interceptors/auth":323,"./interceptors/network-timing":324,"./interceptors/payload-transformer":325,"./interceptors/rate-limit":326,"./interceptors/redirect":327,"./interceptors/request-event":328,"./interceptors/request-logger":329,"./interceptors/request-timing":330,"./interceptors/response-logger":331,"./interceptors/spark-tracking-id":332,"./interceptors/spark-user-agent":333,"./lib/spark-core-plugin-mixin":342,"./lib/spark-http-error":343,"./lib/spark-internal-core-plugin-mixin":344,"./lib/storage":348,"./spark-internal-core":354,"@ciscospark/common":302,"@ciscospark/http-core":313,"_process":1743,"ampersand-state":675,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/toConsumableArray":710,"dup":163,"events":1737,"lodash/defaults":1618,"lodash/get":1636,"lodash/has":1638,"lodash/isFunction":1656,"lodash/isString":1662,"lodash/last":1669,"lodash/merge":1674,"lodash/omit":1679,"lodash/set":1694,"lodash/unset":1712,"util":1769,"uuid":381}],354:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"dup":164,"util":1769}],355:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"ampersand-class-extend":671,"ampersand-events":673,"dup":165,"lodash/assign":1606,"lodash/bind":1610,"lodash/isArray":1648}],356:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],357:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./private/utils":370,"dup":22}],358:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./applyDecorators":356,"./autobind":357,"./debounce":359,"./decorate":360,"./deprecate":361,"./enumerable":362,"./extendDescriptor":363,"./lazy-initialize":364,"./memoize":365,"./mixin":366,"./nonconfigurable":367,"./nonenumerable":368,"./override":369,"./profile":371,"./readonly":372,"./suppress-warnings":373,"./throttle":374,"./time":375,"dup":23}],359:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./private/utils":370,"dup":24}],360:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"./private/utils":370,"dup":25}],361:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./private/utils":370,"dup":26}],362:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./private/utils":370,"dup":27}],363:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./private/utils":370,"dup":28}],364:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./private/utils":370,"dup":29}],365:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./private/utils":370,"dup":30}],366:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./private/utils":370,"dup":31}],367:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./private/utils":370,"dup":32}],368:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./private/utils":370,"dup":33}],369:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./private/utils":370,"dup":34}],370:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"../lazy-initialize":364,"dup":35}],371:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./private/utils":370,"dup":36}],372:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./private/utils":370,"dup":37}],373:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./private/utils":370,"dup":38}],374:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./private/utils":370,"dup":39}],375:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./private/utils":370,"dup":40}],376:[function(require,module,exports){
arguments[4][186][0].apply(exports,arguments)
},{"dup":186}],377:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./formats":376,"./parse":378,"./stringify":379,"dup":187}],378:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"./utils":380,"dup":188}],379:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"./formats":376,"./utils":380,"dup":189}],380:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],381:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"./v1":384,"./v4":385,"dup":191}],382:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"dup":192}],383:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"dup":193}],384:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./lib/bytesToUuid":382,"./lib/rng":383,"dup":194}],385:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"./lib/bytesToUuid":382,"./lib/rng":383,"dup":195}],386:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

var _teamMemberships = require('./team-memberships');

var _teamMemberships2 = _interopRequireDefault(_teamMemberships);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

(0, _sparkCore.registerPlugin)('teamMemberships', _teamMemberships2.default);

exports.default = _teamMemberships2.default;


},{"./team-memberships":387,"@ciscospark/spark-core":417}],387:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

/**
 * @typedef {Object} TeamMembershipObject
 * @property {string} id - (server generated) Unique identifier for the team membership
 * @property {string} teamId - The team ID
 * @property {string} personId - The person ID
 * @property {string} personEmail - The email address of the person
 * @property {boolean} isModerator - Set to `true` to make the person a team
 * moderator
 * @property {string} created - (server generated) The date and time that the team membership was created
 */

/**
 * Team Memberships represent a person's relationship to a team. Use this API to
 * list members of any team that you're in or create memberships to invite
 * someone to a team. Team memberships can also be updated to make someome a
 * moderator or deleted to remove them from the team.
 *
 * Just like in the Spark app, you must be a member of the team in order to list
 * its memberships or invite people.
 * @class
 */
var TeamMemberships = _sparkCore.SparkPlugin.extend({
  /**
   * Add someone to a team by Person ID or email address; optionally making them
   * a moderator.
   * @instance
   * @memberof TeamMemberships
   * @param {TeamMembershipObject} membership
   * @returns {Promise<TeamMembershipObject>}
   * @example
   * ciscospark.teams.create({name: 'Create Team Membership Example'})
   *   .then(function(team) {
   *     return ciscospark.teamMemberships.create({
   *      personEmail: 'alice@example.com',
   *      teamId: team.id
   *    });
   *   })
   *   .then(function(membership) {
   *     var assert = require('assert');
   *     assert(membership.id);
   *     assert(membership.teamId);
   *     assert(membership.personId);
   *     assert(membership.personEmail);
   *     assert('isModerator' in membership);
   *     assert(membership.created);
   *     return 'success';
   *   });
   *   // => success
   */
  create: function create(membership) {
    return this.request({
      method: 'POST',
      service: 'hydra',
      resource: 'team/memberships',
      body: membership
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Get details for a membership by ID.
   * @instance
   * @memberof TeamMemberships
   * @param {TeamMembershipObject|string} membership
   * @returns {Promise<TeamMembershipObject>}
   * @example
   * var membership;
   * ciscospark.teams.create({name: 'Get Team Memberships Example'})
   *   .then(function(team) {
   *     return ciscospark.teamMemberships.create({
   *       personEmail: 'alice@example.com',
   *       teamId: team.id
   *     });
   *   })
   *   .then(function(m) {
   *     membership = m;
   *     return ciscospark.teamMemberships.get(m.id);
   *   })
   *   .then(function(m) {
   *     var assert = require('assert');
   *     assert.deepEqual(m, membership);
   *     return 'success';
   *   });
   *   // => success
   */
  get: function get(membership) {
    var id = membership.id || membership;
    return this.request({
      service: 'hydra',
      resource: 'team/memberships/' + id
    }).then(function (res) {
      return res.body.items || res.body;
    });
  },


  /**
   * Lists all team memberships. By default, lists memberships for teams to
   * which the authenticated user belongs.
   * @instance
   * @memberof TeamMemberships
   * @param {Object} options
   * @param {string} options.max
   * @returns {[type]}
   * @example
   * var team;
   * ciscospark.teams.create({name: 'List Team Memberships Example'})
   *   .then(function(t) {
   *     team = t;
   *     return ciscospark.teamMemberships.create({
   *      personEmail: 'alice@example.com',
   *      teamId: team.id
   *     });
   *   })
   *   .then(function() {
   *     return ciscospark.teamMemberships.list({teamId: team.id});
   *   })
   *   .then(function(teamMemberships) {
   *     var assert = require('assert');
   *     assert.equal(teamMemberships.length, 2);
   *     for (var i = 0; i < teamMemberships.length; i+= 1) {
   *       assert.equal(teamMemberships.items[i].teamId, team.id);
   *     }
   *     return 'success';
   *   });
   *   // => success
   */
  list: function list(options) {
    var _this = this;

    return this.request({
      service: 'hydra',
      resource: 'team/memberships',
      qs: options
    }).then(function (res) {
      return new _sparkCore.Page(res, _this.spark);
    });
  },


  /**
   * Deletes a membership by ID.
   * @instance
   * @memberof TeamMemberships
   * @param {TeamMembershipObject|string} membership
   * @returns {Promise}
   * @example
   * var membership, team;
   * ciscospark.teams.create({name: 'Remove Team Memberships Example'})
   *   .then(function(t) {
   *     team = t;
   *     return ciscospark.teamMemberships.create({
   *      personEmail: 'alice@example.com',
   *      teamId: team.id
   *     });
   *   })
   *   .then(function(m) {
   *     membership = m;
   *     return ciscospark.teamMemberships.list({teamId: team.id});
   *   })
   *   .then(function(teamMemberships) {
   *     var assert = require('assert');
   *     assert.equal(teamMemberships.length, 2);
   *     return ciscospark.teamMemberships.remove(membership);
   *   })
   *   .then(function() {
   *     return ciscospark.teamMemberships.list({teamId: team.id});
   *   })
   *   .then(function(teamMemberships) {
   *     var assert = require('assert');
   *     assert.equal(teamMemberships.length, 1);
   *     return 'success';
   *   });
   *   // => success
   */
  remove: function remove(membership) {
    var id = membership.id || membership;

    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: 'team/memberships/' + id
    }).then(function (res) {
      // Firefox has some issues with 204s and/or DELETE. This should move to
      // http-core
      if (res.statusCode === 204) {
        return undefined;
      }
      return res.body;
    });
  },


  /**
   * Updates properties for a membership.
   * @instance
   * @memberof TeamMemberships
   * @param {TeamMembershipObject} membership
   * @returns {Promise<TeamMembershipObject>}
   */
  update: function update(membership) {
    var id = membership.id || membership;
    return this.request({
      method: 'PUT',
      service: 'hydra',
      resource: 'team/memberships/' + id,
      body: membership
    }).then(function (res) {
      return res.body;
    });
  },
  version: '1.32.5'
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = TeamMemberships;


},{"@ciscospark/spark-core":417}],388:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"buffer":1735,"dup":3,"urlsafe-base64":1730}],389:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":4}],390:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],391:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":6}],392:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"_process":1743,"core-decorators":453,"dup":7}],393:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":8,"lodash/isArray":1648}],394:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"babel-runtime/core-js/array/from":678,"babel-runtime/core-js/object/create":685,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/set-prototype-of":692,"babel-runtime/core-js/reflect/construct":696,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":9}],395:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],396:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./node":395,"dup":11}],397:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./base64":388,"./capped-debounce":389,"./check-required":390,"./defer":391,"./deprecated":392,"./events":393,"./exception":394,"./in-browser":396,"./make-state-datatype":398,"./one-flight":399,"./patterns.js":400,"./resolve-with":401,"./retry":402,"./tap":403,"./template-container":404,"./while-in-flight":405,"dup":12}],398:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],399:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./template-container":404,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/typeof":711,"dup":14,"lodash/wrap":1715}],400:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],401:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":16}],402:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/typeof":711,"backoff":712,"dup":17,"events":1737,"lodash/defaults":1618,"lodash/isFunction":1656,"lodash/wrap":1715}],403:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":18}],404:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":19,"util":1769}],405:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./tap":403,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":20,"lodash/wrap":1715}],406:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":121}],407:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"./http-error-subtypes":406,"@ciscospark/common":397,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/values":693,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":122,"lodash/pick":1685}],408:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./http-error":407,"./interceptors/http-status":409,"./lib/detect":410,"./lib/interceptor":411,"./progress-event":413,"./request":414,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/reflect/get-own-property-descriptor":699,"dup":123,"lodash/assign":1606,"lodash/curry":1615,"lodash/defaults":1618,"lodash/isString":1662}],409:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"../http-error":407,"../lib/interceptor":411,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":124}],410:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"@ciscospark/common":397,"babel-runtime/core-js/promise":694,"dup":125,"file-type":1309}],411:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":126}],412:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"babel-runtime/core-js/json/stringify":681,"dup":127,"global/window":1311,"is-function":1312,"parse-headers":1717,"xtend":1732}],413:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"babel-runtime/core-js/number/is-nan":683,"babel-runtime/core-js/object/define-properties":686,"dup":128,"lodash/isNumber":1658}],414:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"./request":415,"@ciscospark/common":397,"babel-runtime/core-js/promise":694,"dup":129,"events":1737}],415:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"../lib/detect":410,"../lib/xhr":412,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/typeof":711,"dup":130,"lodash/defaults":1618,"lodash/isArray":1648,"lodash/pick":1685,"qs":472}],416:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./lib/storage":443,"_process":1743,"dup":131}],417:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./config":416,"./interceptors/auth":418,"./interceptors/network-timing":419,"./interceptors/payload-transformer":420,"./interceptors/rate-limit":421,"./interceptors/redirect":422,"./interceptors/request-event":423,"./interceptors/request-logger":424,"./interceptors/request-timing":425,"./interceptors/response-logger":426,"./interceptors/spark-tracking-id":427,"./interceptors/spark-user-agent":428,"./lib/batcher":429,"./lib/credentials":432,"./lib/page":436,"./lib/spark-http-error":438,"./lib/spark-plugin":440,"./lib/storage":443,"./plugins/logger":447,"./spark-core":448,"dup":132}],418:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"@ciscospark/http-core":408,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":133}],419:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"@ciscospark/http-core":408,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":134}],420:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"@ciscospark/http-core":408,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":135}],421:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"@ciscospark/http-core":408,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":136}],422:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"@ciscospark/http-core":408,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":137,"lodash/clone":1611}],423:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"@ciscospark/http-core":408,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":138,"lodash/get":1636}],424:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"@ciscospark/http-core":408,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":139,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isString":1662,"lodash/omit":1679,"util":1769}],425:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"@ciscospark/http-core":408,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":140}],426:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"../../../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":1740,"@ciscospark/http-core":408,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":141,"lodash/get":1636,"lodash/omit":1679,"util":1769}],427:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"@ciscospark/http-core":408,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":142}],428:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"@ciscospark/common":397,"@ciscospark/http-core":408,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":143,"lodash/get":1636}],429:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"./spark-http-error":438,"./spark-plugin":440,"@ciscospark/common":397,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"dup":144,"lodash/has":1638}],430:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"../spark-plugin":440,"../storage/decorators":441,"./grant-errors":431,"./scope":433,"./token":435,"./token-collection":434,"@ciscospark/common":397,"@ciscospark/common-timers":41,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"dup":145,"lodash/clone":1611,"lodash/cloneDeep":1612,"lodash/isEmpty":1653,"lodash/isObject":1659,"querystring":1747,"url":1765}],431:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"@ciscospark/common":397,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":146}],432:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"../../spark-core":448,"./credentials":430,"./grant-errors":431,"./scope":433,"./token":435,"dup":147}],433:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"dup":148}],434:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"./token":435,"ampersand-collection":450,"dup":149}],435:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"../spark-http-error":438,"../spark-plugin":440,"./grant-errors":431,"./scope":433,"@ciscospark/common":397,"@ciscospark/common-timers":41,"_process":1743,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/slicedToArray":709,"dup":150,"lodash/pick":1685}],436:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"babel-runtime/core-js/symbol/iterator":702,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":151}],437:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":152,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],438:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"@ciscospark/http-core":408,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":153}],439:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":154,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],440:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"./storage":443,"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":155,"lodash/cloneDeep":1612,"lodash/isObject":1659,"lodash/omit":1679,"util":1769}],441:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"./errors":442,"@ciscospark/common":397,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/set":700,"babel-runtime/helpers/defineProperty":706,"babel-runtime/helpers/toConsumableArray":710,"babel-runtime/helpers/typeof":711,"dup":156,"lodash/curry":1615,"lodash/debounce":1617,"lodash/identity":1641,"lodash/result":1692,"lodash/wrap":1715}],442:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"@ciscospark/common":397,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":157}],443:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"./decorators":441,"./errors":442,"./make-spark-plugin-store.js":444,"./make-spark-store.js":445,"./memory-store-adapter":446,"dup":158}],444:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"./errors":442,"@ciscospark/common":397,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":159,"lodash/isArray":1648,"lodash/isObject":1659,"lodash/result":1692}],445:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"@ciscospark/common":397,"ampersand-events":673,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":160}],446:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"./errors":442,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"dup":161}],447:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"../lib/spark-plugin":440,"../spark-core":448,"_process":1743,"dup":162}],448:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./config":416,"./interceptors/auth":418,"./interceptors/network-timing":419,"./interceptors/payload-transformer":420,"./interceptors/rate-limit":421,"./interceptors/redirect":422,"./interceptors/request-event":423,"./interceptors/request-logger":424,"./interceptors/request-timing":425,"./interceptors/response-logger":426,"./interceptors/spark-tracking-id":427,"./interceptors/spark-user-agent":428,"./lib/spark-core-plugin-mixin":437,"./lib/spark-http-error":438,"./lib/spark-internal-core-plugin-mixin":439,"./lib/storage":443,"./spark-internal-core":449,"@ciscospark/common":397,"@ciscospark/http-core":408,"_process":1743,"ampersand-state":675,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/toConsumableArray":710,"dup":163,"events":1737,"lodash/defaults":1618,"lodash/get":1636,"lodash/has":1638,"lodash/isFunction":1656,"lodash/isString":1662,"lodash/last":1669,"lodash/merge":1674,"lodash/omit":1679,"lodash/set":1694,"lodash/unset":1712,"util":1769,"uuid":476}],449:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"dup":164,"util":1769}],450:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"ampersand-class-extend":671,"ampersand-events":673,"dup":165,"lodash/assign":1606,"lodash/bind":1610,"lodash/isArray":1648}],451:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],452:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./private/utils":465,"dup":22}],453:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./applyDecorators":451,"./autobind":452,"./debounce":454,"./decorate":455,"./deprecate":456,"./enumerable":457,"./extendDescriptor":458,"./lazy-initialize":459,"./memoize":460,"./mixin":461,"./nonconfigurable":462,"./nonenumerable":463,"./override":464,"./profile":466,"./readonly":467,"./suppress-warnings":468,"./throttle":469,"./time":470,"dup":23}],454:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./private/utils":465,"dup":24}],455:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"./private/utils":465,"dup":25}],456:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./private/utils":465,"dup":26}],457:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./private/utils":465,"dup":27}],458:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./private/utils":465,"dup":28}],459:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./private/utils":465,"dup":29}],460:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./private/utils":465,"dup":30}],461:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./private/utils":465,"dup":31}],462:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./private/utils":465,"dup":32}],463:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./private/utils":465,"dup":33}],464:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./private/utils":465,"dup":34}],465:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"../lazy-initialize":459,"dup":35}],466:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./private/utils":465,"dup":36}],467:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./private/utils":465,"dup":37}],468:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./private/utils":465,"dup":38}],469:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./private/utils":465,"dup":39}],470:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./private/utils":465,"dup":40}],471:[function(require,module,exports){
arguments[4][186][0].apply(exports,arguments)
},{"dup":186}],472:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./formats":471,"./parse":473,"./stringify":474,"dup":187}],473:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"./utils":475,"dup":188}],474:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"./formats":471,"./utils":475,"dup":189}],475:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],476:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"./v1":479,"./v4":480,"dup":191}],477:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"dup":192}],478:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"dup":193}],479:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./lib/bytesToUuid":477,"./lib/rng":478,"dup":194}],480:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"./lib/bytesToUuid":477,"./lib/rng":478,"dup":195}],481:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

var _teams = require('./teams');

var _teams2 = _interopRequireDefault(_teams);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

(0, _sparkCore.registerPlugin)('teams', _teams2.default);

exports.default = _teams2.default;


},{"./teams":482,"@ciscospark/spark-core":512}],482:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

/**
 * @typedef {Object} TeamObject
 * @property {string} id - (server generated) Unique identifier for the team
 * @property {string} name - The name of the team
 * @property {isoDate} created - (server generated) The date and time that the
 * team was created
 */

/**
* @class
 */
var Teams = _sparkCore.SparkPlugin.extend({
  /**
   * Create a new team.
   * @instance
   * @param {TeamObject} team
   * @returns {Promise<TeamObject>}
   * @memberof Teams
   * @example
   * ciscospark.teams.create({name: 'Create Team Example'})
   *   .then(function(team) {
   *     var assert = require('assert');
   *     assert(team.id);
   *     assert(team.name);
   *     assert(team.created);
   *     return 'success';
   *   });
   *   // => success
   */
  create: function create(team) {
    return this.request({
      method: 'POST',
      service: 'hydra',
      resource: 'teams',
      body: team
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Returns a single team
   * @instance
   * @param {TeamObject|string} team
   * @param {Object} options
   * @returns {Promise<TeamObject>}
   * @memberof Teams
   * @example
   * var team;
   * ciscospark.teams.create({name: 'Get Team Example'})
   *   .then(function(r) {
   *     team = r;
   *     return ciscospark.teams.get(team.id);
   *   })
   *   .then(function(team2) {
   *     var assert = require('assert');
   *     assert.equal(team2.id, team.id);
   *     return 'success';
   *   });
   *   // => success
   */
  get: function get(team, options) {
    var id = team.id || team;

    return this.request({
      service: 'hydra',
      resource: 'teams/' + id,
      qs: options
    }).then(function (res) {
      return res.body.items || res.body;
    });
  },


  /**
   * List teams.
   * @instance
   * @param {object} options
   * @param {object} options.max Limit the maximum number of teams in the
   * response.
   * @returns {Promise<Page<TeamObject>>}
   * @memberof Teams
   * @example
   * var createdRooms;
   * Promise.all([
   *   ciscospark.teams.create({name: 'List Teams Example 1'}),
   *   ciscospark.teams.create({name: 'List Teams Example 2'}),
   *   ciscospark.teams.create({name: 'List Teams Example 3'})
   * ])
   *   .then(function(r) {
   *     createdRooms = r;
   *     return ciscospark.teams.list({max: 3});
   *   })
   *   .then(function(teams) {
   *     var assert = require('assert');
   *     assert(teams.length === 3);
   *     for (var i = 0; i < teams.items.length; i+= 1) {
   *       assert(createdRooms.filter(function(room) {
   *         return room.id === teams.items[i].id;
   *       }).length === 1);
   *     }
   *     return 'success';
   *   });
   *   // => success
   */
  list: function list(options) {
    var _this = this;

    return this.request({
      service: 'hydra',
      resource: 'teams/',
      qs: options
    }).then(function (res) {
      return new _sparkCore.Page(res, _this.spark);
    });
  },


  /**
   * Update a team.
   * @instance
   * @param {TeamObject} team
   * @returns {Promise<TeamObject>}
   * @memberof Teams
   * @example
   * var teams;
   * ciscospark.teams.create({name: 'Update Team Example'})
   *   .then(function(r) {
   *     teams = r;
   *     teams.name = 'Teams Example (Updated Title)';
   *     return ciscospark.teams.update(teams);
   *   })
   *   .then(function() {
   *     return ciscospark.teams.get(teams.id);
   *   })
   *   .then(function(teams) {
   *     var assert = require('assert');
   *     assert.equal(teams.name, 'Teams Example (Updated Title)');
   *     return 'success';
   *   });
   *   // => success
    */
  update: function update(team) {
    var id = team.id;
    return this.request({
      method: 'PUT',
      service: 'hydra',
      resource: 'teams/' + id,
      body: team
    }).then(function (res) {
      return res.body;
    });
  },
  version: '1.32.5'
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = Teams;


},{"@ciscospark/spark-core":512}],483:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"buffer":1735,"dup":3,"urlsafe-base64":1730}],484:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":4}],485:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],486:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":6}],487:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"_process":1743,"core-decorators":548,"dup":7}],488:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":8,"lodash/isArray":1648}],489:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"babel-runtime/core-js/array/from":678,"babel-runtime/core-js/object/create":685,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/set-prototype-of":692,"babel-runtime/core-js/reflect/construct":696,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":9}],490:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],491:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./node":490,"dup":11}],492:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./base64":483,"./capped-debounce":484,"./check-required":485,"./defer":486,"./deprecated":487,"./events":488,"./exception":489,"./in-browser":491,"./make-state-datatype":493,"./one-flight":494,"./patterns.js":495,"./resolve-with":496,"./retry":497,"./tap":498,"./template-container":499,"./while-in-flight":500,"dup":12}],493:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],494:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./template-container":499,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/typeof":711,"dup":14,"lodash/wrap":1715}],495:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],496:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":16}],497:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/typeof":711,"backoff":712,"dup":17,"events":1737,"lodash/defaults":1618,"lodash/isFunction":1656,"lodash/wrap":1715}],498:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":18}],499:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":19,"util":1769}],500:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./tap":498,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":20,"lodash/wrap":1715}],501:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":121}],502:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"./http-error-subtypes":501,"@ciscospark/common":492,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/values":693,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":122,"lodash/pick":1685}],503:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./http-error":502,"./interceptors/http-status":504,"./lib/detect":505,"./lib/interceptor":506,"./progress-event":508,"./request":509,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/reflect/get-own-property-descriptor":699,"dup":123,"lodash/assign":1606,"lodash/curry":1615,"lodash/defaults":1618,"lodash/isString":1662}],504:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"../http-error":502,"../lib/interceptor":506,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":124}],505:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"@ciscospark/common":492,"babel-runtime/core-js/promise":694,"dup":125,"file-type":1309}],506:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":126}],507:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"babel-runtime/core-js/json/stringify":681,"dup":127,"global/window":1311,"is-function":1312,"parse-headers":1717,"xtend":1732}],508:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"babel-runtime/core-js/number/is-nan":683,"babel-runtime/core-js/object/define-properties":686,"dup":128,"lodash/isNumber":1658}],509:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"./request":510,"@ciscospark/common":492,"babel-runtime/core-js/promise":694,"dup":129,"events":1737}],510:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"../lib/detect":505,"../lib/xhr":507,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/typeof":711,"dup":130,"lodash/defaults":1618,"lodash/isArray":1648,"lodash/pick":1685,"qs":567}],511:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./lib/storage":538,"_process":1743,"dup":131}],512:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./config":511,"./interceptors/auth":513,"./interceptors/network-timing":514,"./interceptors/payload-transformer":515,"./interceptors/rate-limit":516,"./interceptors/redirect":517,"./interceptors/request-event":518,"./interceptors/request-logger":519,"./interceptors/request-timing":520,"./interceptors/response-logger":521,"./interceptors/spark-tracking-id":522,"./interceptors/spark-user-agent":523,"./lib/batcher":524,"./lib/credentials":527,"./lib/page":531,"./lib/spark-http-error":533,"./lib/spark-plugin":535,"./lib/storage":538,"./plugins/logger":542,"./spark-core":543,"dup":132}],513:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"@ciscospark/http-core":503,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":133}],514:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"@ciscospark/http-core":503,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":134}],515:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"@ciscospark/http-core":503,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":135}],516:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"@ciscospark/http-core":503,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":136}],517:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"@ciscospark/http-core":503,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":137,"lodash/clone":1611}],518:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"@ciscospark/http-core":503,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":138,"lodash/get":1636}],519:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"@ciscospark/http-core":503,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":139,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isString":1662,"lodash/omit":1679,"util":1769}],520:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"@ciscospark/http-core":503,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":140}],521:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"../../../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":1740,"@ciscospark/http-core":503,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":141,"lodash/get":1636,"lodash/omit":1679,"util":1769}],522:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"@ciscospark/http-core":503,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":142}],523:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"@ciscospark/common":492,"@ciscospark/http-core":503,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":143,"lodash/get":1636}],524:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"./spark-http-error":533,"./spark-plugin":535,"@ciscospark/common":492,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"dup":144,"lodash/has":1638}],525:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"../spark-plugin":535,"../storage/decorators":536,"./grant-errors":526,"./scope":528,"./token":530,"./token-collection":529,"@ciscospark/common":492,"@ciscospark/common-timers":41,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"dup":145,"lodash/clone":1611,"lodash/cloneDeep":1612,"lodash/isEmpty":1653,"lodash/isObject":1659,"querystring":1747,"url":1765}],526:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"@ciscospark/common":492,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":146}],527:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"../../spark-core":543,"./credentials":525,"./grant-errors":526,"./scope":528,"./token":530,"dup":147}],528:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"dup":148}],529:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"./token":530,"ampersand-collection":545,"dup":149}],530:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"../spark-http-error":533,"../spark-plugin":535,"./grant-errors":526,"./scope":528,"@ciscospark/common":492,"@ciscospark/common-timers":41,"_process":1743,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/slicedToArray":709,"dup":150,"lodash/pick":1685}],531:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"babel-runtime/core-js/symbol/iterator":702,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":151}],532:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":152,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],533:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"@ciscospark/http-core":503,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":153}],534:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":154,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],535:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"./storage":538,"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":155,"lodash/cloneDeep":1612,"lodash/isObject":1659,"lodash/omit":1679,"util":1769}],536:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"./errors":537,"@ciscospark/common":492,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/set":700,"babel-runtime/helpers/defineProperty":706,"babel-runtime/helpers/toConsumableArray":710,"babel-runtime/helpers/typeof":711,"dup":156,"lodash/curry":1615,"lodash/debounce":1617,"lodash/identity":1641,"lodash/result":1692,"lodash/wrap":1715}],537:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"@ciscospark/common":492,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":157}],538:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"./decorators":536,"./errors":537,"./make-spark-plugin-store.js":539,"./make-spark-store.js":540,"./memory-store-adapter":541,"dup":158}],539:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"./errors":537,"@ciscospark/common":492,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":159,"lodash/isArray":1648,"lodash/isObject":1659,"lodash/result":1692}],540:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"@ciscospark/common":492,"ampersand-events":673,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":160}],541:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"./errors":537,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"dup":161}],542:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"../lib/spark-plugin":535,"../spark-core":543,"_process":1743,"dup":162}],543:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./config":511,"./interceptors/auth":513,"./interceptors/network-timing":514,"./interceptors/payload-transformer":515,"./interceptors/rate-limit":516,"./interceptors/redirect":517,"./interceptors/request-event":518,"./interceptors/request-logger":519,"./interceptors/request-timing":520,"./interceptors/response-logger":521,"./interceptors/spark-tracking-id":522,"./interceptors/spark-user-agent":523,"./lib/spark-core-plugin-mixin":532,"./lib/spark-http-error":533,"./lib/spark-internal-core-plugin-mixin":534,"./lib/storage":538,"./spark-internal-core":544,"@ciscospark/common":492,"@ciscospark/http-core":503,"_process":1743,"ampersand-state":675,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/toConsumableArray":710,"dup":163,"events":1737,"lodash/defaults":1618,"lodash/get":1636,"lodash/has":1638,"lodash/isFunction":1656,"lodash/isString":1662,"lodash/last":1669,"lodash/merge":1674,"lodash/omit":1679,"lodash/set":1694,"lodash/unset":1712,"util":1769,"uuid":571}],544:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"dup":164,"util":1769}],545:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"ampersand-class-extend":671,"ampersand-events":673,"dup":165,"lodash/assign":1606,"lodash/bind":1610,"lodash/isArray":1648}],546:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],547:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./private/utils":560,"dup":22}],548:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./applyDecorators":546,"./autobind":547,"./debounce":549,"./decorate":550,"./deprecate":551,"./enumerable":552,"./extendDescriptor":553,"./lazy-initialize":554,"./memoize":555,"./mixin":556,"./nonconfigurable":557,"./nonenumerable":558,"./override":559,"./profile":561,"./readonly":562,"./suppress-warnings":563,"./throttle":564,"./time":565,"dup":23}],549:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./private/utils":560,"dup":24}],550:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"./private/utils":560,"dup":25}],551:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./private/utils":560,"dup":26}],552:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./private/utils":560,"dup":27}],553:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./private/utils":560,"dup":28}],554:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./private/utils":560,"dup":29}],555:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./private/utils":560,"dup":30}],556:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./private/utils":560,"dup":31}],557:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./private/utils":560,"dup":32}],558:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./private/utils":560,"dup":33}],559:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./private/utils":560,"dup":34}],560:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"../lazy-initialize":554,"dup":35}],561:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./private/utils":560,"dup":36}],562:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./private/utils":560,"dup":37}],563:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./private/utils":560,"dup":38}],564:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./private/utils":560,"dup":39}],565:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./private/utils":560,"dup":40}],566:[function(require,module,exports){
arguments[4][186][0].apply(exports,arguments)
},{"dup":186}],567:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./formats":566,"./parse":568,"./stringify":569,"dup":187}],568:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"./utils":570,"dup":188}],569:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"./formats":566,"./utils":570,"dup":189}],570:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],571:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"./v1":574,"./v4":575,"dup":191}],572:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"dup":192}],573:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"dup":193}],574:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./lib/bytesToUuid":572,"./lib/rng":573,"dup":194}],575:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"./lib/bytesToUuid":572,"./lib/rng":573,"dup":195}],576:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

var _webhooks = require('./webhooks');

var _webhooks2 = _interopRequireDefault(_webhooks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

(0, _sparkCore.registerPlugin)('webhooks', _webhooks2.default);

exports.default = _webhooks2.default;


},{"./webhooks":577,"@ciscospark/spark-core":607}],577:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

/**
 * @typedef {Object} WebhookObject
 * @property {string} id - (server generated) Unique identifier for the webhook
 * @property {string} resource - The resource type for the webhook
 * @property {string} event - The event type for the webhook
 * @property {string} filter - The filter that defines the webhook scope
 * @property {string} targetUrl - The URL that receives POST requests for each event
 * @property {string} name - A user-friendly name for this webhook
 * @property {string} created - (server generated) The date and time that the webhook was created
 */

/**
 * Webhooks allow your app to be notified via HTTP when a specific event
 * occurs on Spark. For example, your app can register a webhook to be
 * notified when a new message is posted into a specific room.
 * @class
 */
var Webhooks = _sparkCore.SparkPlugin.extend({
  /**
   * Posts a webhook.
   * @instance
   * @memberof Webhooks
   * @param {WebhookObject} webhook
   * @returns {Promise<Webhook>}
   * @example
   * ciscospark.rooms.create({title: 'Create Webhook Example'})
   *   .then(function(room) {
   *     return ciscospark.webhooks.create({
   *       resource: 'messages',
   *       event: 'created',
   *       filter: 'roomId=' + room.id,
   *       targetUrl: 'https://example.com/webhook',
   *       name: 'Test Webhook'
   *     });
   *   })
   *   .then(function(webhook) {
   *     var assert = require('assert');
   *     assert(webhook.id);
   *     assert(webhook.resource);
   *     assert(webhook.event);
   *     assert(webhook.filter);
   *     assert(webhook.targetUrl);
   *     assert(webhook.name);
   *     return 'success';
   *   });
   *   // => success
   */
  create: function create(webhook) {
    return this.request({
      method: 'POST',
      service: 'hydra',
      resource: 'webhooks',
      body: webhook
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Shows details for a webhook.
   * @instance
   * @memberof Webhooks
   * @param {Webhook|string} webhook
   * @returns {Promise<Array<Webhook>>}
   * @example
   * var webhook;
   * ciscospark.rooms.create({title: 'Get Webhook Example'})
   *   .then(function(room) {
   *     return ciscospark.webhooks.create({
   *       resource: 'messages',
   *       event: 'created',
   *       filter: 'roomId=' + room.id,
   *       targetUrl: 'https://example.com/webhook',
   *       name: 'Test Webhook'
   *     });
   *   })
   *   .then(function(w) {
   *     webhook = w;
   *     return ciscospark.webhooks.get(webhook.id);
   *   })
   *   .then(function(webhook2) {
   *     var assert = require('assert');
   *     assert.deepEqual(webhook2, webhook);
   *     return 'success';
   *   });
   *   // => success
   */
  get: function get(webhook) {
    var id = webhook.id || webhook;

    return this.request({
      service: 'hydra',
      resource: 'webhooks/' + id
    }).then(function (res) {
      return res.body.items || res.body;
    });
  },


  /**
   * Lists all webhooks.
   * @instance
   * @memberof Webhooks
   * @param {Object} options
   * @param {integer} options.max Limit the maximum number of webhooks in the response.
   * @returns {Promise<Webhook>}
   * @example
   * var room, webhook;
   * ciscospark.rooms.create({title: 'List Webhooks Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.webhooks.create({
   *       resource: 'messages',
   *       event: 'created',
   *       filter: 'roomId=' + room.id,
   *       targetUrl: 'https://example.com/webhook',
   *       name: 'Test Webhook'
   *     });
   *   })
   *   .then(function(w) {
   *     webhook = w;
   *     return ciscospark.webhooks.list();
   *   })
   *   .then(function(webhooks) {
   *     var assert = require('assert');
   *     assert.equal(webhooks.items.filter(function(w) {
   *       return w.id === webhook.id;
   *     }).length, 1);
   *     return 'success';
   *   });
   *   // => success
   */
  list: function list(options) {
    var _this = this;

    return this.request({
      service: 'hydra',
      resource: 'webhooks/',
      qs: options
    }).then(function (res) {
      return new _sparkCore.Page(res, _this.spark);
    });
  },


  /**
   * Delete a webhook.
   * @instance
   * @memberof Webhooks
   * @param {Webhook|string} webhook
   * @returns {Promise}
   * @example
   * var room, webhook;
   * ciscospark.rooms.create({title: 'Remove Webhook Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.webhooks.create({
   *       resource: 'messages',
   *       event: 'created',
   *       filter: 'roomId=' + room.id,
   *       targetUrl: 'https://example.com/webhook',
   *       name: 'Test Webhook'
   *     });
   *   })
   *   .then(function(w) {
   *     webhook = w;
   *     return ciscospark.webhooks.remove(webhook);
   *   })
   *   .then(function() {
   *     return ciscospark.webhooks.list();
   *   })
   *   .then(function(webhooks) {
   *     var assert = require('assert');
   *     assert.equal(webhooks.items.filter(function(w) {
   *       return w.id === webhook.id;
   *     }).length, 0);
   *     return 'success';
   *   });
   *   // => success
   */
  remove: function remove(webhook) {
    var id = webhook.id || webhook;
    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: 'webhooks/' + id
    }).then(function (res) {
      // Firefox has some issues with 204s and/or DELETE. This should move to
      // http-core
      if (res.statusCode === 204) {
        return undefined;
      }
      return res.body;
    });
  },


  /**
   * Update a webhook.
   * @instance
   * @memberof Webhooks
   * @param {Webhook} webhook
   * @returns {Promise<Webhook>}
   * @example
   * var webhook;
   * ciscospark.rooms.create({title: 'Webhook Example'})
   *   .then(function(room) {
   *     return ciscospark.webhooks.create({
   *       resource: 'messages',
   *       event: 'created',
   *       filter: 'roomId=' + room.id,
   *       targetUrl: 'https://example.com/webhook',
   *       name: 'Test Webhook'
   *     });
   *   })
   *   .then(function(w) {
   *     webhook = w;
   *     webhook.targetUrl = 'https://example.com/webhook/newtarget';
   *     return ciscospark.webhooks.update(webhook);
   *   })
   *   .then(function() {
   *     return ciscospark.webhooks.get(webhook);
   *   })
   *   .then(function(webhook) {
   *     var assert = require('assert');
   *     assert.equal(webhook.targetUrl, 'https://example.com/webhook/newtarget');
   *     return 'success';
   *   });
   *   // => success
   */
  update: function update(webhook) {
    var id = webhook.id;
    return this.request({
      method: 'PUT',
      service: 'hydra',
      resource: 'webhooks/' + id,
      body: webhook
    }).then(function (res) {
      return res.body;
    });
  },
  version: '1.32.5'
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = Webhooks;


},{"@ciscospark/spark-core":607}],578:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"buffer":1735,"dup":3,"urlsafe-base64":1730}],579:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":4}],580:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],581:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":6}],582:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"_process":1743,"core-decorators":643,"dup":7}],583:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":8,"lodash/isArray":1648}],584:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"babel-runtime/core-js/array/from":678,"babel-runtime/core-js/object/create":685,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/set-prototype-of":692,"babel-runtime/core-js/reflect/construct":696,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":9}],585:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],586:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./node":585,"dup":11}],587:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./base64":578,"./capped-debounce":579,"./check-required":580,"./defer":581,"./deprecated":582,"./events":583,"./exception":584,"./in-browser":586,"./make-state-datatype":588,"./one-flight":589,"./patterns.js":590,"./resolve-with":591,"./retry":592,"./tap":593,"./template-container":594,"./while-in-flight":595,"dup":12}],588:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],589:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./template-container":594,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/typeof":711,"dup":14,"lodash/wrap":1715}],590:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],591:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":16}],592:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/typeof":711,"backoff":712,"dup":17,"events":1737,"lodash/defaults":1618,"lodash/isFunction":1656,"lodash/wrap":1715}],593:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":18}],594:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":19,"util":1769}],595:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./tap":593,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":20,"lodash/wrap":1715}],596:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":121}],597:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"./http-error-subtypes":596,"@ciscospark/common":587,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/values":693,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":122,"lodash/pick":1685}],598:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./http-error":597,"./interceptors/http-status":599,"./lib/detect":600,"./lib/interceptor":601,"./progress-event":603,"./request":604,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/reflect/get-own-property-descriptor":699,"dup":123,"lodash/assign":1606,"lodash/curry":1615,"lodash/defaults":1618,"lodash/isString":1662}],599:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"../http-error":597,"../lib/interceptor":601,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":124}],600:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"@ciscospark/common":587,"babel-runtime/core-js/promise":694,"dup":125,"file-type":1309}],601:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":126}],602:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"babel-runtime/core-js/json/stringify":681,"dup":127,"global/window":1311,"is-function":1312,"parse-headers":1717,"xtend":1732}],603:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"babel-runtime/core-js/number/is-nan":683,"babel-runtime/core-js/object/define-properties":686,"dup":128,"lodash/isNumber":1658}],604:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"./request":605,"@ciscospark/common":587,"babel-runtime/core-js/promise":694,"dup":129,"events":1737}],605:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"../lib/detect":600,"../lib/xhr":602,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/typeof":711,"dup":130,"lodash/defaults":1618,"lodash/isArray":1648,"lodash/pick":1685,"qs":662}],606:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./lib/storage":633,"_process":1743,"dup":131}],607:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./config":606,"./interceptors/auth":608,"./interceptors/network-timing":609,"./interceptors/payload-transformer":610,"./interceptors/rate-limit":611,"./interceptors/redirect":612,"./interceptors/request-event":613,"./interceptors/request-logger":614,"./interceptors/request-timing":615,"./interceptors/response-logger":616,"./interceptors/spark-tracking-id":617,"./interceptors/spark-user-agent":618,"./lib/batcher":619,"./lib/credentials":622,"./lib/page":626,"./lib/spark-http-error":628,"./lib/spark-plugin":630,"./lib/storage":633,"./plugins/logger":637,"./spark-core":638,"dup":132}],608:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"@ciscospark/http-core":598,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":133}],609:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"@ciscospark/http-core":598,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":134}],610:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"@ciscospark/http-core":598,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":135}],611:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"@ciscospark/http-core":598,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":136}],612:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"@ciscospark/http-core":598,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":137,"lodash/clone":1611}],613:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"@ciscospark/http-core":598,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":138,"lodash/get":1636}],614:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"@ciscospark/http-core":598,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":139,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isString":1662,"lodash/omit":1679,"util":1769}],615:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"@ciscospark/http-core":598,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":140}],616:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"../../../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":1740,"@ciscospark/http-core":598,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":141,"lodash/get":1636,"lodash/omit":1679,"util":1769}],617:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"@ciscospark/http-core":598,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":142}],618:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"@ciscospark/common":587,"@ciscospark/http-core":598,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":143,"lodash/get":1636}],619:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"./spark-http-error":628,"./spark-plugin":630,"@ciscospark/common":587,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"dup":144,"lodash/has":1638}],620:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"../spark-plugin":630,"../storage/decorators":631,"./grant-errors":621,"./scope":623,"./token":625,"./token-collection":624,"@ciscospark/common":587,"@ciscospark/common-timers":41,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"dup":145,"lodash/clone":1611,"lodash/cloneDeep":1612,"lodash/isEmpty":1653,"lodash/isObject":1659,"querystring":1747,"url":1765}],621:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"@ciscospark/common":587,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":146}],622:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"../../spark-core":638,"./credentials":620,"./grant-errors":621,"./scope":623,"./token":625,"dup":147}],623:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"dup":148}],624:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"./token":625,"ampersand-collection":640,"dup":149}],625:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"../spark-http-error":628,"../spark-plugin":630,"./grant-errors":621,"./scope":623,"@ciscospark/common":587,"@ciscospark/common-timers":41,"_process":1743,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/slicedToArray":709,"dup":150,"lodash/pick":1685}],626:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"babel-runtime/core-js/symbol/iterator":702,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":151}],627:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":152,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],628:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"@ciscospark/http-core":598,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":153}],629:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":154,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],630:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"./storage":633,"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":155,"lodash/cloneDeep":1612,"lodash/isObject":1659,"lodash/omit":1679,"util":1769}],631:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"./errors":632,"@ciscospark/common":587,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/set":700,"babel-runtime/helpers/defineProperty":706,"babel-runtime/helpers/toConsumableArray":710,"babel-runtime/helpers/typeof":711,"dup":156,"lodash/curry":1615,"lodash/debounce":1617,"lodash/identity":1641,"lodash/result":1692,"lodash/wrap":1715}],632:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"@ciscospark/common":587,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":157}],633:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"./decorators":631,"./errors":632,"./make-spark-plugin-store.js":634,"./make-spark-store.js":635,"./memory-store-adapter":636,"dup":158}],634:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"./errors":632,"@ciscospark/common":587,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":159,"lodash/isArray":1648,"lodash/isObject":1659,"lodash/result":1692}],635:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"@ciscospark/common":587,"ampersand-events":673,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":160}],636:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"./errors":632,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"dup":161}],637:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"../lib/spark-plugin":630,"../spark-core":638,"_process":1743,"dup":162}],638:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./config":606,"./interceptors/auth":608,"./interceptors/network-timing":609,"./interceptors/payload-transformer":610,"./interceptors/rate-limit":611,"./interceptors/redirect":612,"./interceptors/request-event":613,"./interceptors/request-logger":614,"./interceptors/request-timing":615,"./interceptors/response-logger":616,"./interceptors/spark-tracking-id":617,"./interceptors/spark-user-agent":618,"./lib/spark-core-plugin-mixin":627,"./lib/spark-http-error":628,"./lib/spark-internal-core-plugin-mixin":629,"./lib/storage":633,"./spark-internal-core":639,"@ciscospark/common":587,"@ciscospark/http-core":598,"_process":1743,"ampersand-state":675,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/toConsumableArray":710,"dup":163,"events":1737,"lodash/defaults":1618,"lodash/get":1636,"lodash/has":1638,"lodash/isFunction":1656,"lodash/isString":1662,"lodash/last":1669,"lodash/merge":1674,"lodash/omit":1679,"lodash/set":1694,"lodash/unset":1712,"util":1769,"uuid":666}],639:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"dup":164,"util":1769}],640:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"ampersand-class-extend":671,"ampersand-events":673,"dup":165,"lodash/assign":1606,"lodash/bind":1610,"lodash/isArray":1648}],641:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],642:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./private/utils":655,"dup":22}],643:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./applyDecorators":641,"./autobind":642,"./debounce":644,"./decorate":645,"./deprecate":646,"./enumerable":647,"./extendDescriptor":648,"./lazy-initialize":649,"./memoize":650,"./mixin":651,"./nonconfigurable":652,"./nonenumerable":653,"./override":654,"./profile":656,"./readonly":657,"./suppress-warnings":658,"./throttle":659,"./time":660,"dup":23}],644:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./private/utils":655,"dup":24}],645:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"./private/utils":655,"dup":25}],646:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./private/utils":655,"dup":26}],647:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./private/utils":655,"dup":27}],648:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./private/utils":655,"dup":28}],649:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./private/utils":655,"dup":29}],650:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./private/utils":655,"dup":30}],651:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./private/utils":655,"dup":31}],652:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./private/utils":655,"dup":32}],653:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./private/utils":655,"dup":33}],654:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./private/utils":655,"dup":34}],655:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"../lazy-initialize":649,"dup":35}],656:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./private/utils":655,"dup":36}],657:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./private/utils":655,"dup":37}],658:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./private/utils":655,"dup":38}],659:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./private/utils":655,"dup":39}],660:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./private/utils":655,"dup":40}],661:[function(require,module,exports){
arguments[4][186][0].apply(exports,arguments)
},{"dup":186}],662:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./formats":661,"./parse":663,"./stringify":664,"dup":187}],663:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"./utils":665,"dup":188}],664:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"./formats":661,"./utils":665,"dup":189}],665:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],666:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"./v1":669,"./v4":670,"dup":191}],667:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"dup":192}],668:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"dup":193}],669:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./lib/bytesToUuid":667,"./lib/rng":668,"dup":194}],670:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"./lib/bytesToUuid":667,"./lib/rng":668,"dup":195}],671:[function(require,module,exports){
var assign = require('lodash/assign');

/// Following code is largely pasted from Backbone.js

// Helper function to correctly set up the prototype chain, for subclasses.
// Similar to `goog.inherits`, but uses a hash of prototype properties and
// class properties to be extended.
var extend = function(protoProps) {
    var parent = this;
    var child;
    var args = [].slice.call(arguments);

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && protoProps.hasOwnProperty('constructor')) {
        child = protoProps.constructor;
    } else {
        child = function () {
            return parent.apply(this, arguments);
        };
    }

    // Add static properties to the constructor function from parent
    assign(child, parent);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate();

    // Mix in all prototype properties to the subclass if supplied.
    if (protoProps) {
        args.unshift(child.prototype);
        assign.apply(null, args);
    }

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
};

// Expose the extend function
module.exports = extend;

},{"lodash/assign":1606}],672:[function(require,module,exports){
;if (typeof window !== "undefined") {  window.ampersand = window.ampersand || {};  window.ampersand["ampersand-collection-lodash-mixin"] = window.ampersand["ampersand-collection-lodash-mixin"] || [];  window.ampersand["ampersand-collection-lodash-mixin"].push("4.0.0");}
var isFunction = require('lodash/isFunction');
var _ = {
    countBy: require('lodash/countBy'),
    difference: require('lodash/difference'),
    drop: require('lodash/drop'),
    each: require('lodash/forEach'),
    every: require('lodash/every'),
    filter: require('lodash/filter'),
    find: require('lodash/find'),
    forEach: require('lodash/forEach'),
    groupBy: require('lodash/groupBy'),
    includes: require('lodash/includes'),
    keyBy: require('lodash/keyBy'),
    indexOf: require('lodash/indexOf'),
    initial: require('lodash/initial'),
    invoke:  require('lodash/invoke'),
    invokeMap: require('lodash/invokeMap'),
    isEmpty: require('lodash/isEmpty'),
    lastIndexOf: require('lodash/lastIndexOf'),
    map: require('lodash/map'),
    max: require('lodash/max'),
    min: require('lodash/min'),
    partition: require('lodash/partition'),
    reduce: require('lodash/reduce'),
    reduceRight: require('lodash/reduceRight'),
    reject: require('lodash/reject'),
    sample: require('lodash/sample'),
    shuffle: require('lodash/shuffle'),
    some: require('lodash/some'),
    sortBy: require('lodash/sortBy'),
    tail: require('lodash/tail'),
    take: require('lodash/take'),
    without: require('lodash/without')
};
var slice = [].slice;
var mixins = {};


// lodash methods that we want to implement on the Collection.
var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',
    'filter', 'reject', 'every', 'some', 'includes', 'invoke', 'invokeMap', 'max', 'min',
    'take', 'initial', 'tail', 'drop', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'sample', 'partition'
];

// Mix in each lodash method as a proxy to `Collection#models`.
_.each(methods, function (method) {
    if (!_[method]) return;
    mixins[method] = function () {
        var args = slice.call(arguments);
        args.unshift(this.models);
        return _[method].apply(_, args);
    };
});

// lodash methods that take a property name as an argument.
var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'keyBy'];

// Use attributes instead of properties.
_.each(attributeMethods, function (method) {
    if (!_[method]) return;
    mixins[method] = function (value, context) {
        var iterator = isFunction(value) ? value : function (model) {
            return model.get ? model.get(value) : model[value];
        };
        return _[method](this.models, iterator, context);
    };
});

// Return models with matching attributes. Useful for simple cases of
// `filter`.
mixins.where = function (attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return this[first ? 'find' : 'filter'](function (model) {
        var value;
        for (var key in attrs) {
            value = model.get ? model.get(key) : model[key];
            if (attrs[key] !== value) return false;
        }
        return true;
    });
};

// Return the first model with matching attributes. Useful for simple cases
// of `find`.
mixins.findWhere = function (attrs) {
    return this.where(attrs, true);
};

// Plucks an attribute from each model in the collection.
mixins.pluck = function (attr) {
    return _.invokeMap(this.models, 'get', attr);
};

// We implement the following trivial methods ourselves.

// Gets first model
mixins.first = function () {
    return this.models[0];
};

// Gets last model
mixins.last = function () {
    return this.models[this.models.length - 1];
};

// Gets size of collection
mixins.size = function () {
    return this.models.length;
};

module.exports = mixins;

},{"lodash/countBy":1614,"lodash/difference":1621,"lodash/drop":1622,"lodash/every":1625,"lodash/filter":1626,"lodash/find":1627,"lodash/forEach":1634,"lodash/groupBy":1637,"lodash/includes":1642,"lodash/indexOf":1643,"lodash/initial":1644,"lodash/invoke":1645,"lodash/invokeMap":1646,"lodash/isEmpty":1653,"lodash/isFunction":1656,"lodash/keyBy":1666,"lodash/lastIndexOf":1670,"lodash/map":1671,"lodash/max":1672,"lodash/min":1675,"lodash/partition":1684,"lodash/reduce":1688,"lodash/reduceRight":1689,"lodash/reject":1690,"lodash/sample":1693,"lodash/shuffle":1695,"lodash/some":1696,"lodash/sortBy":1697,"lodash/tail":1701,"lodash/take":1702,"lodash/without":1714}],673:[function(require,module,exports){
;if (typeof window !== "undefined") {  window.ampersand = window.ampersand || {};  window.ampersand["ampersand-events"] = window.ampersand["ampersand-events"] || [];  window.ampersand["ampersand-events"].push("2.0.2");}
var runOnce = require('lodash/once');
var keys = require('lodash/keys');
var isEmpty = require('lodash/isEmpty');
var assign = require('lodash/assign');
var forEach = require('lodash/forEach');
var slice = Array.prototype.slice;

var utils = require('./libs/utils');

var Events = {
    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function (name, callback, context) {
        if (!utils.eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
        this._events || (this._events = {});
        var events = this._events[name] || (this._events[name] = []);
        events.push({callback: callback, context: context, ctx: context || this});
        return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function (name, callback, context) {
        if (!utils.eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
        var self = this;
        var once = runOnce(function () {
            self.off(name, once);
            callback.apply(this, arguments);
        });
        once._callback = callback;
        return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function (name, callback, context) {
        var retain, ev, events, names, i, l, j, k;
        if (!this._events || !utils.eventsApi(this, 'off', name, [callback, context])) return this;
        if (!name && !callback && !context) {
            this._events = void 0;
            return this;
        }
        names = name ? [name] : keys(this._events);
        for (i = 0, l = names.length; i < l; i++) {
            name = names[i];
            if (events = this._events[name]) {
                this._events[name] = retain = [];
                if (callback || context) {
                    for (j = 0, k = events.length; j < k; j++) {
                        ev = events[j];
                        if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                                (context && context !== ev.context)) {
                            retain.push(ev);
                        }
                    }
                }
                if (!retain.length) delete this._events[name];
            }
        }

        return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function (name) {
        if (!this._events) return this;
        var args = slice.call(arguments, 1);
        if (!utils.eventsApi(this, 'trigger', name, args)) return this;
        var events = this._events[name];
        var allEvents = this._events.all;
        if (events) utils.triggerEvents(events, args);
        if (allEvents) utils.triggerEvents(allEvents, arguments);
        return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function (obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) return this;
        var remove = !name && !callback;
        if (!callback && typeof name === 'object') callback = this;
        if (obj) (listeningTo = {})[obj._listenId] = obj;
        var self = this;
        forEach(listeningTo, function (item, id) {
            item.off(name, callback, self);
            if (remove || isEmpty(item._events)) delete self._listeningTo[id];
        });
        return this;
    },

    // extend an object with event capabilities if passed
    // or just return a new one.
    createEmitter: function (obj) {
        return assign(obj || {}, Events);
    },

    listenTo: utils.createListenMethod('on'),

    listenToOnce: utils.createListenMethod('once'),

    listenToAndRun: function (obj, name, callback) {
        this.listenTo.apply(this, arguments);
        if (!callback && typeof name === 'object') callback = this;
        callback.apply(this);
        return this;
    }
};

// setup aliases
Events.bind = Events.on;
Events.unbind = Events.off;
Events.removeListener = Events.off;
Events.removeAllListeners = Events.off;
Events.emit = Events.trigger;

module.exports = Events;

},{"./libs/utils":674,"lodash/assign":1606,"lodash/forEach":1634,"lodash/isEmpty":1653,"lodash/keys":1667,"lodash/once":1680}],674:[function(require,module,exports){
var uniqueId = require('lodash/uniqueId');
var eventSplitter = /\s+/;

// A difficult-to-believe, but optimized internal dispatch function for
// triggering events. Tries to keep the usual cases speedy.
exports.triggerEvents = function triggerEvents(events, args) {
    var ev;
    var i = -1;
    var l = events.length;
    var a1 = args[0];
    var a2 = args[1];
    var a3 = args[2];
    switch (args.length) {
        case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
        case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
        case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
        case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
        default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
};

// Implement fancy features of the Events API such as multiple event
// names `"change blur"` and jQuery-style event maps `{change: action}`
// in terms of the existing API.
exports.eventsApi = function eventsApi(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
        for (var key in name) {
            obj[action].apply(obj, [key, name[key]].concat(rest));
        }
        return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
        var names = name.split(eventSplitter);
        for (var i = 0, l = names.length; i < l; i++) {
            obj[action].apply(obj, [names[i]].concat(rest));
        }
        return false;
    }

    return true;
};

// Inversion-of-control versions of `on` and `once`. Tell *this* object to
// listen to an event in another object ... keeping track of what it's
// listening to.
exports.createListenMethod = function createListenMethod(implementation) {
    return function listenMethod(obj, name, callback) {
        if (!obj) {
            throw new Error('Trying to listenTo event: \'' + name + '\' but the target object is undefined');
        }
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var id = obj._listenId || (obj._listenId = uniqueId('l'));
        listeningTo[id] = obj;
        if (!callback && typeof name === 'object') callback = this;
        if (typeof obj[implementation] !== 'function') {
            throw new Error('Trying to listenTo event: \'' + name + '\' on object: ' + obj.toString() + ' but it does not have an \'on\' method so is unbindable');
        }
        obj[implementation](name, callback, this);
        return this;
    };
};

},{"lodash/uniqueId":1711}],675:[function(require,module,exports){
'use strict';
;if (typeof window !== "undefined") {  window.ampersand = window.ampersand || {};  window.ampersand["ampersand-state"] = window.ampersand["ampersand-state"] || [];  window.ampersand["ampersand-state"].push("5.0.2");}
var uniqueId = require('lodash/uniqueId');
var assign = require('lodash/assign');
var cloneObj = function(obj) { return assign({}, obj); };
var omit = require('lodash/omit');
var escape = require('lodash/escape');
var forOwn = require('lodash/forOwn');
var includes = require('lodash/includes');
var isString = require('lodash/isString');
var isObject = require('lodash/isObject');
var isDate = require('lodash/isDate');
var isFunction = require('lodash/isFunction');
var _isEqual = require('lodash/isEqual'); // to avoid shadowing
var has = require('lodash/has');
var result = require('lodash/result');
var bind = require('lodash/bind'); // because phantomjs doesn't have Function#bind
var union = require('lodash/union');
var Events = require('ampersand-events');
var KeyTree = require('key-tree-store');
var arrayNext = require('array-next');
var changeRE = /^change:/;
var noop = function () {};

function Base(attrs, options) {
    options || (options = {});
    this.cid || (this.cid = uniqueId('state'));
    this._events = {};
    this._values = {};
    this._eventBubblingHandlerCache = {};
    this._definition = Object.create(this._definition);
    if (options.parse) attrs = this.parse(attrs, options);
    this.parent = options.parent;
    this.collection = options.collection;
    this._keyTree = new KeyTree();
    this._initCollections();
    this._initChildren();
    this._cache = {};
    this._previousAttributes = {};
    if (attrs) this.set(attrs, assign({silent: true, initial: true}, options));
    this._changed = {};
    if (this._derived) this._initDerived();
    if (options.init !== false) this.initialize.apply(this, arguments);
}

assign(Base.prototype, Events, {
    // can be allow, ignore, reject
    extraProperties: 'ignore',

    idAttribute: 'id',

    namespaceAttribute: 'namespace',

    typeAttribute: 'modelType',

    // Stubbed out to be overwritten
    initialize: function () {
        return this;
    },

    // Get ID of model per configuration.
    // Should *always* be how ID is determined by other code.
    getId: function () {
        return this[this.idAttribute];
    },

    // Get namespace of model per configuration.
    // Should *always* be how namespace is determined by other code.
    getNamespace: function () {
        return this[this.namespaceAttribute];
    },

    // Get type of model per configuration.
    // Should *always* be how type is determined by other code.
    getType: function () {
        return this[this.typeAttribute];
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function () {
        return this.getId() == null;
    },

    // get HTML-escaped value of attribute
    escape: function (attr) {
        return escape(this.get(attr));
    },

    // Check if the model is currently in a valid state.
    isValid: function (options) {
        return this._validate({}, assign(options || {}, { validate: true }));
    },

    // Parse can be used remap/restructure/rename incoming properties
    // before they are applied to attributes.
    parse: function (resp, options) {
        //jshint unused:false
        return resp;
    },

    // Serialize is the inverse of `parse` it lets you massage data
    // on the way out. Before, sending to server, for example.
    serialize: function (options) {
        var attrOpts = assign({props: true}, options);
        var res = this.getAttributes(attrOpts, true);
        forOwn(this._children, bind(function (value, key) {
            res[key] = this[key].serialize();
        }, this));
        forOwn(this._collections, bind(function (value, key) {
            res[key] = this[key].serialize();
        }, this));
        return res;
    },

    // Main set method used by generated setters/getters and can
    // be used directly if you need to pass options or set multiple
    // properties at once.
    set: function (key, value, options) {
        var self = this;
        var extraProperties = this.extraProperties;
        var wasChanging, changeEvents, newType, newVal, def, cast, err, attr,
            attrs, dataType, silent, unset, currentVal, initial, hasChanged, isEqual, onChange;

        // Handle both `"key", value` and `{key: value}` -style arguments.
        if (isObject(key) || key === null) {
            attrs = key;
            options = value;
        } else {
            attrs = {};
            attrs[key] = value;
        }

        options = options || {};

        if (!this._validate(attrs, options)) return false;

        // Extract attributes and options.
        unset = options.unset;
        silent = options.silent;
        initial = options.initial;

        // Initialize change tracking.
        wasChanging = this._changing;
        this._changing = true;
        changeEvents = [];

        // if not already changing, store previous
        if (initial) {
            this._previousAttributes = {};
        } else if (!wasChanging) {
            this._previousAttributes = this.attributes;
            this._changed = {};
        }

        // For each `set` attribute...
        for (var i = 0, keys = Object.keys(attrs), len = keys.length; i < len; i++) {
            attr = keys[i];
            newVal = attrs[attr];
            newType = typeof newVal;
            currentVal = this._values[attr];
            def = this._definition[attr];

            if (!def) {
                // if this is a child model or collection
                if (this._children[attr] || this._collections[attr]) {
                    if (!isObject(newVal)) {
                        newVal = {};
                    }

                    this[attr].set(newVal, options);
                    continue;
                } else if (extraProperties === 'ignore') {
                    continue;
                } else if (extraProperties === 'reject') {
                    throw new TypeError('No "' + attr + '" property defined on ' + (this.type || 'this') + ' model and extraProperties not set to "ignore" or "allow"');
                } else if (extraProperties === 'allow') {
                    def = this._createPropertyDefinition(attr, 'any');
                } else if (extraProperties) {
                    throw new TypeError('Invalid value for extraProperties: "' + extraProperties + '"');
                }
            }

            isEqual = this._getCompareForType(def.type);
            onChange = this._getOnChangeForType(def.type);
            dataType = this._dataTypes[def.type];

            // check type if we have one
            if (dataType && dataType.set) {
                cast = dataType.set(newVal);
                newVal = cast.val;
                newType = cast.type;
            }

            // If we've defined a test, run it
            if (def.test) {
                err = def.test.call(this, newVal, newType);
                if (err) {
                    throw new TypeError('Property \'' + attr + '\' failed validation with error: ' + err);
                }
            }

            // If we are required but undefined, throw error.
            // If we are null and are not allowing null, throw error
            // If we have a defined type and the new type doesn't match, and we are not null, throw error.
            // If we require specific value and new one is not one of them, throw error (unless it has default value or we're unsetting it with undefined).

            if (newVal === undefined && def.required) {
                throw new TypeError('Required property \'' + attr + '\' must be of type ' + def.type + '. Tried to set ' + newVal);
            }
            if (newVal === null && def.required && !def.allowNull) {
                throw new TypeError('Property \'' + attr + '\' must be of type ' + def.type + ' (cannot be null). Tried to set ' + newVal);
            }
            if ((def.type && def.type !== 'any' && def.type !== newType) && newVal !== null && newVal !== undefined) {
                throw new TypeError('Property \'' + attr + '\' must be of type ' + def.type + '. Tried to set ' + newVal);
            }
            if (def.values && !includes(def.values, newVal)) {
                var defaultValue = result(def, 'default');
                if (unset && defaultValue !== undefined) {
                    newVal = defaultValue;
                } else if (!unset || (unset && newVal !== undefined)) {
                    throw new TypeError('Property \'' + attr + '\' must be one of values: ' + def.values.join(', ') + '. Tried to set ' + newVal);
                }
            }

            // We know this has 'changed' if it's the initial set, so skip a potentially expensive isEqual check.
            hasChanged = initial || !isEqual(currentVal, newVal, attr);

            // enforce `setOnce` for properties if set
            if (def.setOnce && currentVal !== undefined && hasChanged) {
                throw new TypeError('Property \'' + attr + '\' can only be set once.');
            }

            // set/unset attributes.
            // If this is not the initial set, keep track of changed attributes
            // and push to changeEvents array so we can fire events.
            if (hasChanged) {

                // This fires no matter what, even on initial set.
                onChange(newVal, currentVal, attr);

                // If this is a change (not an initial set), mark the change.
                // Note it's impossible to unset on the initial set (it will already be unset),
                // so we only include that logic here.
                if (!initial) {
                    this._changed[attr] = newVal;
                    this._previousAttributes[attr] = currentVal;
                    if (unset) {
                        // FIXME delete is very slow. Can we get away with setting to undefined?
                        delete this._values[attr];
                    }
                    if (!silent) {
                        changeEvents.push({prev: currentVal, val: newVal, key: attr});
                    }
                }
                if (!unset) {
                    this._values[attr] = newVal;
                }
            } else {
                // Not changed
                // FIXME delete is very slow. Can we get away with setting to undefined?
                delete this._changed[attr];
            }
        }

        // Fire events. This array is not populated if we are told to be silent.
        if (changeEvents.length) this._pending = true;
        changeEvents.forEach(function (change) {
            self.trigger('change:' + change.key, self, change.val, options);
        });

        // You might be wondering why there's a `while` loop here. Changes can
        // be recursively nested within `"change"` events.
        if (wasChanging) return this;
        while (this._pending) {
            this._pending = false;
            this.trigger('change', this, options);
        }
        this._pending = false;
        this._changing = false;
        return this;
    },

    get: function (attr) {
        return this[attr];
    },

    // Toggle boolean properties or properties that have a `values`
    // array in its definition.
    toggle: function (property) {
        var def = this._definition[property];
        if (def.type === 'boolean') {
            // if it's a bool, just flip it
            this[property] = !this[property];
        } else if (def && def.values) {
            // If it's a property with an array of values
            // skip to the next one looping back if at end.
            this[property] = arrayNext(def.values, this[property]);
        } else {
            throw new TypeError('Can only toggle properties that are type `boolean` or have `values` array.');
        }
        return this;
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function () {
        return cloneObj(this._previousAttributes);
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function (attr) {
        if (attr == null) return !!Object.keys(this._changed).length;
        if (has(this._derived, attr)) {
            return this._derived[attr].depList.some(function (dep) {
                return this.hasChanged(dep);
            }, this);
        }
        return has(this._changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function (diff) {
        if (!diff) return this.hasChanged() ? cloneObj(this._changed) : false;
        var val, changed = false;
        var old = this._changing ? this._previousAttributes : this.attributes;
        var def, isEqual;
        for (var attr in diff) {
            def = this._definition[attr];
            if (!def) continue;
            isEqual = this._getCompareForType(def.type);
            if (isEqual(old[attr], (val = diff[attr]))) continue;
            (changed || (changed = {}))[attr] = val;
        }
        return changed;
    },

    toJSON: function () {
        return this.serialize();
    },

    unset: function (attrs, options) {
        var self = this;
        attrs = Array.isArray(attrs) ? attrs : [attrs];
        attrs.forEach(function (key) {
            var def = self._definition[key];
            if (!def) return;
            var val;
            if (def.required) {
                val = result(def, 'default');
                return self.set(key, val, options);
            } else {
                return self.set(key, val, assign({}, options, {unset: true}));
            }
        });
    },

    clear: function (options) {
        var self = this;
        Object.keys(this.attributes).forEach(function (key) {
            self.unset(key, options);
        });
        return this;
    },

    previous: function (attr) {
        if (attr == null || !Object.keys(this._previousAttributes).length) return null;
        return this._previousAttributes[attr];
    },

    // Get default values for a certain type
    _getDefaultForType: function (type) {
        var dataType = this._dataTypes[type];
        return dataType && dataType['default'];
    },

    // Determine which comparison algorithm to use for comparing a property
    _getCompareForType: function (type) {
        var dataType = this._dataTypes[type];
        if (dataType && dataType.compare) return bind(dataType.compare, this);
        return _isEqual; // if no compare function is defined, use _.isEqual
    },

    _getOnChangeForType : function(type){
        var dataType = this._dataTypes[type];
        if (dataType && dataType.onChange) return bind(dataType.onChange, this);
        return noop;
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function (attrs, options) {
        if (!options.validate || !this.validate) return true;
        attrs = assign({}, this.attributes, attrs);
        var error = this.validationError = this.validate(attrs, options) || null;
        if (!error) return true;
        this.trigger('invalid', this, error, assign(options || {}, {validationError: error}));
        return false;
    },

    _createPropertyDefinition: function (name, desc, isSession) {
        return createPropertyDefinition(this, name, desc, isSession);
    },

    // just makes friendlier errors when trying to define a new model
    // only used when setting up original property definitions
    _ensureValidType: function (type) {
        return includes(['string', 'number', 'boolean', 'array', 'object', 'date', 'state', 'any']
            .concat(Object.keys(this._dataTypes)), type) ? type : undefined;
    },

    getAttributes: function (options, raw) {
        options = assign({
            session: false,
            props: false,
            derived: false
        }, options || {});
        var res = {};
        var val, def;
        for (var item in this._definition) {
            def = this._definition[item];
            if ((options.session && def.session) || (options.props && !def.session)) {
                val = raw ? this._values[item] : this[item];
                if (raw && val && isFunction(val.serialize)) val = val.serialize();
                if (typeof val === 'undefined') val = result(def, 'default');
                if (typeof val !== 'undefined') res[item] = val;
            }
        }
        if (options.derived) {
            for (var derivedItem in this._derived) res[derivedItem] = this[derivedItem];
        }
        return res;
    },

    _initDerived: function () {
        var self = this;

        forOwn(this._derived, function (value, name) {
            var def = self._derived[name];
            def.deps = def.depList;

            var update = function (options) {
                options = options || {};

                var newVal = def.fn.call(self);

                if (self._cache[name] !== newVal || !def.cache) {
                    if (def.cache) {
                        self._previousAttributes[name] = self._cache[name];
                    }
                    self._cache[name] = newVal;
                    self.trigger('change:' + name, self, self._cache[name]);
                }
            };

            def.deps.forEach(function (propString) {
                self._keyTree.add(propString, update);
            });
        });

        this.on('all', function (eventName) {
            if (changeRE.test(eventName)) {
                self._keyTree.get(eventName.split(':')[1]).forEach(function (fn) {
                    fn();
                });
            }
        }, this);
    },

    _getDerivedProperty: function (name, flushCache) {
        // is this a derived property that is cached
        if (this._derived[name].cache) {
            //set if this is the first time, or flushCache is set
            if (flushCache || !this._cache.hasOwnProperty(name)) {
                this._cache[name] = this._derived[name].fn.apply(this);
            }
            return this._cache[name];
        } else {
            return this._derived[name].fn.apply(this);
        }
    },

    _initCollections: function () {
        var coll;
        if (!this._collections) return;
        for (coll in this._collections) {
            this._safeSet(coll, new this._collections[coll](null, {parent: this}));
        }
    },

    _initChildren: function () {
        var child;
        if (!this._children) return;
        for (child in this._children) {
            this._safeSet(child, new this._children[child]({}, {parent: this}));
            this.listenTo(this[child], 'all', this._getCachedEventBubblingHandler(child));
        }
    },

    // Returns a bound handler for doing event bubbling while
    // adding a name to the change string.
    _getCachedEventBubblingHandler: function (propertyName) {
        if (!this._eventBubblingHandlerCache[propertyName]) {
            this._eventBubblingHandlerCache[propertyName] = bind(function (name, model, newValue) {
                if (changeRE.test(name)) {
                    this.trigger('change:' + propertyName + '.' + name.split(':')[1], model, newValue);
                } else if (name === 'change') {
                    this.trigger('change', this);
                }
            }, this);
        }
        return this._eventBubblingHandlerCache[propertyName];
    },

    // Check that all required attributes are present
    _verifyRequired: function () {
        var attrs = this.attributes; // should include session
        for (var def in this._definition) {
            if (this._definition[def].required && typeof attrs[def] === 'undefined') {
                return false;
            }
        }
        return true;
    },

    // expose safeSet method
    _safeSet: function safeSet(property, value) {
        if (property in this) {
            throw new Error('Encountered namespace collision while setting instance property `' + property + '`');
        }
        this[property] = value;
        return this;
    }
});

// getter for attributes
Object.defineProperties(Base.prototype, {
    attributes: {
        get: function () {
            return this.getAttributes({props: true, session: true});
        }
    },
    all: {
        get: function () {
            return this.getAttributes({
                session: true,
                props: true,
                derived: true
            });
        }
    },
    isState: {
        get: function () { return true; },
        set: function () { }
    }
});

// helper for creating/storing property definitions and creating
// appropriate getters/setters
function createPropertyDefinition(object, name, desc, isSession) {
    var def = object._definition[name] = {};
    var type, descArray;

    if (isString(desc)) {
        // grab our type if all we've got is a string
        type = object._ensureValidType(desc);
        if (type) def.type = type;
    } else {
        //Transform array of ['type', required, default] to object form
        if (Array.isArray(desc)) {
            descArray = desc;
            desc = {
                type: descArray[0],
                required: descArray[1],
                'default': descArray[2]
            };
        }

        type = object._ensureValidType(desc.type);
        if (type) def.type = type;

        if (desc.required) def.required = true;

        if (desc['default'] && typeof desc['default'] === 'object') {
            throw new TypeError('The default value for ' + name + ' cannot be an object/array, must be a value or a function which returns a value/object/array');
        }

        def['default'] = desc['default'];

        def.allowNull = desc.allowNull ? desc.allowNull : false;
        if (desc.setOnce) def.setOnce = true;
        if (def.required && def['default'] === undefined && !def.setOnce) def['default'] = object._getDefaultForType(type);
        def.test = desc.test;
        def.values = desc.values;
    }
    if (isSession) def.session = true;

    if (!type) {
        type = isString(desc) ? desc : desc.type;
        // TODO: start throwing a TypeError in future major versions instead of warning
        console.warn('Invalid data type of `' + type + '` for `' + name + '` property. Use one of the default types or define your own');
    }

    // define a getter/setter on the prototype
    // but they get/set on the instance
    Object.defineProperty(object, name, {
        set: function (val) {
            this.set(name, val);
        },
        get: function () {
            if (!this._values) {
                throw Error('You may be trying to `extend` a state object with "' + name + '" which has been defined in `props` on the object being extended');
            }
            var value = this._values[name];
            var typeDef = this._dataTypes[def.type];
            if (typeof value !== 'undefined') {
                if (typeDef && typeDef.get) {
                    value = typeDef.get(value);
                }
                return value;
            }
            var defaultValue = result(def, 'default');
            this._values[name] = defaultValue;
            // If we've set a defaultValue, fire a change handler effectively marking
            // its change from undefined to the default value.
            if (typeof defaultValue !== 'undefined') {
                var onChange = this._getOnChangeForType(def.type);
                onChange(defaultValue, value, name);
            }
            return defaultValue;
        }
    });

    return def;
}

// helper for creating derived property definitions
function createDerivedProperty(modelProto, name, definition) {
    var def = modelProto._derived[name] = {
        fn: isFunction(definition) ? definition : definition.fn,
        cache: (definition.cache !== false),
        depList: definition.deps || []
    };

    // add to our shared dependency list
    def.depList.forEach(function (dep) {
        modelProto._deps[dep] = union(modelProto._deps[dep] || [], [name]);
    });

    // defined a top-level getter for derived names
    Object.defineProperty(modelProto, name, {
        get: function () {
            return this._getDerivedProperty(name);
        },
        set: function () {
            throw new TypeError("`" + name + "` is a derived property, it can't be set directly.");
        }
    });
}

var dataTypes = {
    string: {
        'default': function () {
            return '';
        }
    },
    date: {
        set: function (newVal) {
            var newType;
            if (newVal == null) {
                newType = typeof null;
            } else if (!isDate(newVal)) {
                var err = null;
                var dateVal = new Date(newVal).valueOf();
                if (isNaN(dateVal)) {
                    // If the newVal cant be parsed, then try parseInt first
                    dateVal = new Date(parseInt(newVal, 10)).valueOf();
                    if (isNaN(dateVal)) err = true;
                }
                newVal = dateVal;
                newType = 'date';
                if (err) {
                    newType = typeof newVal;
                }
            } else {
                newType = 'date';
                newVal = newVal.valueOf();
            }

            return {
                val: newVal,
                type: newType
            };
        },
        get: function (val) {
            if (val == null) { return val; }
            return new Date(val);
        },
        'default': function () {
            return new Date();
        }
    },
    array: {
        set: function (newVal) {
            return {
                val: newVal,
                type: Array.isArray(newVal) ? 'array' : typeof newVal
            };
        },
        'default': function () {
            return [];
        }
    },
    object: {
        set: function (newVal) {
            var newType = typeof newVal;
            // we have to have a way of supporting "missing" objects.
            // Null is an object, but setting a value to undefined
            // should work too, IMO. We just override it, in that case.
            if (newType !== 'object' && newVal === undefined) {
                newVal = null;
                newType = 'object';
            }
            return {
                val: newVal,
                type: newType
            };
        },
        'default': function () {
            return {};
        }
    },
    // the `state` data type is a bit special in that setting it should
    // also bubble events
    state: {
        set: function (newVal) {
            var isInstance = newVal instanceof Base || (newVal && newVal.isState);
            if (isInstance) {
                return {
                    val: newVal,
                    type: 'state'
                };
            } else {
                return {
                    val: newVal,
                    type: typeof newVal
                };
            }
        },
        compare: function (currentVal, newVal) {
            return currentVal === newVal;
        },

        onChange : function(newVal, previousVal, attributeName){
            // if this has changed we want to also handle
            // event propagation
            if (previousVal) {
                this.stopListening(previousVal, 'all', this._getCachedEventBubblingHandler(attributeName));
            }

            if (newVal != null) {
                this.listenTo(newVal, 'all', this._getCachedEventBubblingHandler(attributeName));
            }
        }
    }
};

// the extend method used to extend prototypes, maintain inheritance chains for instanceof
// and allow for additions to the model definitions.
function extend(protoProps) {
    /*jshint validthis:true*/
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && protoProps.hasOwnProperty('constructor')) {
        child = protoProps.constructor;
    } else {
        child = function () {
            return parent.apply(this, arguments);
        };
    }

    // Add static properties to the constructor function from parent
    assign(child, parent);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function () { this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate();

    // set prototype level objects
    child.prototype._derived =  assign({}, parent.prototype._derived);
    child.prototype._deps = assign({}, parent.prototype._deps);
    child.prototype._definition = assign({}, parent.prototype._definition);
    child.prototype._collections = assign({}, parent.prototype._collections);
    child.prototype._children = assign({}, parent.prototype._children);
    child.prototype._dataTypes = assign({}, parent.prototype._dataTypes || dataTypes);

    // Mix in all prototype properties to the subclass if supplied.
    if (protoProps) {
        var omitFromExtend = [
            'dataTypes', 'props', 'session', 'derived', 'collections', 'children'
        ];
        for(var i = 0; i < arguments.length; i++) {
            var def = arguments[i];
            if (def.dataTypes) {
                forOwn(def.dataTypes, function (def, name) {
                    child.prototype._dataTypes[name] = def;
                });
            }
            if (def.props) {
                forOwn(def.props, function (def, name) {
                    createPropertyDefinition(child.prototype, name, def);
                });
            }
            if (def.session) {
                forOwn(def.session, function (def, name) {
                    createPropertyDefinition(child.prototype, name, def, true);
                });
            }
            if (def.derived) {
                forOwn(def.derived, function (def, name) {
                    createDerivedProperty(child.prototype, name, def);
                });
            }
            if (def.collections) {
                forOwn(def.collections, function (constructor, name) {
                    child.prototype._collections[name] = constructor;
                });
            }
            if (def.children) {
                forOwn(def.children, function (constructor, name) {
                    child.prototype._children[name] = constructor;
                });
            }
            assign(child.prototype, omit(def, omitFromExtend));
        }
    }

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
}

Base.extend = extend;

// Our main exports
module.exports = Base;

},{"ampersand-events":673,"array-next":676,"key-tree-store":1313,"lodash/assign":1606,"lodash/bind":1610,"lodash/escape":1624,"lodash/forOwn":1635,"lodash/has":1638,"lodash/includes":1642,"lodash/isDate":1652,"lodash/isEqual":1654,"lodash/isFunction":1656,"lodash/isObject":1659,"lodash/isString":1662,"lodash/omit":1679,"lodash/result":1692,"lodash/union":1710,"lodash/uniqueId":1711}],676:[function(require,module,exports){
module.exports = function arrayNext(array, currentItem) {
    var len = array.length;
    var newIndex = array.indexOf(currentItem) + 1;
    if (newIndex > (len - 1)) newIndex = 0;
    return array[newIndex];
};

},{}],677:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"core-js/fn/regexp/escape":873,"core-js/shim":1307,"regenerator-runtime/runtime":1721}],678:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":874}],679:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":875}],680:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/is-iterable"), __esModule: true };
},{"core-js/library/fn/is-iterable":876}],681:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/json/stringify"), __esModule: true };
},{"core-js/library/fn/json/stringify":877}],682:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":878}],683:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/is-nan"), __esModule: true };
},{"core-js/library/fn/number/is-nan":879}],684:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":880}],685:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":881}],686:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-properties"), __esModule: true };
},{"core-js/library/fn/object/define-properties":882}],687:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":883}],688:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/entries"), __esModule: true };
},{"core-js/library/fn/object/entries":884}],689:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":885}],690:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":886}],691:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":887}],692:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":888}],693:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/values"), __esModule: true };
},{"core-js/library/fn/object/values":889}],694:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":890}],695:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/reflect/apply"), __esModule: true };
},{"core-js/library/fn/reflect/apply":891}],696:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/reflect/construct"), __esModule: true };
},{"core-js/library/fn/reflect/construct":892}],697:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/reflect/define-property"), __esModule: true };
},{"core-js/library/fn/reflect/define-property":893}],698:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/reflect/delete-property"), __esModule: true };
},{"core-js/library/fn/reflect/delete-property":894}],699:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/reflect/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/reflect/get-own-property-descriptor":895}],700:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":896}],701:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":897}],702:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":898}],703:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/weak-map"), __esModule: true };
},{"core-js/library/fn/weak-map":899}],704:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],705:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":687}],706:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};
},{"../core-js/object/define-property":687}],707:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":685,"../core-js/object/set-prototype-of":692,"../helpers/typeof":711}],708:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":711}],709:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _isIterable2 = require("../core-js/is-iterable");

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = require("../core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
},{"../core-js/get-iterator":679,"../core-js/is-iterable":680}],710:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _from = require("../core-js/array/from");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};
},{"../core-js/array/from":678}],711:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":701,"../core-js/symbol/iterator":702}],712:[function(require,module,exports){
//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var Backoff = require('./lib/backoff');
var ExponentialBackoffStrategy = require('./lib/strategy/exponential');
var FibonacciBackoffStrategy = require('./lib/strategy/fibonacci');
var FunctionCall = require('./lib/function_call.js');

module.exports.Backoff = Backoff;
module.exports.FunctionCall = FunctionCall;
module.exports.FibonacciStrategy = FibonacciBackoffStrategy;
module.exports.ExponentialStrategy = ExponentialBackoffStrategy;

// Constructs a Fibonacci backoff.
module.exports.fibonacci = function(options) {
    return new Backoff(new FibonacciBackoffStrategy(options));
};

// Constructs an exponential backoff.
module.exports.exponential = function(options) {
    return new Backoff(new ExponentialBackoffStrategy(options));
};

// Constructs a FunctionCall for the given function and arguments.
module.exports.call = function(fn, vargs, callback) {
    var args = Array.prototype.slice.call(arguments);
    fn = args[0];
    vargs = args.slice(1, args.length - 1);
    callback = args[args.length - 1];
    return new FunctionCall(fn, vargs, callback);
};

},{"./lib/backoff":713,"./lib/function_call.js":714,"./lib/strategy/exponential":715,"./lib/strategy/fibonacci":716}],713:[function(require,module,exports){
//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var events = require('events');
var precond = require('precond');
var util = require('util');

// A class to hold the state of a backoff operation. Accepts a backoff strategy
// to generate the backoff delays.
function Backoff(backoffStrategy) {
    events.EventEmitter.call(this);

    this.backoffStrategy_ = backoffStrategy;
    this.maxNumberOfRetry_ = -1;
    this.backoffNumber_ = 0;
    this.backoffDelay_ = 0;
    this.timeoutID_ = -1;

    this.handlers = {
        backoff: this.onBackoff_.bind(this)
    };
}
util.inherits(Backoff, events.EventEmitter);

// Sets a limit, greater than 0, on the maximum number of backoffs. A 'fail'
// event will be emitted when the limit is reached.
Backoff.prototype.failAfter = function(maxNumberOfRetry) {
    precond.checkArgument(maxNumberOfRetry > 0,
        'Expected a maximum number of retry greater than 0 but got %s.',
        maxNumberOfRetry);

    this.maxNumberOfRetry_ = maxNumberOfRetry;
};

// Starts a backoff operation. Accepts an optional parameter to let the
// listeners know why the backoff operation was started.
Backoff.prototype.backoff = function(err) {
    precond.checkState(this.timeoutID_ === -1, 'Backoff in progress.');

    if (this.backoffNumber_ === this.maxNumberOfRetry_) {
        this.emit('fail', err);
        this.reset();
    } else {
        this.backoffDelay_ = this.backoffStrategy_.next();
        this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);
        this.emit('backoff', this.backoffNumber_, this.backoffDelay_, err);
    }
};

// Handles the backoff timeout completion.
Backoff.prototype.onBackoff_ = function() {
    this.timeoutID_ = -1;
    this.emit('ready', this.backoffNumber_, this.backoffDelay_);
    this.backoffNumber_++;
};

// Stops any backoff operation and resets the backoff delay to its inital value.
Backoff.prototype.reset = function() {
    this.backoffNumber_ = 0;
    this.backoffStrategy_.reset();
    clearTimeout(this.timeoutID_);
    this.timeoutID_ = -1;
};

module.exports = Backoff;

},{"events":1737,"precond":1718,"util":1769}],714:[function(require,module,exports){
//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var events = require('events');
var precond = require('precond');
var util = require('util');

var Backoff = require('./backoff');
var FibonacciBackoffStrategy = require('./strategy/fibonacci');

// Wraps a function to be called in a backoff loop.
function FunctionCall(fn, args, callback) {
    events.EventEmitter.call(this);

    precond.checkIsFunction(fn, 'Expected fn to be a function.');
    precond.checkIsArray(args, 'Expected args to be an array.');
    precond.checkIsFunction(callback, 'Expected callback to be a function.');

    this.function_ = fn;
    this.arguments_ = args;
    this.callback_ = callback;
    this.lastResult_ = [];
    this.numRetries_ = 0;

    this.backoff_ = null;
    this.strategy_ = null;
    this.failAfter_ = -1;
    this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;

    this.state_ = FunctionCall.State_.PENDING;
}
util.inherits(FunctionCall, events.EventEmitter);

// States in which the call can be.
FunctionCall.State_ = {
    // Call isn't started yet.
    PENDING: 0,
    // Call is in progress.
    RUNNING: 1,
    // Call completed successfully which means that either the wrapped function
    // returned successfully or the maximal number of backoffs was reached.
    COMPLETED: 2,
    // The call was aborted.
    ABORTED: 3
};

// The default retry predicate which considers any error as retriable.
FunctionCall.DEFAULT_RETRY_PREDICATE_ = function(err) {
  return true;
};

// Checks whether the call is pending.
FunctionCall.prototype.isPending = function() {
    return this.state_ == FunctionCall.State_.PENDING;
};

// Checks whether the call is in progress.
FunctionCall.prototype.isRunning = function() {
    return this.state_ == FunctionCall.State_.RUNNING;
};

// Checks whether the call is completed.
FunctionCall.prototype.isCompleted = function() {
    return this.state_ == FunctionCall.State_.COMPLETED;
};

// Checks whether the call is aborted.
FunctionCall.prototype.isAborted = function() {
    return this.state_ == FunctionCall.State_.ABORTED;
};

// Sets the backoff strategy to use. Can only be called before the call is
// started otherwise an exception will be thrown.
FunctionCall.prototype.setStrategy = function(strategy) {
    precond.checkState(this.isPending(), 'FunctionCall in progress.');
    this.strategy_ = strategy;
    return this; // Return this for chaining.
};

// Sets the predicate which will be used to determine whether the errors
// returned from the wrapped function should be retried or not, e.g. a
// network error would be retriable while a type error would stop the
// function call.
FunctionCall.prototype.retryIf = function(retryPredicate) {
    precond.checkState(this.isPending(), 'FunctionCall in progress.');
    this.retryPredicate_ = retryPredicate;
    return this;
};

// Returns all intermediary results returned by the wrapped function since
// the initial call.
FunctionCall.prototype.getLastResult = function() {
    return this.lastResult_.concat();
};

// Returns the number of times the wrapped function call was retried.
FunctionCall.prototype.getNumRetries = function() {
    return this.numRetries_;
};

// Sets the backoff limit.
FunctionCall.prototype.failAfter = function(maxNumberOfRetry) {
    precond.checkState(this.isPending(), 'FunctionCall in progress.');
    this.failAfter_ = maxNumberOfRetry;
    return this; // Return this for chaining.
};

// Aborts the call.
FunctionCall.prototype.abort = function() {
    if (this.isCompleted() || this.isAborted()) {
      return;
    }

    if (this.isRunning()) {
        this.backoff_.reset();
    }

    this.state_ = FunctionCall.State_.ABORTED;
    this.lastResult_ = [new Error('Backoff aborted.')];
    this.emit('abort');
    this.doCallback_();
};

// Initiates the call to the wrapped function. Accepts an optional factory
// function used to create the backoff instance; used when testing.
FunctionCall.prototype.start = function(backoffFactory) {
    precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');
    precond.checkState(this.isPending(), 'FunctionCall already started.');

    var strategy = this.strategy_ || new FibonacciBackoffStrategy();

    this.backoff_ = backoffFactory ?
        backoffFactory(strategy) :
        new Backoff(strategy);

    this.backoff_.on('ready', this.doCall_.bind(this, true /* isRetry */));
    this.backoff_.on('fail', this.doCallback_.bind(this));
    this.backoff_.on('backoff', this.handleBackoff_.bind(this));

    if (this.failAfter_ > 0) {
        this.backoff_.failAfter(this.failAfter_);
    }

    this.state_ = FunctionCall.State_.RUNNING;
    this.doCall_(false /* isRetry */);
};

// Calls the wrapped function.
FunctionCall.prototype.doCall_ = function(isRetry) {
    if (isRetry) {
        this.numRetries_++;
    }
    var eventArgs = ['call'].concat(this.arguments_);
    events.EventEmitter.prototype.emit.apply(this, eventArgs);
    var callback = this.handleFunctionCallback_.bind(this);
    this.function_.apply(null, this.arguments_.concat(callback));
};

// Calls the wrapped function's callback with the last result returned by the
// wrapped function.
FunctionCall.prototype.doCallback_ = function() {
    this.callback_.apply(null, this.lastResult_);
};

// Handles wrapped function's completion. This method acts as a replacement
// for the original callback function.
FunctionCall.prototype.handleFunctionCallback_ = function() {
    if (this.isAborted()) {
        return;
    }

    var args = Array.prototype.slice.call(arguments);
    this.lastResult_ = args; // Save last callback arguments.
    events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));

    var err = args[0];
    if (err && this.retryPredicate_(err)) {
        this.backoff_.backoff(err);
    } else {
        this.state_ = FunctionCall.State_.COMPLETED;
        this.doCallback_();
    }
};

// Handles the backoff event by reemitting it.
FunctionCall.prototype.handleBackoff_ = function(number, delay, err) {
    this.emit('backoff', number, delay, err);
};

module.exports = FunctionCall;

},{"./backoff":713,"./strategy/fibonacci":716,"events":1737,"precond":1718,"util":1769}],715:[function(require,module,exports){
//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var util = require('util');
var precond = require('precond');

var BackoffStrategy = require('./strategy');

// Exponential backoff strategy.
function ExponentialBackoffStrategy(options) {
    BackoffStrategy.call(this, options);
    this.backoffDelay_ = 0;
    this.nextBackoffDelay_ = this.getInitialDelay();
    this.factor_ = ExponentialBackoffStrategy.DEFAULT_FACTOR;

    if (options && options.factor !== undefined) {
        precond.checkArgument(options.factor > 1,
            'Exponential factor should be greater than 1 but got %s.',
            options.factor);
        this.factor_ = options.factor;
    }
}
util.inherits(ExponentialBackoffStrategy, BackoffStrategy);

// Default multiplication factor used to compute the next backoff delay from
// the current one. The value can be overridden by passing a custom factor as
// part of the options.
ExponentialBackoffStrategy.DEFAULT_FACTOR = 2;

ExponentialBackoffStrategy.prototype.next_ = function() {
    this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
    this.nextBackoffDelay_ = this.backoffDelay_ * this.factor_;
    return this.backoffDelay_;
};

ExponentialBackoffStrategy.prototype.reset_ = function() {
    this.backoffDelay_ = 0;
    this.nextBackoffDelay_ = this.getInitialDelay();
};

module.exports = ExponentialBackoffStrategy;

},{"./strategy":717,"precond":1718,"util":1769}],716:[function(require,module,exports){
//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var util = require('util');

var BackoffStrategy = require('./strategy');

// Fibonacci backoff strategy.
function FibonacciBackoffStrategy(options) {
    BackoffStrategy.call(this, options);
    this.backoffDelay_ = 0;
    this.nextBackoffDelay_ = this.getInitialDelay();
}
util.inherits(FibonacciBackoffStrategy, BackoffStrategy);

FibonacciBackoffStrategy.prototype.next_ = function() {
    var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
    this.nextBackoffDelay_ += this.backoffDelay_;
    this.backoffDelay_ = backoffDelay;
    return backoffDelay;
};

FibonacciBackoffStrategy.prototype.reset_ = function() {
    this.nextBackoffDelay_ = this.getInitialDelay();
    this.backoffDelay_ = 0;
};

module.exports = FibonacciBackoffStrategy;

},{"./strategy":717,"util":1769}],717:[function(require,module,exports){
//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var events = require('events');
var util = require('util');

function isDef(value) {
    return value !== undefined && value !== null;
}

// Abstract class defining the skeleton for the backoff strategies. Accepts an
// object holding the options for the backoff strategy:
//
//  * `randomisationFactor`: The randomisation factor which must be between 0
//     and 1 where 1 equates to a randomization factor of 100% and 0 to no
//     randomization.
//  * `initialDelay`: The backoff initial delay in milliseconds.
//  * `maxDelay`: The backoff maximal delay in milliseconds.
function BackoffStrategy(options) {
    options = options || {};

    if (isDef(options.initialDelay) && options.initialDelay < 1) {
        throw new Error('The initial timeout must be greater than 0.');
    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {
        throw new Error('The maximal timeout must be greater than 0.');
    }

    this.initialDelay_ = options.initialDelay || 100;
    this.maxDelay_ = options.maxDelay || 10000;

    if (this.maxDelay_ <= this.initialDelay_) {
        throw new Error('The maximal backoff delay must be ' +
                        'greater than the initial backoff delay.');
    }

    if (isDef(options.randomisationFactor) &&
        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {
        throw new Error('The randomisation factor must be between 0 and 1.');
    }

    this.randomisationFactor_ = options.randomisationFactor || 0;
}

// Gets the maximal backoff delay.
BackoffStrategy.prototype.getMaxDelay = function() {
    return this.maxDelay_;
};

// Gets the initial backoff delay.
BackoffStrategy.prototype.getInitialDelay = function() {
    return this.initialDelay_;
};

// Template method that computes and returns the next backoff delay in
// milliseconds.
BackoffStrategy.prototype.next = function() {
    var backoffDelay = this.next_();
    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;
    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);
    return randomizedDelay;
};

// Computes and returns the next backoff delay. Intended to be overridden by
// subclasses.
BackoffStrategy.prototype.next_ = function() {
    throw new Error('BackoffStrategy.next_() unimplemented.');
};

// Template method that resets the backoff delay to its initial value.
BackoffStrategy.prototype.reset = function() {
    this.reset_();
};

// Resets the backoff delay to its initial value. Intended to be overridden by
// subclasses.
BackoffStrategy.prototype.reset_ = function() {
    throw new Error('BackoffStrategy.reset_() unimplemented.');
};

module.exports = BackoffStrategy;

},{"events":1737,"util":1769}],718:[function(require,module,exports){
'use strict';

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

// Note: this file is written using commonjs instead of import/export to
// simplify consumption by those less familiar with the current state of
// JavaScript modularization

/* eslint camelcase: [0] */

require('@ciscospark/plugin-authorization');
require('@ciscospark/plugin-phone');
// explicitly load wdm, since we're relying on preDiscoveryServices and the
// url interceptor
require('@ciscospark/internal-plugin-wdm');
require('@ciscospark/plugin-logger');
require('@ciscospark/plugin-messages');
require('@ciscospark/plugin-memberships');
require('@ciscospark/plugin-people');
require('@ciscospark/plugin-rooms');
require('@ciscospark/plugin-teams');
require('@ciscospark/plugin-team-memberships');
require('@ciscospark/plugin-webhooks');

var merge = require('lodash/merge');
var SparkCore = require('@ciscospark/spark-core').default;

var config = require('./config');

// documentation.js puts hashes in relative urls, so need to specify full urls
// here
/**
 * See {@link https://webex.github.io/spark-js-sdk/example/browsers|Browser Guide} and
 * {@link https://webex.github.io/spark-js-sdk/example/servers|Server Guide}
 * @see {@link /example/browsers|Browser Guide}
 * @see {@link /example/servers|Server Guide}
 * @class CiscoSpark
 */
var CiscoSpark = SparkCore.extend({
  ciscospark: true,
  version: '1.32.6'
});

CiscoSpark.version = '1.32.6';

/**
 * Create a new {@link CiscoSpark} instance
 *
 * @example
 * <caption>Create a new CiscoSpark instance configured for your OAuth client</caption>
 * const ciscospark = CiscoSpark.init({
 *   config: {
 *     credentials: {
 *       authorizationString: `<AUTHORIZATION URL FROM DEVELOPER PORTAL>`
 *     }
 *   }
 * });
 *
 * @example
 * <caption>Create a new CiscoSpark instance configured for a Bot</caption>
 * const ciscospark = CiscoSpark.init({
 *   config: {
 *     credentials: `<BOT TOKEN FROM DEVELOPER PORTAL>`
 *   }
 * });
 *
 *
 * @param {Object} attrs
 * @param {Object} attrs.config (optional)
 * @memberof CiscoSpark
 * @returns {CiscoSpark}
 */
CiscoSpark.init = function init() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  attrs.config = merge({}, config, attrs.config);
  return new CiscoSpark(attrs);
};

module.exports = CiscoSpark;


},{"./config":720,"@ciscospark/internal-plugin-wdm":777,"@ciscospark/plugin-authorization":784,"@ciscospark/plugin-logger":786,"@ciscospark/plugin-memberships":101,"@ciscospark/plugin-messages":196,"@ciscospark/plugin-people":789,"@ciscospark/plugin-phone":798,"@ciscospark/plugin-rooms":291,"@ciscospark/plugin-team-memberships":386,"@ciscospark/plugin-teams":481,"@ciscospark/plugin-webhooks":576,"@ciscospark/spark-core":804,"lodash/merge":1674}],719:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sparkCore = require('@ciscospark/spark-core');

var _storageAdapterLocalStorage = require('@ciscospark/storage-adapter-local-storage');

var _storageAdapterLocalStorage2 = _interopRequireDefault(_storageAdapterLocalStorage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

exports.default = {
  boundedAdapter: new _storageAdapterLocalStorage2.default('ciscospark'),
  unboundedAdapter: _sparkCore.MemoryStoreAdapter
};


},{"@ciscospark/spark-core":804,"@ciscospark/storage-adapter-local-storage":837}],720:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _configStorage = require('./config-storage');

var _configStorage2 = _interopRequireDefault(_configStorage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  hydraServiceUrl: process.env.HYDRA_SERVICE_URL || 'https://api.ciscospark.com/v1',
  credentials: {
    clientType: 'confidential'
  },
  device: {
    ephemeral: true
  },
  storage: _configStorage2.default
}; /*!
    * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
    */


}).call(this,require('_process'))
},{"./config-storage":719,"_process":1743}],721:[function(require,module,exports){
(function (global){
'use strict';

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/* istanbul ignore else */
if (!global._babelPolyfill) {
  /* eslint global-require: [0] */
  require('babel-polyfill');
}

module.exports = require('./ciscospark');

/**
 * The date and time, specified in ISO 8601 extended offset date/time
 * format (e.g. `2015-10-18T14:26:16+00:00`).
 *
 * @typedef {string} isoDate
 */

/**
 * An email address, as a string.
 * @typedef {string} email
 */


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./ciscospark":718,"babel-polyfill":677}],722:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"buffer":1735,"dup":3,"urlsafe-base64":1730}],723:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":4}],724:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],725:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":6}],726:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"_process":1743,"core-decorators":841,"dup":7}],727:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"babel-runtime/core-js/reflect/apply":695,"dup":8,"lodash/isArray":1648}],728:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"babel-runtime/core-js/array/from":678,"babel-runtime/core-js/object/create":685,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/set-prototype-of":692,"babel-runtime/core-js/reflect/construct":696,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":9}],729:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],730:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./node":729,"dup":11}],731:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./base64":722,"./capped-debounce":723,"./check-required":724,"./defer":725,"./deprecated":726,"./events":727,"./exception":728,"./in-browser":730,"./make-state-datatype":732,"./one-flight":733,"./patterns.js":734,"./resolve-with":735,"./retry":736,"./tap":737,"./template-container":738,"./while-in-flight":739,"dup":12}],732:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],733:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./template-container":738,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/typeof":711,"dup":14,"lodash/wrap":1715}],734:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],735:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":16}],736:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/typeof":711,"backoff":712,"dup":17,"events":1737,"lodash/defaults":1618,"lodash/isFunction":1656,"lodash/wrap":1715}],737:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"babel-runtime/core-js/promise":694,"dup":18}],738:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":19,"util":1769}],739:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./tap":737,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":20,"lodash/wrap":1715}],740:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":121}],741:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"./http-error-subtypes":740,"@ciscospark/common":731,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/values":693,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"dup":122,"lodash/pick":1685}],742:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./http-error":741,"./interceptors/http-status":743,"./lib/detect":744,"./lib/interceptor":745,"./progress-event":747,"./request":748,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/reflect/get-own-property-descriptor":699,"dup":123,"lodash/assign":1606,"lodash/curry":1615,"lodash/defaults":1618,"lodash/isString":1662}],743:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"../http-error":741,"../lib/interceptor":745,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":124}],744:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"@ciscospark/common":731,"babel-runtime/core-js/promise":694,"dup":125,"file-type":1309}],745:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":126}],746:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"babel-runtime/core-js/json/stringify":681,"dup":127,"global/window":1311,"is-function":1312,"parse-headers":1717,"xtend":1732}],747:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"babel-runtime/core-js/number/is-nan":683,"babel-runtime/core-js/object/define-properties":686,"dup":128,"lodash/isNumber":1658}],748:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"./request":749,"@ciscospark/common":731,"babel-runtime/core-js/promise":694,"dup":129,"events":1737}],749:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"../lib/detect":744,"../lib/xhr":746,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/typeof":711,"dup":130,"lodash/defaults":1618,"lodash/isArray":1648,"lodash/pick":1685,"qs":860}],750:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

exports.default = {
  feature: {}
};


},{}],751:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _partition2 = require('lodash/partition');

var _partition3 = _interopRequireDefault(_partition2);

require('@ciscospark/internal-plugin-wdm');

var _sparkCore = require('@ciscospark/spark-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var Feature = _sparkCore.SparkPlugin.extend({
  namespace: 'Feature',

  /**
   * Returns the value of the requested feature toggle.
   * @param {string} keyType <developer|user|entitlement>
   * @param {string} key
   * @param {Object} options
   * @param {boolean} options.full to get full feature record including metadata.
   * @returns {string|boolean|number|FeatureModel|null}
   */
  getFeature: function getFeature(keyType, key, options) {
    if (keyType !== 'developer' && keyType !== 'user' && keyType !== 'entitlement') {
      return _promise2.default.reject(new Error('Invalid feature keyType provided. Only `developer`, `user`, and `entitlement` feature toggles are permitted.'));
    }

    options = options || {};

    var feature = this.spark.internal.device.features[keyType].get(key);

    if (!feature) {
      return _promise2.default.resolve(null);
    }

    if (options.full) {
      return _promise2.default.resolve(feature.serialize());
    }

    return _promise2.default.resolve(feature.value);
  },


  /**
   * Issues request to server to set a value for a feature toggle.
   * @param {string} keyType <developer|user>
   * @param {string} key
   * @param {string} value
   * @returns {Promise} Refreshes the local device and resolves with the features endpoint's response.
   */
  setFeature: function setFeature(keyType, key, value) {
    var _this = this;

    // Limit only to developer feature toggles for now.
    if (keyType !== 'developer' && keyType !== 'user') {
      return _promise2.default.reject(new Error('Only `developer` and `user` feature toggles can be set.'));
    }

    return this.request({
      method: 'POST',
      api: 'feature',
      resource: 'features/users/' + this.spark.internal.device.userId + '/' + keyType,
      body: {
        key: key,
        mutable: true,
        val: value
      }
    }).then(function (res) {
      return _this.spark.internal.device.features[keyType].add(res.body, { merge: true });
    });
  },


  /**
   * Issues request to server to set a value for a feature toggle.
   * @param {array} featureList
   * @returns {Promise} Refreshes the local device and resolves with the features endpoint`s response.
   */
  setBundledFeatures: function setBundledFeatures(featureList) {
    var _this2 = this;

    featureList.forEach(function (item) {
      item.mutable = item.mutable || 'true';
      if (item.type !== 'USER' && item.type !== 'DEV') {
        item.type = 'USER';
      }
    });

    return this.request({
      method: 'POST',
      api: 'feature',
      resource: 'features/users/' + this.spark.internal.device.userId + '/toggles',
      body: featureList
    }).then(function (res) {
      var partitionedToggles = (0, _partition3.default)(res.body.featureToggles, { type: 'USER' });
      _this2.spark.internal.device.features.user.add(partitionedToggles[0], { merge: true });
      _this2.spark.internal.device.features.developer.add(partitionedToggles[1], { merge: true });
    });
  },
  initialize: function initialize() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.initialize, this, args);

    this.listenToAndRun(this.spark, 'change:internal.device.features.developer', this.trigger.bind(this, 'change:developer'));
    this.listenToAndRun(this.spark, 'change:internal.device.features.entitlement', this.trigger.bind(this, 'change:entitlement'));
    this.listenToAndRun(this.spark, 'change:internal.device.features.user', this.trigger.bind(this, 'change:user'));
  },
  version: '1.32.5'
});

exports.default = Feature;


},{"@ciscospark/internal-plugin-wdm":777,"@ciscospark/spark-core":804,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"lodash/partition":1684}],752:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _feature = require('./feature');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_feature).default;
  }
});

var _sparkCore = require('@ciscospark/spark-core');

var _feature2 = _interopRequireDefault(_feature);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _sparkCore.registerInternalPlugin)('feature', _feature2.default, {
  config: _config2.default
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */


},{"./config":750,"./feature":751,"@ciscospark/spark-core":804}],753:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var locusEventKeys = exports.locusEventKeys = ['locus.summary', 'locus.self_changed', 'locus.participant_joined', 'locus.participant_left', 'locus.participant_declined', 'locus.participant_alerted', 'locus.participant_updated', 'locus.participant_roles_updated', 'locus.participant_audio_muted', 'locus.participant_audio_unmuted', 'locus.participant_video_muted', 'locus.participant_video_unmuted', 'locus.floor_granted', 'locus.floor_released', 'locus.space_users_modified', 'locus.controls_updated', 'locus.participant_controls_updated'];

exports.default = locusEventKeys;


},{}],754:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DESYNC = exports.LESS_THAN = exports.GREATER_THAN = exports.FETCH = exports.EQUAL = exports.USE_CURRENT = exports.USE_INCOMING = exports.eventKeys = undefined;

var _eventKeys = require('./event-keys');

Object.defineProperty(exports, 'eventKeys', {
  enumerable: true,
  get: function get() {
    return _eventKeys.locusEventKeys;
  }
});

var _locus = require('./locus');

Object.defineProperty(exports, 'USE_INCOMING', {
  enumerable: true,
  get: function get() {
    return _locus.USE_INCOMING;
  }
});
Object.defineProperty(exports, 'USE_CURRENT', {
  enumerable: true,
  get: function get() {
    return _locus.USE_CURRENT;
  }
});
Object.defineProperty(exports, 'EQUAL', {
  enumerable: true,
  get: function get() {
    return _locus.EQUAL;
  }
});
Object.defineProperty(exports, 'FETCH', {
  enumerable: true,
  get: function get() {
    return _locus.FETCH;
  }
});
Object.defineProperty(exports, 'GREATER_THAN', {
  enumerable: true,
  get: function get() {
    return _locus.GREATER_THAN;
  }
});
Object.defineProperty(exports, 'LESS_THAN', {
  enumerable: true,
  get: function get() {
    return _locus.LESS_THAN;
  }
});
Object.defineProperty(exports, 'DESYNC', {
  enumerable: true,
  get: function get() {
    return _locus.DESYNC;
  }
});

require('@ciscospark/internal-plugin-mercury');

var _sparkCore = require('@ciscospark/spark-core');

var _locus2 = _interopRequireDefault(_locus);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _sparkCore.registerInternalPlugin)('locus', _locus2.default); /*!
                                                                   * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                                                   */

exports.default = _locus2.default;


},{"./event-keys":753,"./locus":755,"@ciscospark/internal-plugin-mercury":758,"@ciscospark/spark-core":804}],755:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DESYNC = exports.LESS_THAN = exports.GREATER_THAN = exports.FETCH = exports.EQUAL = exports.USE_CURRENT = exports.USE_INCOMING = undefined;

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _memoize2 = require('lodash/memoize');

var _memoize3 = _interopRequireDefault(_memoize2);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _first2 = require('lodash/first');

var _first3 = _interopRequireDefault(_first2);

var _difference2 = require('lodash/difference');

var _difference3 = _interopRequireDefault(_difference2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _sparkCore = require('@ciscospark/spark-core');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var USE_INCOMING = exports.USE_INCOMING = 'USE_INCOMING';
var USE_CURRENT = exports.USE_CURRENT = 'USE_CURRENT';
var EQUAL = exports.EQUAL = 'EQUAL';
var FETCH = exports.FETCH = 'FETCH';
var GREATER_THAN = exports.GREATER_THAN = 'GREATER_THAN';
var LESS_THAN = exports.LESS_THAN = 'LESS_THAN';
var DESYNC = exports.DESYNC = 'DESYNC';

/**
 * Transates the result of a sequence comparison into an intended behavior
 * @param {string} result
 * @private
 * @returns {string}
 */
function compareToAction(result) {
  switch (result) {
    case EQUAL:
    case GREATER_THAN:
      return USE_CURRENT;
    case LESS_THAN:
      return USE_INCOMING;
    case DESYNC:
      return FETCH;
    default:
      throw new Error(result + ' is not a recognized sequence comparison result');
  }
}

/**
 * @class
 */
var Locus = _sparkCore.SparkPlugin.extend({
  namespace: 'Locus',

  /**
   * Alert the specified locus that the local user has been notified of the
   * locus's active state
   * @instance
   * @memberof Locus
   * @param {Types~Locus} locus
   * @returns {Promise}
   */
  alert: function alert(locus) {
    return this.request({
      method: 'PUT',
      uri: locus.url + '/participant/alert',
      body: {
        deviceUrl: this.spark.internal.device.url,
        sequence: locus.sequence
      }
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Compares two loci to determine which one contains the most recent state
   * @instance
   * @memberof Locus
   * @param {Types~Locus} current
   * @param {Types~Locus} incoming
   * @returns {string} one of USE_INCOMING, USE_CURRENT, or FETCH
   */
  compare: function compare(current, incoming) {
    /**
     * Determines if a paricular locus's sequence is empty
     * @param {Types~Locus} locus
     * @private
     * @returns {bool}
     */
    function isEmpty(locus) {
      var sequence = locus.sequence;

      return (!sequence.entries || !sequence.entries.length) && sequence.rangeStart === 0 && sequence.rangeEnd === 0;
    }

    if (isEmpty(current) || isEmpty(incoming)) {
      return USE_INCOMING;
    }

    if (incoming.baseSequence) {
      return this.compareDelta(current, incoming);
    }

    return compareToAction(this.compareSequence(current.sequence, incoming.sequence));
  },


  /**
   * Compares two loci sequences (with delta params) and indicates what action
   * to take.
   * @instance
   * @memberof Locus
   * @param {Types~Locus} current
   * @param {Types~Locus} incoming
   * @private
   * @returns {string} one of USE_INCOMING, USE_CURRENT, or FETCH
   */
  compareDelta: function compareDelta(current, incoming) {
    var ret = this.compareSequence(current.sequence, incoming.sequence);
    if (ret !== LESS_THAN) {
      return compareToAction(ret);
    }

    ret = this.compareSequence(current.sequence, incoming.baseSequence);

    switch (ret) {
      case GREATER_THAN:
      case EQUAL:
        return USE_INCOMING;
      default:
        return FETCH;
    }
  },


  /**
   * Compares two Locus sequences
   * @instance
   * @memberof Locus
   * @param {LocusSequence} current
   * @param {LocusSequence} incoming
   * @returns {string} one of LESS_THAN, GREATER_THAN, EQUAL, or DESYNC
   */
  compareSequence: function compareSequence(current, incoming) {
    if (!current) {
      throw new Error('`current` is required');
    }

    if (!incoming) {
      throw new Error('`incoming` is required');
    }
    // complexity here is unavoidable
    /* eslint complexity: [0] */
    /* eslint max-statements: [0] */

    // must pick one of arrow-body-style or no-confusing-arrow to disable
    /* eslint arrow-body-style: [0] */

    // after running the #compare() test suite in a loop, there doesn't seem to
    // be any appreciable difference when used with or without memoize; since
    // real locus sequences are likely to contain more sequence numbers than
    // those in the test suite, I have to assume memoize can only help and the
    // overhead of memoizing these methods is not a problem.

    var getEntriesFirstValue = (0, _memoize3.default)(function (sequence) {
      return sequence.entries.length === 0 ? 0 : (0, _first3.default)(sequence.entries);
    });
    var getEntriesLastValue = (0, _memoize3.default)(function (sequence) {
      return sequence.entries.length === 0 ? 0 : (0, _last3.default)(sequence.entries);
    });
    var getCompareFirstValue = (0, _memoize3.default)(function (sequence) {
      return sequence.rangeStart || getEntriesFirstValue(sequence);
    });
    var getCompareLastValue = (0, _memoize3.default)(function (sequence) {
      return getEntriesLastValue(sequence) || sequence.rangeEnd;
    });
    /**
     * @param {number} entry
     * @param {LocusSequence} sequence
     * @private
     * @returns {Boolean}
     */
    function inRange(entry, sequence) {
      return entry >= sequence.rangeStart && entry <= sequence.rangeEnd;
    }

    if (getCompareFirstValue(current) > getCompareLastValue(incoming)) {
      return GREATER_THAN;
    }

    if (getCompareLastValue(current) < getCompareFirstValue(incoming)) {
      return LESS_THAN;
    }

    var currentOnlyEntries = (0, _difference3.default)(current.entries, incoming.entries);
    var incomingOnlyEntries = (0, _difference3.default)(incoming.entries, current.entries);
    var currentOnly = [];
    var incomingOnly = [];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(currentOnlyEntries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var i = _step.value;

        if (!inRange(i, incoming)) {
          currentOnly.push(i);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)(incomingOnlyEntries), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _i = _step2.value;

        if (!inRange(_i, current)) {
          incomingOnly.push(_i);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    if (!currentOnly.length && !incomingOnly.length) {
      if (current.rangeEnd - getCompareFirstValue(current) > incoming.rangeEnd - getCompareFirstValue(incoming)) {
        return GREATER_THAN;
      }

      if (current.rangeEnd - getCompareFirstValue(current) < incoming.rangeEnd - getCompareFirstValue(incoming)) {
        return LESS_THAN;
      }

      return EQUAL;
    }

    if (currentOnly.length && !incomingOnly.length) {
      return GREATER_THAN;
    }

    if (!currentOnly.length && incomingOnly.length) {
      return LESS_THAN;
    }

    if (!current.rangeStart && !current.rangeEnd && !incoming.rangeStart && !incoming.rangeEnd) {
      return DESYNC;
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = (0, _getIterator3.default)(currentOnly), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _i2 = _step3.value;

        if (getCompareFirstValue(incoming) < _i2 && _i2 < getCompareLastValue(incoming)) {
          return DESYNC;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = (0, _getIterator3.default)(incomingOnly), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var _i3 = _step4.value;

        if (getCompareFirstValue(current) < _i3 && _i3 < getCompareLastValue(current)) {
          return DESYNC;
        }
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    if (currentOnly[0] > incomingOnly[0]) {
      return GREATER_THAN;
    }

    return LESS_THAN;
  },


  /**
   * Calls the specified invitee and offers the specified media via
   * options.localSdp
   * @instance
   * @memberof Locus
   * @param {string} invitee
   * @param {Object} options
   * @param {Object} options.localSdp
   * @returns {Promise<Types~Locus>}
   */
  create: function create(invitee) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var correlationId = options.correlationId;


    if (!correlationId) {
      throw new Error('options.correlationId is required');
    }

    return this.request({
      method: 'POST',
      service: 'locus',
      resource: 'loci/call',
      body: {
        correlationId: correlationId,
        deviceUrl: this.spark.internal.device.url,
        invitee: {
          invitee: invitee
        },
        localMedias: [{
          localSdp: (0, _stringify2.default)({
            type: 'SDP',
            sdp: options.localSdp
          })
        }],
        sequence: {
          entries: [],
          rangeStart: 0,
          rangeEnd: 0
        }
      }
    })
    // res.body.mediaConnections is deprecated so just return the locus
    .then(function (res) {
      return res.body.locus;
    });
  },


  /**
   * This is mostly an internal function to simplify the phone plugin. Decides
   * which path to call based on the type of the thing being joined.
   * @instance
   * @memberof Locus
   * @param {Object|Types~Locus} target
   * @param {Object} options
   * @private
   * @returns {Promise<Types~Locus>}
   */
  createOrJoin: function createOrJoin(target, options) {
    if (target.url) {
      return this.join(target, options);
    }
    return this.create(target, options);
  },


  /**
   * Decline to join the specified Locus
   * @instance
   * @memberof Locus
   * @param {Types~Locus} locus
   * @returns {Promise<Types~Locus>}
   */
  decline: function decline(locus) {
    var _this = this;

    return this.request({
      method: 'PUT',
      uri: locus.url + '/participant/decline',
      body: {
        deviceUrl: this.spark.internal.device.url,
        sequence: locus.sequence
      }
    }).then(function (res) {
      return res.body;
    }).catch(function (reason) {
      if (reason instanceof _sparkCore.SparkHttpError.Conflict) {
        return _this.get(locus);
      }
      return _promise2.default.reject(reason);
    });
  },


  /**
   * Retrieves a single Locus
   * @instance
   * @memberof Locus
   * @param {Types~Locus} locus
   * @returns {Types~Locus}
   */
  get: function get(locus) {
    return this.request({
      method: 'GET',
      uri: '' + locus.url
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Retrieves the call history for the current user
   * @instance
   * @memberof Locus
   * @param {Object} options
   * @param {Date|number} options.from
   * @returns {Promise<Object>}
   */
  getCallHistory: function getCallHistory() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var from = new Date(options.from || Date.now()).toISOString();

    return this.request({
      method: 'GET',
      service: 'janus',
      resource: 'history/userSessions',
      qs: { from: from }
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Join the specified Locus and offer to send it media
   * @instance
   * @memberof Locus
   * @param {Types~Locus} locus
   * @param {Object} options
   * @param {Object} options.localSdp
   * @returns {Types~Locus}
   */
  join: function join(locus) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var correlationId = locus.correlationId || options.correlationId;

    if (!correlationId) {
      throw new Error('locus.correlationId or options.correlationId is required');
    }

    return this.request({
      method: 'POST',
      uri: locus.url + '/participant',
      body: {
        correlationId: correlationId,
        deviceUrl: this.spark.internal.device.url,
        localMedias: [{
          localSdp: (0, _stringify2.default)({
            type: 'SDP',
            sdp: options.localSdp
          })
        }],
        sequence: locus.sequence || {
          entries: [],
          rangeStart: 0,
          rangeEnd: 0
        }
      }
    })
    // The mediaConnections object is deprecated, so just return the locus
    .then(function (res) {
      return res.body.locus;
    });
  },


  /**
   * Leave the specified Locus
   * @instance
   * @memberof Locus
   * @param {Types~Locus} locus
   * @returns {Promise<Types~Locus>}
   */
  leave: function leave(locus) {
    var _this2 = this;

    return this.request({
      method: 'PUT',
      uri: locus.self.url + '/leave',
      body: {
        deviceUrl: this.spark.internal.device.url,
        sequence: locus.sequence
      }
    }).then(function (res) {
      return res.body.locus;
    }).catch(function (reason) {
      if (reason instanceof _sparkCore.SparkHttpError.Conflict) {
        return _this2.get(locus);
      }
      return _promise2.default.reject(reason);
    });
  },


  /**
   * Lists active loci
   * @instance
   * @memberof Locus
   * @returns {Promise<Array<Types~Locus>>}
   */
  list: function list() {
    return this.request({
      method: 'GET',
      service: 'locus',
      resource: 'loci'
    }).then(function (res) {
      return res.body.loci;
    });
  },


  /**
   * Merges two locus DTOs (for the same locus)
   * @instance
   * @memberof Locus
   * @param {Types~Locus} current
   * @param {Types~Locus|Types~LocusDelta} incoming
   * @returns {Type~Locus}
   */
  merge: function merge(current, incoming) {
    // if incoming is not a delta event, treat it as a new full locus.
    if (!incoming.baseSequence) {
      return incoming;
    }

    var next = (0, _cloneDeep3.default)(current);

    // 1. All non-null elements in the delta event except the "baseSequence" and
    // the "participants" collection should be used to replace their existing
    // values.
    (0, _keys2.default)(incoming).forEach(function (key) {
      if (key === 'baseSequence' || key === 'participants') {
        return;
      }

      next[key] = incoming[key] || next[key];
    });

    // 2. The "baseSequence" in the delta event can be discarded (it doesn't
    // need to be maintained in the local working copy).

    if (incoming.participants || incoming.participants.length) {
      var toRemove = new _set2.default();
      var toUpsert = new _map2.default();

      incoming.participants.forEach(function (p) {
        if (p.removed) {
          // Elements of the delta event's "participants" list with the
          // attribute `removed=true` should be removed from the working copy's
          // "participants" collection.
          toRemove.add(p.url);
        } else {
          // Elements of the delta events "participants" list that are absent
          // from the local working copy should be added to that collection.
          toUpsert.set(p.url, p);
        }
      });

      // The "participants" collection in the delta event should be merged with
      // that of the local working copy of the Locus such that elements in the
      // delta event's "participants" replace those with the same url value in
      // the working copy "participants" collection.
      var participants = next.participants.reduce(function (acc, p) {
        if (!toRemove.has(p.url)) {
          acc[p.url] = p;
        }
        return acc;
      }, {});

      toUpsert.forEach(function (value, key) {
        participants[key] = value;
      });

      next.participants = (0, _values2.default)(participants);
    }

    return next;
  },


  /**
   * Signals to locus that the current user is done sharing their additional
   * media stream
   * @param {Types~Locus} locus
   * @param {Types~MediaShare} share
   * @returns {Promise}
   */
  releaseFloorGrant: function releaseFloorGrant(locus, share) {
    return this.spark.request({
      uri: share.url,
      method: 'PUT',
      body: {
        floor: {
          disposition: 'RELEASED'
        }
      }
    }).then(function (_ref) {
      var body = _ref.body;
      return body;
    });
  },


  /**
   * Signals to locus that the current user would like to share an additional
   * media stream
   * @param {Types~Locus} locus
   * @param {Types~MediaShare} share
   * @returns {Promise}
   */
  requestFloorGrant: function requestFloorGrant(locus, share) {
    return this.spark.request({
      uri: share.url,
      method: 'PUT',
      body: {
        floor: {
          beneficiary: {
            url: locus.self.url,
            devices: [{ url: this.spark.internal.device.url }]
          },
          disposition: 'GRANTED'
        }
      }
    }).then(function (_ref2) {
      var body = _ref2.body;
      return body;
    });
  },


  /**
   * Sends a string of DTMF tones to the locus
   * @instance
   * @memberof Locus
   * @param {Types~Locus} locus
   * @param {string} tones
   * @returns {Promise}
   */
  sendDtmf: function sendDtmf(locus, tones) {
    return this.request({
      method: 'POST',
      uri: locus.self.url + '/sendDtmf',
      body: {
        deviceUrl: this.spark.internal.device.url,
        dtmf: {
          correlationId: _uuid2.default.v4(),
          tones: tones
        }
      }
    });
  },


  /**
   * Fetches the delta for the locus from its syncUrl. *Does not merge*
   * @instance
   * @memberof Locus
   * @param {Types~Locus} locus
   * @returns {Types~LocusDelta}
   */
  sync: function sync(locus) {
    return this.request({
      method: 'GET',
      uri: locus.syncUrl
    })
    // the api may return a 204 no content, so we'll give back an empty
    // object in that case.
    .then(function (res) {
      return res.body || {};
    });
  },


  /**
   * Send a new sdp to Linus via the Locus API to update media state (e.g. to
   * start or stop sending audio or video)
   * @instance
   * @memberof Locus
   * @param {Types~Locus} locus
   * @param {Object} options
   * @param {string} options.localSdp
   * @param {string} options.mediaId
   * @param {Boolean} options.audioMuted
   * @param {Boolean} options.videoMuted
   * @returns {Promise<Types~Locus>}
   */
  updateMedia: function updateMedia(locus, _ref3) {
    var sdp = _ref3.sdp,
        audioMuted = _ref3.audioMuted,
        videoMuted = _ref3.videoMuted,
        mediaId = _ref3.mediaId;

    return this.request({
      method: 'PUT',
      uri: locus.self.url + '/media',
      body: {
        deviceUrl: this.spark.internal.device.url,
        localMedias: [{
          type: 'SDP',
          localSdp: (0, _stringify2.default)({
            type: 'SDP',
            sdp: sdp,
            audioMuted: audioMuted,
            videoMuted: videoMuted
          }),
          mediaId: mediaId
        }]
      },
      sequence: locus.sequence
    }).then(function (res) {
      return res.body.locus;
    });
  },
  version: '1.32.5'
});

exports.default = Locus;


},{"@ciscospark/spark-core":804,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/object/values":693,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/set":700,"lodash/cloneDeep":1612,"lodash/difference":1621,"lodash/first":1629,"lodash/last":1669,"lodash/memoize":1673,"uuid":868}],756:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

exports.default = {
  mercury: {
    /**
     * Milliseconds between pings sent up the socket
     * @type {number}
     */
    pingInterval: process.env.MERCURY_PING_INTERVAL || 15000,
    /**
     * Milliseconds to wait for a pong before declaring the connection dead
     * @type {number}
     */
    pongTimeout: process.env.MERCURY_PONG_TIMEOUT || 14000,
    /**
     * Maximum milliseconds between connection attempts
     * @type {Number}
     */
    backoffTimeMax: process.env.MERCURY_BACKOFF_TIME_MAX || 32000,
    /**
     * Initial milliseconds between connection attempts
     * @type {Number}
     */
    backoffTimeReset: process.env.MERCURY_BACKOFF_TIME_RESET || 1000,
    /**
     * Milliseconds to wait for a close frame before declaring the socket dead and
     * discarding it
     * @type {[type]}
     */
    forceCloseDelay: process.env.MERCURY_FORCE_CLOSE_DELAY || 2000
  }
};


}).call(this,require('_process'))
},{"_process":1743}],757:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Forbidden = exports.NotAuthorized = exports.BadRequest = exports.UnknownResponse = exports.ConnectionError = undefined;

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class, _temp, _class2, _temp2, _class3, _temp3, _class4, _temp4, _class5, _temp5; /*!
                                                                                        * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                                                                        */

var _common = require('@ciscospark/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Exception thrown when a websocket gets closed
 */
var ConnectionError = exports.ConnectionError = (_temp = _class = function (_Exception) {
  (0, _inherits3.default)(ConnectionError, _Exception);

  function ConnectionError() {
    (0, _classCallCheck3.default)(this, ConnectionError);
    return (0, _possibleConstructorReturn3.default)(this, (ConnectionError.__proto__ || (0, _getPrototypeOf2.default)(ConnectionError)).apply(this, arguments));
  }

  (0, _createClass3.default)(ConnectionError, [{
    key: 'parse',


    /**
     * @param {CloseEvent} event
     * @returns {string}
     */
    value: function parse() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      (0, _defineProperties2.default)(this, {
        code: {
          value: event.code
        },
        reason: {
          value: event.reason
        }
      });

      return event.reason;
    }
  }]);
  return ConnectionError;
}(_common.Exception), _class.defaultMessage = 'Failed to connect to socket', _temp);

/**
 * thrown for CloseCode 4400
 */

var UnknownResponse = exports.UnknownResponse = (_temp2 = _class2 = function (_ConnectionError) {
  (0, _inherits3.default)(UnknownResponse, _ConnectionError);

  function UnknownResponse() {
    (0, _classCallCheck3.default)(this, UnknownResponse);
    return (0, _possibleConstructorReturn3.default)(this, (UnknownResponse.__proto__ || (0, _getPrototypeOf2.default)(UnknownResponse)).apply(this, arguments));
  }

  return UnknownResponse;
}(ConnectionError), _class2.defaultMessage = 'UnknownResponse is produced by IE when we receive a 4XXX. You probably want to treat this like a NotFound', _temp2);

/**
 * thrown for CloseCode 4400
 */

var BadRequest = exports.BadRequest = (_temp3 = _class3 = function (_ConnectionError2) {
  (0, _inherits3.default)(BadRequest, _ConnectionError2);

  function BadRequest() {
    (0, _classCallCheck3.default)(this, BadRequest);
    return (0, _possibleConstructorReturn3.default)(this, (BadRequest.__proto__ || (0, _getPrototypeOf2.default)(BadRequest)).apply(this, arguments));
  }

  return BadRequest;
}(ConnectionError), _class3.defaultMessage = 'BadRequest usually implies an attempt to use service account credentials', _temp3);

/**
 * thrown for CloseCode 4401
 */

var NotAuthorized = exports.NotAuthorized = (_temp4 = _class4 = function (_ConnectionError3) {
  (0, _inherits3.default)(NotAuthorized, _ConnectionError3);

  function NotAuthorized() {
    (0, _classCallCheck3.default)(this, NotAuthorized);
    return (0, _possibleConstructorReturn3.default)(this, (NotAuthorized.__proto__ || (0, _getPrototypeOf2.default)(NotAuthorized)).apply(this, arguments));
  }

  return NotAuthorized;
}(ConnectionError), _class4.defaultMessage = 'Please refresh your access token', _temp4);

/**
 * thrown for CloseCode 4403
 */

var Forbidden = exports.Forbidden = (_temp5 = _class5 = function (_ConnectionError4) {
  (0, _inherits3.default)(Forbidden, _ConnectionError4);

  function Forbidden() {
    (0, _classCallCheck3.default)(this, Forbidden);
    return (0, _possibleConstructorReturn3.default)(this, (Forbidden.__proto__ || (0, _getPrototypeOf2.default)(Forbidden)).apply(this, arguments));
  }

  return Forbidden;
}(ConnectionError), _class5.defaultMessage = 'Forbidden usually implies these credentials are not entitled for Spark', _temp5);

// /**
//  * thrown for CloseCode 4404
//  */
// export class NotFound extends ConnectionError {
//   static defaultMessage = `Please refresh your Mercury registration (typically via a WDM refresh)`;
// }


},{"@ciscospark/common":731,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],758:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnknownResponse = exports.NotAuthorized = exports.Forbidden = exports.ConnectionError = exports.BadRequest = exports.config = exports.Socket = exports.Mercury = exports.default = undefined;

var _mercury = require('./mercury');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_mercury).default;
  }
});
Object.defineProperty(exports, 'Mercury', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_mercury).default;
  }
});

var _socket = require('./socket');

Object.defineProperty(exports, 'Socket', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_socket).default;
  }
});

var _config = require('./config');

Object.defineProperty(exports, 'config', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_config).default;
  }
});

var _errors = require('./errors');

Object.defineProperty(exports, 'BadRequest', {
  enumerable: true,
  get: function get() {
    return _errors.BadRequest;
  }
});
Object.defineProperty(exports, 'ConnectionError', {
  enumerable: true,
  get: function get() {
    return _errors.ConnectionError;
  }
});
Object.defineProperty(exports, 'Forbidden', {
  enumerable: true,
  get: function get() {
    return _errors.Forbidden;
  }
});
Object.defineProperty(exports, 'NotAuthorized', {
  enumerable: true,
  get: function get() {
    return _errors.NotAuthorized;
  }
});
Object.defineProperty(exports, 'UnknownResponse', {
  enumerable: true,
  get: function get() {
    return _errors.UnknownResponse;
  }
});

require('@ciscospark/internal-plugin-wdm');

require('@ciscospark/internal-plugin-feature');

require('@ciscospark/internal-plugin-metrics');

var _sparkCore = require('@ciscospark/spark-core');

var _mercury2 = _interopRequireDefault(_mercury);

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

(0, _sparkCore.registerInternalPlugin)('mercury', _mercury2.default, {
  config: _config2.default,
  onBeforeLogout: function onBeforeLogout() {
    return this.disconnect();
  }
});


},{"./config":756,"./errors":757,"./mercury":759,"./socket":760,"@ciscospark/internal-plugin-feature":752,"@ciscospark/internal-plugin-metrics":767,"@ciscospark/internal-plugin-wdm":777,"@ciscospark/spark-core":804}],759:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _set2 = require('lodash/set');

var _set3 = _interopRequireDefault(_set2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _dec, _dec2, _desc, _value, _obj; /*!
                                       * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                       */

var _sparkCore = require('@ciscospark/spark-core');

var _common = require('@ciscospark/common');

var _string = require('string');

var _string2 = _interopRequireDefault(_string);

var _backoff = require('backoff');

var _backoff2 = _interopRequireDefault(_backoff);

var _socket = require('./socket');

var _socket2 = _interopRequireDefault(_socket);

var _errors = require('./errors');

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var normalReconnectReasons = ['idle', 'done (forced)', 'pong not received', 'pong mismatch'];

var Mercury = _sparkCore.SparkPlugin.extend((_dec = (0, _common.deprecated)('Mercury#listen(): Use Mercury#connect() instead'), _dec2 = (0, _common.deprecated)('Mercury#stopListening(): Use Mercury#disconnect() instead'), (_obj = {
  namespace: 'Mercury',

  session: {
    connected: {
      default: false,
      type: 'boolean'
    },
    connecting: {
      default: false,
      type: 'boolean'
    },
    socket: 'object',
    localClusterServiceUrls: 'object'
  },

  derived: {
    listening: {
      deps: ['connected'],
      fn: function fn() {
        return this.connected;
      }
    }
  },

  connect: function connect(webSocketUrl) {
    var _this = this;

    if (this.connected) {
      this.logger.info('mercury: already connected, will not connect again');
      return _promise2.default.resolve();
    }

    this.connecting = true;
    return _promise2.default.resolve(this.spark.internal.device.registered || this.spark.internal.device.register()).then(function () {
      _this.logger.info('mercury: connecting');

      return _this._connectWithBackoff(webSocketUrl);
    });
  },
  disconnect: function disconnect() {
    var _this2 = this;

    return new _promise2.default(function (resolve) {
      if (_this2.backoffCall) {
        _this2.logger.info('mercury: aborting connection');
        _this2.backoffCall.abort();
      }

      if (_this2.socket) {
        _this2.socket.removeAllListeners('message');
        _this2.once('offline', resolve);
        _this2.socket.close();
        return;
      }

      resolve();
    });
  },
  listen: function listen() {
    /* eslint no-invalid-this: [0] */
    return this.connect();
  },
  stopListening: function stopListening() {
    /* eslint no-invalid-this: [0] */
    return this.disconnect();
  },
  processRegistrationStatusEvent: function processRegistrationStatusEvent(message) {
    this.localClusterServiceUrls = message.localClusterServiceUrls;
  },
  _applyOverrides: function _applyOverrides(event) {
    if (!event.headers) {
      return;
    }
    var headerKeys = (0, _keys2.default)(event.headers);
    headerKeys.forEach(function (keyPath) {
      (0, _set3.default)(event, keyPath, event.headers[keyPath]);
    });
  },
  _prepareUrl: function _prepareUrl(webSocketUrl) {
    var _this3 = this;

    if (!webSocketUrl) {
      webSocketUrl = this.spark.internal.device.webSocketUrl;
    }

    return this.spark.internal.feature.getFeature('developer', 'web-ha-messaging').then(function (haMessagingEnabled) {
      if (haMessagingEnabled) {
        return _this3.spark.internal.device.useServiceCatalogUrl(webSocketUrl);
      }
      return webSocketUrl;
    }).then(function (wsUrl) {
      webSocketUrl = wsUrl;
    }).then(function () {
      return _this3.spark.internal.feature.getFeature('developer', 'web-shared-mercury');
    }).then(function (webSharedMercury) {
      webSocketUrl = _url2.default.parse(webSocketUrl, true);
      (0, _assign2.default)(webSocketUrl.query, {
        outboundWireFormat: 'text',
        bufferStates: true,
        aliasHttpStatus: true
      });

      if (webSharedMercury) {
        (0, _assign2.default)(webSocketUrl.query, {
          mercuryRegistrationStatus: true,
          isRegistrationRefreshEnabled: true
        });
        (0, _deleteProperty2.default)(webSocketUrl.query, 'bufferStates');
      }

      if ((0, _get3.default)(_this3, 'spark.config.device.ephemeral', false)) {
        webSocketUrl.query.multipleConnections = true;
      }

      return _url2.default.format(webSocketUrl);
    });
  },
  _attemptConnection: function _attemptConnection(socketUrl, callback) {
    var _this4 = this;

    var socket = new _socket2.default();
    var attemptWSUrl = void 0;
    socket.on('close', function () {
      return _this4._onclose.apply(_this4, arguments);
    });
    socket.on('message', function () {
      return _this4._onmessage.apply(_this4, arguments);
    });
    socket.on('sequence-mismatch', function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _this4._emit.apply(_this4, ['sequence-mismatch'].concat(args));
    });

    _promise2.default.all([this._prepareUrl(socketUrl), this.spark.credentials.getUserToken()]).then(function (_ref) {
      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
          webSocketUrl = _ref2[0],
          token = _ref2[1];

      attemptWSUrl = webSocketUrl;
      return socket.open(webSocketUrl, {
        forceCloseDelay: _this4.config.forceCloseDelay,
        pingInterval: _this4.config.pingInterval,
        pongTimeout: _this4.config.pongTimeout,
        token: token.toString(),
        trackingId: _this4.spark.sessionId + '_' + Date.now(),
        logger: _this4.logger
      });
    }).then(function () {
      _this4.socket = socket;
      _this4.spark.internal.metrics.submitClientMetrics('web-ha-mercury', {
        fields: {
          success: true
        },
        tags: {
          action: 'connected',
          url: attemptWSUrl
        }
      });
      callback();
      return _this4.spark.internal.device.fetchNewUrls(attemptWSUrl);
    }).catch(function (reason) {
      // Suppress connection errors that appear to be network related. This
      // may end up suppressing metrics during outages, but we might not care
      // (especially since many of our outages happen in a way that client
      // metrics can't be trusted).
      if (reason.code !== 1006 && _this4.backoffCall && _this4.backoffCall.getNumRetries() > 0) {
        _this4._emit('connection_failed', reason, { retries: _this4.backoffCall.getNumRetries() });
      }
      _this4.logger.info('mercury: connection attempt failed', reason);
      // UnknownResponse is produced by IE for any 4XXX; treated it like a bad
      // web socket url and let WDM handle the token checking
      if (reason instanceof _errors.UnknownResponse) {
        _this4.logger.info('mercury: received unknown response code, refreshing device registration');
        return _this4.spark.internal.device.refresh().then(function () {
          return callback(reason);
        });
      }
      // NotAuthorized implies expired token
      if (reason instanceof _errors.NotAuthorized) {
        _this4.logger.info('mercury: received authorization error, reauthorizing');
        return _this4.spark.credentials.refresh({ force: true }).then(function () {
          return callback(reason);
        });
      }
      // // NotFound implies expired web socket url
      // else if (reason instanceof NotFound) {
      //   this.logger.info(`mercury: received not found error, refreshing device registration`);
      //   return this.spark.internal.device.refresh()
      //     .then(() => callback(reason));
      // }
      // BadRequest implies current credentials are for a Service Account
      // Forbidden implies current user is not entitle for Spark
      if (reason instanceof _errors.BadRequest || reason instanceof _errors.Forbidden) {
        _this4.logger.warn('mercury: received unrecoverable response from mercury');
        _this4.backoffCall.abort();
        return callback(reason);
      }
      if (reason instanceof _errors.ConnectionError) {
        return _this4.spark.internal.feature.getFeature('developer', 'web-ha-messaging').then(function (haMessagingEnabled) {
          if (haMessagingEnabled) {
            _this4.logger.info('mercury: received a generic connection error, will try to connect to another datacenter');
            _this4.spark.internal.metrics.submitClientMetrics('web-ha-mercury', {
              fields: {
                success: false
              },
              tags: {
                action: 'failed',
                error: reason.message,
                url: attemptWSUrl
              }
            });
            return _this4.spark.internal.device.markUrlFailedAndGetNew(attemptWSUrl);
          }
          return null;
        }).then(function () {
          return callback(reason);
        });
      }

      return callback(reason);
    }).catch(function (reason) {
      _this4.logger.error('mercury: failed to handle connection failure', reason);
      callback(reason);
    });
  },
  _connectWithBackoff: function _connectWithBackoff(webSocketUrl) {
    var _this5 = this;

    return new _promise2.default(function (resolve, reject) {
      // eslint gets confused about whether or not call is actually used
      // eslint-disable-next-line prefer-const
      var call = void 0;
      var onComplete = function onComplete(err) {
        _this5.connecting = false;

        _this5.backoffCall = undefined;
        if (err) {
          _this5.logger.info('mercury: failed to connect after ' + call.getNumRetries() + ' retries; log statement about next retry was inaccurate');
          return reject(err);
        }
        _this5.connected = true;
        _this5._emit('online');
        return resolve();
      };

      // eslint-disable-next-line prefer-reflect
      call = _backoff2.default.call(function (callback) {
        _this5.logger.info('mercury: executing connection attempt ' + call.getNumRetries());
        _this5._attemptConnection(webSocketUrl, callback);
      }, onComplete);

      call.setStrategy(new _backoff2.default.ExponentialStrategy({
        initialDelay: _this5.config.backoffTimeReset,
        maxDelay: _this5.config.backoffTimeMax
      }));

      if (_this5.config.maxRetries) {
        call.failAfter(_this5.config.maxRetries);
      }

      call.on('abort', function () {
        _this5.logger.info('mercury: connection aborted');
        reject();
      });

      call.on('callback', function (err) {
        if (err) {
          var number = call.getNumRetries();
          var delay = Math.min(call.strategy_.nextBackoffDelay_, _this5.config.backoffTimeMax);

          _this5.logger.info('mercury: failed to connect; attempting retry ' + (number + 1) + ' in ' + delay + ' ms');
          /* istanbul ignore if */
          if (process.env.NODE_ENV === 'development') {
            _this5.logger.debug('mercury: ', err, err.stack);
          }
          return;
        }
        _this5.logger.info('mercury: connected');
      });

      call.start();

      _this5.backoffCall = call;
    });
  },
  _emit: function _emit() {
    try {
      this.trigger.apply(this, arguments);
    } catch (error) {
      this.logger.error('mercury: error occurred in event handler', error);
    }
  },
  _getEventHandlers: function _getEventHandlers(eventType) {
    var _eventType$split = eventType.split('.'),
        _eventType$split2 = (0, _slicedToArray3.default)(_eventType$split, 2),
        namespace = _eventType$split2[0],
        name = _eventType$split2[1];

    var handlers = [];

    if (!this.spark[namespace] && !this.spark.internal[namespace]) {
      return handlers;
    }

    var handlerName = (0, _string2.default)('process_' + name + '_event').camelize().s;
    if ((this.spark[namespace] || this.spark.internal[namespace])[handlerName]) {
      handlers.push({
        name: handlerName,
        namespace: namespace
      });
    }
    return handlers;
  },
  _onclose: function _onclose(event) {
    // I don't see any way to avoid the complexity or statement count in here.
    /* eslint complexity: [0] */

    try {
      var reason = event.reason && event.reason.toLowerCase();
      var socketUrl = this.socket.url;
      this.socket.removeAllListeners();
      this.unset('socket');
      this.connected = false;
      this._emit('offline', event);

      switch (event.code) {
        case 1003:
          // metric: disconnect
          this.logger.info('mercury: Mercury service rejected last message; will not reconnect: ' + event.reason);
          this._emit('offline.permanent', event);
          break;
        case 4000:
          // metric: disconnect
          this.logger.info('mercury: socket replaced; will not reconnect');
          this._emit('offline.replaced', event);
          break;
        case 1001:
        case 1005:
        case 1006:
        case 1011:
          this.logger.info('mercury: socket disconnected; reconnecting');
          this._emit('offline.transient', event);
          this._reconnect(socketUrl);
          // metric: disconnect
          // if (code == 1011 && rason !== ping error) metric: unexpected disconnect
          break;
        case 1000:
          if (normalReconnectReasons.includes(reason)) {
            this.logger.info('mercury: socket disconnected; reconnecting');
            this._emit('offline.transient', event);
            this._reconnect(socketUrl);
            // metric: disconnect
            // if (reason === done forced) metric: force closure
          } else {
            this.logger.info('mercury: socket disconnected; will not reconnect');
            this._emit('offline.permanent', event);
          }
          break;
        default:
          this.logger.info('mercury: socket disconnected unexpectedly; will not reconnect');
          // unexpected disconnect
          this._emit('offline.permanent', event);
      }
    } catch (error) {
      this.logger.error('mercury: error occurred in close handler', error);
    }
  },
  _onmessage: function _onmessage(event) {
    var _this6 = this;

    var envelope = event.data;
    if (process.env.ENABLE_MERCURY_LOGGING) {
      this.logger.debug('mercury: message envelope: ', envelope);
    }

    var data = envelope.data;
    this._applyOverrides(data);
    return this._getEventHandlers(data.eventType).reduce(function (promise, handler) {
      return promise.then(function () {
        var namespace = handler.namespace,
            name = handler.name;

        return new _promise2.default(function (resolve) {
          return resolve((_this6.spark[namespace] || _this6.spark.internal[namespace])[name](data));
        }).catch(function (reason) {
          return _this6.logger.error('mercury: error occurred in autowired event handler for ' + data.eventType, reason);
        });
      });
    }, _promise2.default.resolve()).then(function () {
      _this6._emit('event', event.data);

      var _data$eventType$split = data.eventType.split('.'),
          _data$eventType$split2 = (0, _slicedToArray3.default)(_data$eventType$split, 1),
          namespace = _data$eventType$split2[0];

      _this6._emit('event:' + namespace, envelope);
      _this6._emit('event:' + data.eventType, envelope);
    }).catch(function (reason) {
      _this6.logger.error('mercury: error occurred processing socket message', reason);
    });
  },
  _reconnect: function _reconnect(webSocketUrl) {
    this.logger.info('mercury: reconnecting');
    return this.connect(webSocketUrl);
  },
  version: '1.32.5'
}, (_applyDecoratedDescriptor(_obj, 'connect', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'connect'), _obj), _applyDecoratedDescriptor(_obj, 'disconnect', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'disconnect'), _obj), _applyDecoratedDescriptor(_obj, 'listen', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'listen'), _obj), _applyDecoratedDescriptor(_obj, 'stopListening', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'stopListening'), _obj)), _obj)));

exports.default = Mercury;


}).call(this,require('_process'))
},{"./errors":757,"./socket":760,"@ciscospark/common":731,"@ciscospark/spark-core":804,"_process":1743,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/slicedToArray":709,"backoff":712,"lodash/get":1636,"lodash/set":1694,"string":1727,"url":1765}],760:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _socket = require('./socket');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_socket).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


},{"./socket":762}],761:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _defineProperty = require('babel-runtime/core-js/reflect/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _events = require('events');

var _errors = require('../errors');

var _common = require('@ciscospark/common');

var _commonTimers = require('@ciscospark/common-timers');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sockets = new _weakMap2.default();

/**
 * Generalized socket abstraction
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var Socket = function (_EventEmitter) {
  (0, _inherits3.default)(Socket, _EventEmitter);

  /**
   * constructor
   * @returns {Socket}
   */
  function Socket() {
    (0, _classCallCheck3.default)(this, Socket);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Socket.__proto__ || (0, _getPrototypeOf2.default)(Socket)).call(this));

    _this.onmessage = _this.onmessage.bind(_this);
    _this.onclose = _this.onclose.bind(_this);
    return _this;
  }

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
   * @returns {string}
   */


  (0, _createClass3.default)(Socket, [{
    key: 'close',


    /**
     * Closes the socket
     * @param {Object} options
     * @param {string} options.reason
     * @param {number} options.code
     * @returns {Promise}
     */
    value: function close(options) {
      var _this2 = this;

      return new _promise2.default(function (resolve, reject) {
        _this2.logger.info('socket: closing');
        var socket = sockets.get(_this2);
        if (socket.readyState === 2 || socket.readyState === 3) {
          _this2.logger.info('socket: already closed');
          resolve();
          return;
        }

        options = options || {};
        if (options.code && options.code !== 1000 && (options.code < 3000 || options.code > 4999)) {
          reject(new Error('`options.code` must be 1000 or between 3000 and 4999 (inclusive)'));
          return;
        }

        options = (0, _defaults3.default)(options, {
          code: 1000,
          reason: 'Done'
        });

        var closeTimer = (0, _commonTimers.safeSetTimeout)(function () {
          try {
            _this2.logger.info('socket: no close event received, forcing closure');
            resolve(_this2.onclose({
              code: 1000,
              reason: 'Done (forced)'
            }));
          } catch (error) {
            _this2.logger.warn('socket: force-close failed', error);
          }
        }, _this2.forceCloseDelay);

        socket.onclose = function (event) {
          _this2.logger.info('socket: close event fired', event.code, event.reason);
          clearTimeout(closeTimer);
          _this2.onclose(event);
          resolve(event);
        };

        socket.close(options.code, options.reason);
      });
    }

    /**
     * Opens a WebSocket
     * @param {string} url
     * @param {options} options
     * @param {number} options.forceCloseDelay (required)
     * @param {number} options.pingInterval (required)
     * @param {number} options.pongTimeout (required)
     * @param {string} options.token (required)
     * @param {string} options.trackingId (required)
     * @param {Logger} options.logger (required)
     * @param {string} options.logLevelToken
     * @returns {Promise}
     */

  }, {
    key: 'open',
    value: function open(url, options) {
      var _this3 = this;

      return new _promise2.default(function (resolve, reject) {
        /* eslint complexity: [0] */
        if (!url) {
          reject(new Error('`url` is required'));
          return;
        }

        if (sockets.get(_this3)) {
          reject(new Error('Socket#open() can only be called once per instance'));
          return;
        }

        options = options || {};

        (0, _common.checkRequired)(['forceCloseDelay', 'pingInterval', 'pongTimeout', 'token', 'trackingId', 'logger'], options);

        (0, _keys2.default)(options).forEach(function (key) {
          (0, _defineProperty2.default)(_this3, key, {
            enumerable: false,
            value: options[key]
          });
        });

        var WebSocket = Socket.getWebSocketConstructor();

        _this3.logger.info('socket: creating WebSocket');
        var socket = new WebSocket(url);
        socket.binaryType = 'arraybuffer';
        socket.onmessage = _this3.onmessage;

        socket.onclose = function (event) {
          event = _this3._fixCloseCode(event);
          switch (event.code) {
            case 1005:
              // IE 11 doesn't seem to allow 4XXX codes, so if we get a 1005, assume
              // it's a bad websocket url. That'll trigger a device refresh; if it
              // turns out we had a bad token, the device refresh should 401 and
              // trigger a token refresh.
              return reject(new _errors.UnknownResponse(event));
            case 4400:
              return reject(new _errors.BadRequest(event));
            case 4401:
              return reject(new _errors.NotAuthorized(event));
            case 4403:
              return reject(new _errors.Forbidden(event));
            // case 4404:
            //   return reject(new NotFound(event));
            default:
              return reject(new _errors.ConnectionError(event));
          }
        };

        socket.onopen = function () {
          _this3.logger.info('socket: connected');
          _this3._authorize().then(function () {
            _this3.logger.info('socket: authorized');
            socket.onclose = _this3.onclose;
            resolve();
          }).catch(reject);
        };

        socket.onerror = function (event) {
          _this3.logger.warn('socket: error event fired', event);
        };

        sockets.set(_this3, socket);
        _this3.logger.info('socket: waiting for server');
      });
    }

    /**
     * Handles incoming CloseEvents
     * @param {CloseEvent} event
     * @returns {undefined}
     */

  }, {
    key: 'onclose',
    value: function onclose(event) {
      this.logger.info('socket: closed', event.code, event.reason);
      clearTimeout(this.pongTimer);
      clearTimeout(this.pingTimer);

      event = this._fixCloseCode(event);
      this.emit('close', event);

      // Remove all listeners to (a) avoid reacting to late pongs and (b) ensure
      // we don't have a retain cycle.
      this.removeAllListeners();
    }

    /**
     * Handles incoming message events
     * @param {MessageEvent} event
     * @returns {undefined}
     */

  }, {
    key: 'onmessage',
    value: function onmessage(event) {
      try {
        var data = JSON.parse(event.data);
        var sequenceNumber = parseInt(data.sequenceNumber, 10);
        this.logger.debug('socket: sequence number: ', sequenceNumber);
        if (this.expectedSequenceNumber && sequenceNumber !== this.expectedSequenceNumber) {
          this.logger.debug('socket: sequence number mismatch indicates lost mercury message. expected: ' + this.expectedSequenceNumber + ', actual: ' + sequenceNumber);
          this.emit('sequence-mismatch', sequenceNumber, this.expectedSequenceNumber);
        }
        this.expectedSequenceNumber = sequenceNumber + 1;

        // Yes, it's a little weird looking; we want to emit message events that
        // look like normal socket message events, but event.data cannot be
        // modified and we don't actually care about anything but the data property
        var processedEvent = { data: data };
        this._acknowledge(processedEvent);
        if (data.type === 'pong') {
          this.emit('pong', processedEvent);
        } else {
          this.emit('message', processedEvent);
        }
      } catch (error) {
        // The above code should only be able to throw if we receive an unparsable
        // message from Mercury. At this time, the only action we have is to
        // ignore it and move on.
        /* istanbul ignore next */
        this.logger.warn('socket: error while receiving WebSocket message', error);
      }
    }

    /**
     * Sends a message up the socket
     * @param {mixed} data
     * @returns {Promise}
     */

  }, {
    key: 'send',
    value: function send(data) {
      var _this4 = this;

      return new _promise2.default(function (resolve, reject) {
        if (_this4.readyState !== 1) {
          return reject(new Error('INVALID_STATE_ERROR'));
        }

        if ((0, _isObject3.default)(data)) {
          data = (0, _stringify2.default)(data);
        }

        var socket = sockets.get(_this4);
        socket.send(data);
        return resolve();
      });
    }

    /**
     * Sends an acknowledgment for a specific event
     * @param {MessageEvent} event
     * @returns {Promise}
     */

  }, {
    key: '_acknowledge',
    value: function _acknowledge(event) {
      if (!event) {
        return _promise2.default.reject(new Error('`event` is required'));
      }

      if (!(0, _has3.default)(event, 'data.id')) {
        return _promise2.default.reject(new Error('`event.data.id` is required'));
      }

      return this.send({
        messageId: event.data.id,
        type: 'ack'
      });
    }

    /**
     * Sends an auth message up the socket
     * @private
     * @returns {Promise}
     */

  }, {
    key: '_authorize',
    value: function _authorize() {
      var _this5 = this;

      return new _promise2.default(function (resolve) {
        _this5.logger.info('socket: authorizing');
        _this5.send({
          id: _uuid2.default.v4(),
          type: 'authorization',
          data: {
            token: _this5.token
          },
          trackingId: _this5.trackingId,
          logLevelToken: _this5.logLevelToken
        });

        var waitForBufferState = function waitForBufferState(event) {
          if (!event.data.type && (event.data.data.eventType === 'mercury.buffer_state' || event.data.data.eventType === 'mercury.registration_status')) {
            _this5.removeListener('message', waitForBufferState);
            _this5._ping();
            resolve();
          }
        };
        _this5.once('message', waitForBufferState);
      });
    }

    /**
     * Deals with the fact that some browsers drop some close codes (but not
     * close reasons).
     * @param {CloseEvent} event
     * @private
     * @returns {CloseEvent}
     */

  }, {
    key: '_fixCloseCode',
    value: function _fixCloseCode(event) {
      if (event.code === 1005 && event.reason) {
        switch (event.reason.toLowerCase()) {
          case 'replaced':
            this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);
            event.code = 4000;
            break;
          case 'authentication failed':
          case 'authentication did not happen within the timeout window of 30000 seconds.':
            this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);
            event.code = 1008;
            break;
          default:
          // do nothing
        }
      }

      return event;
    }

    /**
     * Sends a ping up the socket and confirms we get it back
     * @param {[type]} id
     * @private
     * @returns {[type]}
     */

  }, {
    key: '_ping',
    value: function _ping(id) {
      var _this6 = this;

      var confirmPongId = function confirmPongId(event) {
        try {
          _this6.logger.debug('socket: pong', event.data.id);
          if (event.data && event.data.id !== id) {
            _this6.logger.info('socket: received pong for wrong ping id, closing socket');
            _this6.logger.debug('socket: expected', id, 'received', event.data.id);
            _this6.close({
              code: 1000,
              reason: 'Pong mismatch'
            });
          }
        } catch (error) {
          // This try/catch block was added as a debugging step; to the best of my
          // knowledge, the above can never throw.
          /* istanbul ignore next */
          _this6.logger.error('socket: error occurred in confirmPongId', error);
        }
      };

      var onPongNotReceived = function onPongNotReceived() {
        try {
          _this6.logger.info('socket: pong not receive in expected period, closing socket');
          _this6.close({
            code: 1000,
            reason: 'Pong not received'
          }).catch(function (reason) {
            _this6.logger.warn('socket: failed to close socket after missed pong', reason);
          });
        } catch (error) {
          // This try/catch block was added as a debugging step; to the best of my
          // knowledge, the above can never throw.
          /* istanbul ignore next */
          _this6.logger.error('socket: error occurred in onPongNotReceived', error);
        }
      };

      var scheduleNextPingAndCancelPongTimer = function scheduleNextPingAndCancelPongTimer() {
        try {
          clearTimeout(_this6.pongTimer);
          _this6.pingTimer = (0, _commonTimers.safeSetTimeout)(function () {
            return _this6._ping();
          }, _this6.pingInterval);
        } catch (error) {
          // This try/catch block was added as a debugging step; to the best of my
          // knowledge, the above can never throw.
          /* istanbul ignore next */
          _this6.logger.error('socket: error occurred in scheduleNextPingAndCancelPongTimer', error);
        }
      };

      id = id || _uuid2.default.v4();
      this.pongTimer = (0, _commonTimers.safeSetTimeout)(onPongNotReceived, this.pongTimeout);
      this.once('pong', scheduleNextPingAndCancelPongTimer);
      this.once('pong', confirmPongId);

      this.logger.debug('socket: ping ' + id);
      return this.send({
        id: id,
        type: 'ping'
      });
    }
  }, {
    key: 'binaryType',
    get: function get() {
      return sockets.get(this).binaryType;
    }

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
     * @returns {number}
     */

  }, {
    key: 'bufferedAmount',
    get: function get() {
      return sockets.get(this).bufferedAmount;
    }

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
     * @returns {string}
     */

  }, {
    key: 'extensions',
    get: function get() {
      return sockets.get(this).extensions;
    }

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
     * @returns {string}
     */

  }, {
    key: 'protocol',
    get: function get() {
      return sockets.get(this).protocol;
    }

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
     * @returns {number}
     */

  }, {
    key: 'readyState',
    get: function get() {
      return sockets.get(this).readyState;
    }

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
     * @returns {string}
     */

  }, {
    key: 'url',
    get: function get() {
      return sockets.get(this).url;
    }

    /**
     * Provides the environmentally appropriate constructor (ws in NodeJS,
     * WebSocket in browsers)
     * @returns {WebSocket}
     */

  }], [{
    key: 'getWebSocketConstructor',
    value: function getWebSocketConstructor() {
      throw new Error('Socket.getWebSocketConstructor() must be implemented in an environmentally appropriate way');
    }
  }]);
  return Socket;
}(_events.EventEmitter);

exports.default = Socket;


},{"../errors":757,"@ciscospark/common":731,"@ciscospark/common-timers":41,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"events":1737,"lodash/defaults":1618,"lodash/has":1638,"lodash/isObject":1659,"uuid":868}],762:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _socketBase = require('./socket-base');

var _socketBase2 = _interopRequireDefault(_socketBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_socketBase2.default.getWebSocketConstructor = function getWebSocketConstructor() {
  return WebSocket;
}; /*!
    * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
    */

/* eslint-env browser */

exports.default = _socketBase2.default;


},{"./socket-base":761}],763:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _sparkCore = require('@ciscospark/spark-core');

var _commonTimers = require('@ciscospark/common-timers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var sym = (0, _symbol2.default)('metric id');

var MetricsBatcher = _sparkCore.Batcher.extend({
  namespace: 'Metrics',

  prepareItem: function prepareItem(item) {
    // Keep non-prod data out of metrics
    var env = process.env.NODE_ENV === 'production' ? null : 'TEST';

    item.appType = item.appType || this.config.appType;
    item.env = item.env || env;
    item.time = item.time || Date.now();
    item.version = item.version || this.spark.version;

    return _promise2.default.resolve(item);
  },
  prepareRequest: function prepareRequest(queue) {
    return _promise2.default.resolve(queue.map(function (item) {
      item.postTime = item.postTime || Date.now();
      return item;
    }));
  },
  submitHttpRequest: function submitHttpRequest(payload) {
    return this.spark.request({
      method: 'POST',
      service: 'metrics',
      resource: 'metrics',
      body: {
        metrics: payload
      }
    });
  },
  handleHttpSuccess: function handleHttpSuccess(res) {
    var _this = this;

    return _promise2.default.all(res.options.body.metrics.map(function (item) {
      return _this.acceptItem(item);
    }));
  },
  handleHttpError: function handleHttpError(reason) {
    var _this2 = this;

    if (reason instanceof _sparkCore.SparkHttpError.NetworkOrCORSError) {
      this.logger.warn('metrics-batcher: received network error submitting metrics, reenqueuing payload');
      return _promise2.default.all(reason.options.body.metrics.map(function (item) {
        return new _promise2.default(function (resolve) {
          var delay = item[sym].nextDelay;
          if (delay < _this2.config.batcherRetryPlateau) {
            item[sym].nextDelay *= 2;
          }
          (0, _commonTimers.safeSetTimeout)(function () {
            resolve(_this2.rerequest(item));
          }, delay);
        });
      }));
    }

    return (0, _apply2.default)(_sparkCore.Batcher.prototype.handleHttpError, this, [reason]);
  },
  rerequest: function rerequest(item) {
    var _this3 = this;

    return _promise2.default.all([this.getDeferredForRequest(item), this.prepareItem(item)]).then(function (_ref) {
      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
          defer = _ref2[0],
          req = _ref2[1];

      _this3.enqueue(req).then(function () {
        return _this3.bounce();
      }).catch(function (reason) {
        return defer.reject(reason);
      });
    });
  },
  fingerprintRequest: function fingerprintRequest(item) {
    item[sym] = item[sym] || {
      nextDelay: 1000
    };

    return _promise2.default.resolve(item[sym]);
  },
  fingerprintResponse: function fingerprintResponse(item) {
    return _promise2.default.resolve(item[sym]);
  }
});

exports.default = MetricsBatcher;


}).call(this,require('_process'))
},{"@ciscospark/common-timers":41,"@ciscospark/spark-core":804,"_process":1743,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/symbol":701,"babel-runtime/helpers/slicedToArray":709}],764:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _batcher = require('./batcher');

var _batcher2 = _interopRequireDefault(_batcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CallDiagnosticEventsBatcher = _batcher2.default.extend({
  namespace: 'Metrics',

  prepareItem: function prepareItem(item) {
    // networkType should be a enum value: `wifi`, `ethernet`, `cellular`, or `unknown`.
    // Browsers cannot provide such information right now. However, it is a required field.
    var origin = {
      buildType: process.env.NODE_ENV === 'production' ? 'prod' : 'test',
      networkType: 'unknown'
    };
    item.eventPayload.origin = (0, _assign2.default)(origin, item.eventPayload.origin);
    return _promise2.default.resolve(item);
  },
  prepareRequest: function prepareRequest(queue) {
    // Add sent timestamp
    queue.forEach(function (item) {
      item.eventPayload.originTime.sent = new Date().toISOString();
    });
    return _promise2.default.resolve(queue);
  },
  submitHttpRequest: function submitHttpRequest(payload) {
    return this.spark.request({
      method: 'POST',
      service: 'metrics',
      resource: 'clientmetrics',
      body: {
        metrics: payload
      }
    });
  }
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = CallDiagnosticEventsBatcher;


}).call(this,require('_process'))
},{"./batcher":763,"_process":1743,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/promise":694}],765:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _batcher = require('./batcher');

var _batcher2 = _interopRequireDefault(_batcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ClientMetricsBatcher = _batcher2.default.extend({
  namespace: 'Metrics',

  prepareItem: function prepareItem(item) {
    // Add more defaults to payload when the clientmetrics endpoint evolves to support richer payloads
    return _promise2.default.resolve(item);
  },
  prepareRequest: function prepareRequest(queue) {
    return _promise2.default.resolve(queue);
  },
  submitHttpRequest: function submitHttpRequest(payload) {
    return this.spark.request({
      method: 'POST',
      service: 'metrics',
      resource: 'clientmetrics',
      body: {
        metrics: payload
      }
    });
  }
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = ClientMetricsBatcher;


},{"./batcher":763,"babel-runtime/core-js/promise":694}],766:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = require('@ciscospark/common');

exports.default = {
  device: {
    preDiscoveryServices: {
      metricsServiceUrl: process.env.METRICS_SERVICE_URL || 'https://metrics-a.wbx2.com/metrics/api/v1'
    }
  },
  metrics: {
    appType: _common.inBrowser ? 'browser' : 'nodejs',
    batcherWait: 500,
    batcherMaxCalls: 50,
    batcherMaxWait: 1500,
    batcherRetryPlateau: 32000
  }
}; /*!
    * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
    */


}).call(this,require('_process'))
},{"@ciscospark/common":731,"_process":1743}],767:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.config = exports.default = undefined;

var _metrics = require('./metrics');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_metrics).default;
  }
});

require('@ciscospark/internal-plugin-wdm');

var _sparkCore = require('@ciscospark/spark-core');

var _metrics2 = _interopRequireDefault(_metrics);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

(0, _sparkCore.registerInternalPlugin)('metrics', _metrics2.default, {
  config: _config2.default
});

exports.config = _config2.default;


},{"./config":766,"./metrics":768,"@ciscospark/internal-plugin-wdm":777,"@ciscospark/spark-core":804}],768:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _dec, _desc, _value, _obj; /*!
                                * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                */

var _sparkCore = require('@ciscospark/spark-core');

var _batcher = require('./batcher');

var _batcher2 = _interopRequireDefault(_batcher);

var _clientMetricsBatcher = require('./client-metrics-batcher');

var _clientMetricsBatcher2 = _interopRequireDefault(_clientMetricsBatcher);

var _callDiagnosticEventsBatcher = require('./call-diagnostic-events-batcher');

var _callDiagnosticEventsBatcher2 = _interopRequireDefault(_callDiagnosticEventsBatcher);

var _common = require('@ciscospark/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var Metrics = _sparkCore.SparkPlugin.extend((_dec = (0, _common.deprecated)('Metrics#sendUnstructured() is deprecated; please use Metrics#submit()'), (_obj = {
  children: {
    batcher: _batcher2.default,
    clientMetricsBatcher: _clientMetricsBatcher2.default,
    callDiagnosticEventsBatcher: _callDiagnosticEventsBatcher2.default
  },

  namespace: 'Metrics',

  sendUnstructured: function sendUnstructured(key, value) {
    return this.submit(key, value);
  },
  submit: function submit(key, value) {
    return this.batcher.request((0, _assign2.default)({ key: key }, value));
  },


  /**
   * This corresponds to #sendSemiStructured() in the deprecated metrics handler
   * @param {string} eventName
   * @param {Object} props
   * @param {string} preLoginId
   * @returns {Object} HttpResponse object
   */
  submitClientMetrics: function submitClientMetrics(eventName, props, preLoginId) {
    var payload = { metricName: eventName };
    if (props.tags) {
      payload.tags = props.tags;
    }
    if (props.fields) {
      payload.fields = props.fields;
    }
    if (props.type) {
      payload.type = props.type;
    }
    payload.timestamp = Date.now();
    if (preLoginId) {
      var _payload = {
        metrics: [payload]
      };
      // Do not batch these because pre-login events occur during onboarding, so we will be partially blind
      // to users' progress through the reg flow if we wait to persist pre-login metrics for people who drop off because
      // their metrics will not post from a queue flush in time
      return this.postPreLoginMetric(_payload, preLoginId);
    }
    return this.clientMetricsBatcher.request(payload);
  },


  /**
   * Issue request to alias a user's pre-login ID with their CI UUID
   * @param {string} preLoginId
   * @returns {Object} HttpResponse object
   */
  aliasUser: function aliasUser(preLoginId) {
    return this.request({
      method: 'POST',
      api: 'metrics',
      resource: 'clientmetrics',
      headers: {
        'x-prelogin-userid': preLoginId
      },
      body: {},
      qs: {
        alias: true
      }
    });
  },
  postPreLoginMetric: function postPreLoginMetric(payload, preLoginId) {
    var _this = this;

    return this.spark.credentials.getClientToken().then(function (token) {
      return _this.request({
        method: 'POST',
        api: 'metrics',
        resource: 'clientmetrics-prelogin',
        headers: {
          authorization: token.toString(),
          'x-prelogin-userid': preLoginId
        },
        body: payload
      });
    });
  },
  submitCallDiagnosticEvents: function submitCallDiagnosticEvents(payload) {
    var event = {
      type: 'diagnostic-event',
      eventPayload: payload
    };
    return this.callDiagnosticEventsBatcher.request(event);
  },
  version: '1.32.5'
}, (_applyDecoratedDescriptor(_obj, 'sendUnstructured', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'sendUnstructured'), _obj)), _obj)));

exports.default = Metrics;


},{"./batcher":763,"./call-diagnostic-events-batcher":764,"./client-metrics-batcher":765,"@ciscospark/common":731,"@ciscospark/spark-core":804,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689}],769:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = require('@ciscospark/common');

exports.default = {
  device: {
    preDiscoveryServices: {
      wdmServiceUrl: process.env.WDM_SERVICE_URL || 'https://wdm-a.wbx2.com/wdm/api/v1',
      hydraServiceUrl: process.env.HYDRA_SERVICE_URL || 'https://api.ciscospark.com/v1'
    },
    defaults: {
      name: process.title || _common.inBrowser && 'browser' || 'javascript',
      deviceType: 'UNKNOWN'
    },
    enableInactivityEnforcement: false,
    /**
     * When true, device registrations will include a ttl value of
     * {@link config.device.ephemeralDeviceTTL} and refresh on an interval of
     * {@link config.device.ephemeralDeviceTTL}/2+60 seconds
     * @type {boolean}
     */
    ephemeral: false,

    /**
     * TTL value to include in device registration if
     * {@link config.device.ephemeral} is true. Measured in seconds.
     * @type {boolean}
     */
    ephemeralDeviceTTL: 30 * 60
  }
}; /*!
    * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
    */


}).call(this,require('_process'))
},{"@ciscospark/common":731,"_process":1743}],770:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _desc, _value, _obj; /*!
                                                                                        * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                                                                        */

var _common = require('@ciscospark/common');

var _commonTimers = require('@ciscospark/common-timers');

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _featuresModel = require('./features-model');

var _featuresModel2 = _interopRequireDefault(_featuresModel);

var _serviceCollection = require('./service-collection');

var _serviceCollection2 = _interopRequireDefault(_serviceCollection);

var _sparkCore = require('@ciscospark/spark-core');

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * Decides if this device should be persisted to boundedStorage, based on
 * this.config.ephemeral.
 * @returns {Boolean}
 */
function decider() {
  return !this.config.ephemeral;
}

var Device = _sparkCore.SparkPlugin.extend((_dec = (0, _sparkCore.waitForValue)('@'), _dec2 = (0, _sparkCore.waitForValue)('@'), _dec3 = (0, _sparkCore.persist)('@', decider), _dec4 = (0, _sparkCore.waitForValue)('@'), _dec5 = (0, _sparkCore.waitForValue)('@'), _dec6 = (0, _sparkCore.waitForValue)('@'), _dec7 = (0, _sparkCore.waitForValue)('@'), _dec8 = (0, _sparkCore.waitForValue)('@'), _dec9 = (0, _sparkCore.waitForValue)('@'), (_obj = {
  children: {
    features: _featuresModel2.default
  },

  collections: {
    serviceCatalog: _serviceCollection2.default
  },

  idAttribute: 'url',

  namespace: 'Device',

  props: {
    // deviceType doesn't have any real value, but we need to send it during
    // device refresh to make sure we don't get back an ios device url
    deviceType: 'string',
    intranetInactivityDuration: 'number',
    intranetInactivityCheckUrl: 'string',
    modificationTime: 'string',
    searchEncryptionKeyUrl: 'string',
    services: {
      // Even though @jodykstr will tell you the docs claim you don't need to
      // initialize `object` properties, the docs lie.
      default: function _default() {
        return {};
      },

      type: 'object'
    },
    serviceHostMap: {
      default: function _default() {
        return {
          serviceLinks: {},
          hostCatalog: {}
        };
      },

      type: 'object'
    },
    url: 'string',
    userId: 'string',
    /**
     * Notifies the client if file sharing is disabled.
     * Currently, the values for it are:
     * - BLOCK_BOTH
     * - BLOCK_UPLOAD
     * @instance
     * @memberof Device
     * @type {string}
     */
    webFileShareControl: 'string',
    webSocketUrl: 'string'
  },

  derived: {
    registered: {
      deps: ['url'],
      fn: function fn() {
        return Boolean(this.url);
      }
    }
  },

  session: {
    // Fun Fact: setTimeout returns a Timer object instead of a Number in Node 6
    // or later
    logoutTimer: 'any',
    lastUserActivityDate: 'number'
  },

  determineService: function determineService(url) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(this.services)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        var serviceUrl = this.services[key];
        if (url.startsWith(serviceUrl)) {
          // "ServiceUrl" is 10 characters
          return _promise2.default.resolve(key.substr(0, key.length - 10));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return _promise2.default.reject(new Error(url + ' does not reflect a known service'));
  },
  getServiceUrl: function getServiceUrl(service) {
    var _this = this;

    return this._getServiceUrl(this.services, service).then(function (isServiceUrl) {
      return isServiceUrl || _this.getPreDiscoveryServiceUrl(service);
    });
  },
  getPreDiscoveryServiceUrl: function getPreDiscoveryServiceUrl(service) {
    // The Promise.resolve here is temporary. A future PR will make the
    // corresponding _ method async to allow for lazy device registration
    return _promise2.default.resolve(this._getServiceUrl(this.config.preDiscoveryServices, service));
  },
  getWebSocketUrl: function getWebSocketUrl() {
    return this.useServiceCatalogUrl(this.webSocketUrl);
  },
  useServiceCatalogUrl: function useServiceCatalogUrl(uri) {
    return this.serviceCatalog.inferServiceFromUrl(uri).then(function (s) {
      return s.replaceUrlWithCurrentHost(uri);
    });
  },
  markUrlFailedAndGetNew: function markUrlFailedAndGetNew(url) {
    var _this2 = this;

    if (!url) {
      return _promise2.default.reject(new Error('`url` is a required parameter'));
    }

    this.logger.info('device: marking ' + url + ' as failed');
    return this.serviceCatalog.markFailedAndCycleUrl(url).then(function (uri) {
      _this2.spark.internal.metrics.submitClientMetrics('web-ha', {
        tags: {
          action: 'replace_url',
          failedUrl: url,
          newUrl: uri
        }
      });
      return uri;
    })
    // it's likely we fail here because we've cycled though all hosts,
    // reset all hosts and then retry connecting
    .catch(function () {
      return _this2._resetAllAndRetry(url);
    });
  },
  _resetAllAndRetry: function _resetAllAndRetry(url) {
    if (!url) {
      return _promise2.default.reject(new Error('`url` is a required parameter'));
    }

    this.logger.info('device: reset available hosts and retry ' + url);
    return this.serviceCatalog.resetAllAndRetry(url);
  },


  // this function is exposed beyond the device file
  fetchNewUrls: function fetchNewUrls(url) {
    var _this3 = this;

    // we want to get the current service first, just in case the
    // refreshed catalog has different host names
    return new _promise2.default(function (resolve) {
      return _this3.serviceCatalog.inferServiceFromUrl(url).then(function (s) {
        _this3.logger.info('device: refresh to ' + s.service + ' get new urls');
        _this3.refresh();
        _this3.on('serviceCatalogUpdated', function () {
          return resolve(s.url);
        });
      });
    });
  },
  initialize: function initialize() {
    var _this4 = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.initialize, this, args);

    // Propagate change(:[attribute]) events from collections
    ['developer', 'entitlement', 'user'].forEach(function (collectionName) {
      _this4.features.on('change:' + collectionName, function (model, value, options) {
        _this4.trigger('change', _this4, options);
        _this4.trigger('change:features', _this4, _this4.features, options);
      });
    });

    this.on('change:serviceHostMap', this._updateServiceCatalog);

    this.listenToAndRun(this, 'change:intranetInactivityCheckUrl', function () {
      return _this4._resetLogoutTimer();
    });
    this.listenToAndRun(this, 'change:intranetInactivityDuration', function () {
      return _this4._resetLogoutTimer();
    });
    this.listenTo(this.spark, 'user-activity', function () {
      _this4.lastUserActivityDate = Date.now();
    });
  },


  /**
   * Don't log the features object
   * @param {number} depth
   * @returns {Object}
   */
  inspect: function inspect(depth) {
    return _util2.default.inspect((0, _omit3.default)(this.serialize(), 'features'), { depth: depth });
  },
  isPreDiscoveryService: function isPreDiscoveryService(service) {
    // The Promise.resolve here is temporary. A future PR will make the
    // corresponding _ method async to allow for lazy device registration
    return _promise2.default.resolve(this._isService(this.config.preDiscoveryServices, service));
  },
  isPreDiscoveryServiceUrl: function isPreDiscoveryServiceUrl(uri) {
    // The Promise.resolve here is temporary. A future PR will make the
    // corresponding _ method async to allow for lazy device registration
    return _promise2.default.resolve(this._isServiceUrl(this.config.preDiscoveryServices, uri));
  },
  isService: function isService(service) {
    var _this5 = this;

    return this._isService(this.services, service).then(function (_isService) {
      return _isService || _this5.isPreDiscoveryService(service);
    });
  },
  isServiceUrl: function isServiceUrl(uri) {
    // The Promise.resolve here is temporary. A future PR will make the
    // corresponding _ method async to allow for lazy device registration
    return _promise2.default.resolve(this._isServiceUrl(this.services, uri));
  },
  isSpecificService: function isSpecificService(service, key) {
    if (key === service) {
      return _promise2.default.resolve(true);
    }

    return this.getServiceUrl(service).then(function (serviceUrl) {
      return key.includes(serviceUrl);
    });
  },
  _getServiceUrl: function _getServiceUrl(target, service) {
    /* istanbul ignore if */
    if (!target) {
      return _promise2.default.reject(new Error('`target` is a required parameter'));
    }

    if (!service) {
      return _promise2.default.reject(new Error('`service` is a required parameter'));
    }

    var feature = this.features.developer.get('web-ha-messaging');
    if (feature && feature.value) {
      var s = this.serviceCatalog.get(service + 'ServiceUrl');
      if (s) {
        return _promise2.default.resolve(s.url);
      }
    }

    return _promise2.default.resolve(target[service + 'ServiceUrl']);
  },
  _isService: function _isService(target, service) {
    return this._getServiceUrl(target, service).then(function (url) {
      return Boolean(url);
    });
  },
  _isServiceUrl: function _isServiceUrl(target, uri) {
    if (!uri) {
      return _promise2.default.reject(new Error('`uri` is a required parameter'));
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)((0, _values2.default)(target)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var value = _step2.value;

        if (value && uri.startsWith(value)) {
          return _promise2.default.resolve(true);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return _promise2.default.resolve(false);
  },
  refresh: function refresh() {
    var _this6 = this;

    this.logger.info('device: refreshing');

    if (!this.registered) {
      this.logger.info('device: device not registered, registering');
      return this.register();
    }

    var body = (0, _omit3.default)(this.serialize(), 'features', 'mediaClusters');
    if (this.config.ephemeral) {
      body.ttl = this.config.ephemeralDeviceTTL;
    }

    return this.request({
      method: 'PUT',
      uri: this.url,
      body: body
    }).then(function (res) {
      return _this6._processRegistrationSuccess(res);
    }).catch(function (reason) {
      if (reason.statusCode === 404) {
        // If we get a 404, it means the device is no longer valid and we need
        // to register a new one.
        _this6.logger.info('device: refresh failed with 404, attempting to register new device');
        _this6.clear();
        return _this6.register();
      }
      return _promise2.default.reject(reason);
    });
  },
  register: function register() {
    var _this7 = this;

    /* eslint no-invalid-this: [0] */
    this.logger.info('device: registering');

    if (this.registered) {
      this.logger.info('device: device already registered, refreshing');
      return this.refresh();
    }

    var body = this.config.defaults;
    if (this.config.ephemeral) {
      body.ttl = this.config.ephemeralDeviceTTL;
    }

    return this.request({
      method: 'POST',
      service: 'wdm',
      resource: 'devices',
      body: body
    }).then(function (res) {
      return _this7._processRegistrationSuccess(res);
    });
  },
  unregister: function unregister() {
    var _this8 = this;

    this.logger.info('device: unregistering');

    if (!this.url) {
      this.logger.warn('device: not registered');
      return _promise2.default.resolve();
    }

    return this.request({
      uri: this.url,
      method: 'DELETE'
    }).then(function () {
      return _this8.clear();
    });
  },
  clear: function clear() {
    clearTimeout(this.refreshTimer);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.clear, this, args);
  },
  _processRegistrationSuccess: function _processRegistrationSuccess(res) {
    var _this9 = this;

    this.logger.info('device: received registration payload');
    this.set(res.body);
    if (this.config.ephemeral) {
      this.logger.info('device: enqueing device refresh');
      var delay = (this.config.ephemeralDeviceTTL / 2 + 60) * 1000;
      this.refreshTimer = (0, _commonTimers.safeSetTimeout)(function () {
        return _this9.refresh();
      }, delay);
    }
  },
  _updateServiceCatalog: function _updateServiceCatalog(newRegistration) {
    var _this10 = this;

    var feature = this.features.developer.get('web-ha-messaging');
    if (feature && feature.value) {
      if (newRegistration.serviceHostMap && newRegistration.serviceHostMap.hostCatalog) {
        (0, _keys2.default)(newRegistration.services).forEach(function (service) {
          var uri = newRegistration.services[service];
          var u = _url2.default.parse(uri);
          var hosts = newRegistration.serviceHostMap.hostCatalog[u.host];
          _this10.serviceCatalog.set({
            service: service,
            defaultUrl: uri,
            availableHosts: hosts || []
          }, { remove: false });
        });
        this.trigger('serviceCatalogUpdated');
      } else {
        // if user has old device in localStorage, refresh device
        this.refresh();
      }
    }
  },
  _resetLogoutTimer: function _resetLogoutTimer() {
    var _this11 = this;

    clearTimeout(this.logoutTimer);
    this.unset('logoutTimer');
    if (this.config.enableInactivityEnforcement && this.intranetInactivityCheckUrl && this.intranetInactivityDuration) {
      this.once('change:lastUserActivityDate', function () {
        return _this11._resetLogoutTimer();
      });

      var timer = (0, _commonTimers.safeSetTimeout)(function () {
        _this11.spark.request({
          headers: {
            'cisco-no-http-redirect': null,
            'spark-user-agent': null,
            trackingid: null
          },
          method: 'GET',
          uri: _this11.intranetInactivityCheckUrl
        }).catch(function () {
          _this11.logger.info('device: did not reach internal ping endpoint; logging out after inactivity on a public network');
          return _this11.spark.logout();
        }).catch(function (reason) {
          _this11.logger.warn('device: logout failed', reason);
        });
      }, this.intranetInactivityDuration * 1000);

      this.logoutTimer = timer;
    }
  },
  version: '1.32.5'
}, (_applyDecoratedDescriptor(_obj, 'determineService', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'determineService'), _obj), _applyDecoratedDescriptor(_obj, 'getServiceUrl', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getServiceUrl'), _obj), _applyDecoratedDescriptor(_obj, 'initialize', [_dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initialize'), _obj), _applyDecoratedDescriptor(_obj, 'isService', [_dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'isService'), _obj), _applyDecoratedDescriptor(_obj, 'isServiceUrl', [_dec5], (0, _getOwnPropertyDescriptor2.default)(_obj, 'isServiceUrl'), _obj), _applyDecoratedDescriptor(_obj, 'isSpecificService', [_dec6], (0, _getOwnPropertyDescriptor2.default)(_obj, 'isSpecificService'), _obj), _applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight, _dec7], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj), _applyDecoratedDescriptor(_obj, 'register', [_common.oneFlight, _dec8], (0, _getOwnPropertyDescriptor2.default)(_obj, 'register'), _obj), _applyDecoratedDescriptor(_obj, 'unregister', [_common.oneFlight, _dec9], (0, _getOwnPropertyDescriptor2.default)(_obj, 'unregister'), _obj)), _obj)));

exports.default = Device;


},{"./features-model":773,"./service-collection":775,"@ciscospark/common":731,"@ciscospark/common-timers":41,"@ciscospark/spark-core":804,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/object/values":693,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"lodash/omit":1679,"url":1765,"util":1769}],771:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ampersandCollection = require('ampersand-collection');

var _ampersandCollection2 = _interopRequireDefault(_ampersandCollection);

var _featureModel = require('./feature-model');

var _featureModel2 = _interopRequireDefault(_featureModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var FeatureCollection = _ampersandCollection2.default.extend({
  mainIndex: 'key',
  model: _featureModel2.default
});

exports.default = FeatureCollection;


},{"./feature-model":772,"ampersand-collection":838}],772:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isNan = require('babel-runtime/core-js/number/is-nan');

var _isNan2 = _interopRequireDefault(_isNan);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _ampersandState = require('ampersand-state');

var _ampersandState2 = _interopRequireDefault(_ampersandState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FeatureModel = _ampersandState2.default.extend({
  props: {
    key: 'string',
    lastModified: 'date',
    mutable: 'boolean',
    type: 'string',
    val: 'string',
    value: 'any'
  },

  constructor: function constructor(attrs, options) {
    options = options || {};
    (0, _defaults3.default)(options, { parse: true });
    return (0, _apply2.default)(_ampersandState2.default.prototype.constructor, this, [attrs, options]);
  },


  idAttribute: 'key',

  parse: function parse(attrs) {
    if (!attrs) {
      return {};
    }

    var num = Number(attrs.val);
    if (attrs.val && !(0, _isNan2.default)(num)) {
      // Handle numbers.
      attrs.value = num;
      attrs.type = 'number';
    }
    // Handle booleans.
    else if (attrs.val === 'true') {
        attrs.value = true;
        attrs.type = 'boolean';
      } else if (attrs.val === 'false') {
        attrs.value = false;
        attrs.type = 'boolean';
      }
      // It must be a string, so return it.
      else {
          attrs.value = attrs.val;
          attrs.type = 'string';
        }

    return attrs;
  },
  serialize: function serialize() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var attrs = (0, _apply2.default)(_ampersandState2.default.prototype.serialize, this, args);
    if (attrs.lastModified) {
      attrs.lastModified = new Date(attrs.lastModified).toISOString();
    }

    return attrs;
  },


  // Override set to make sure we always run features through parse()
  // See https://github.com/AmpersandJS/ampersand-state/issues/146 for related
  // bug
  set: function set(key, value, options) {
    var attrs = void 0;
    // Handle both `"key", value` and `{key: value}` -style arguments.
    // The next block is a direct copy from ampersand-state, so no need to test
    // both scenarios.
    /* istanbul ignore next */
    if ((0, _isObject3.default)(key) || key === null) {
      attrs = key;
      options = value;
    } else {
      attrs = {};
      attrs[key] = value;
    }

    attrs = this.parse(attrs, options);
    return (0, _apply2.default)(_ampersandState2.default.prototype.set, this, [attrs, options]);
  }
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = FeatureModel;


},{"ampersand-state":675,"babel-runtime/core-js/number/is-nan":683,"babel-runtime/core-js/reflect/apply":695,"lodash/defaults":1618,"lodash/isObject":1659}],773:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _ampersandState = require('ampersand-state');

var _ampersandState2 = _interopRequireDefault(_ampersandState);

var _featureCollection = require('./feature-collection');

var _featureCollection2 = _interopRequireDefault(_featureCollection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var FeaturesModel = _ampersandState2.default.extend({
  collections: {
    developer: _featureCollection2.default,
    entitlement: _featureCollection2.default,
    user: _featureCollection2.default
  },

  /**
   * Recursively clear children/collections;
   * @param {Object} options
   * @returns {SparkPlugin}
   */
  clear: function clear(options) {
    var _this = this;

    (0, _keys2.default)(this.attributes).forEach(function (key) {
      _this.unset(key, options);
    });

    (0, _keys2.default)(this._children).forEach(function (key) {
      _this[key].clear();
    });

    (0, _keys2.default)(this._collections).forEach(function (key) {
      _this[key].reset();
    });

    return this;
  },
  initialize: function initialize() {
    var _this2 = this;

    /* eslint max-nested-callbacks: [0] */
    // Propagate change(:[attribute]) events from collections
    ['change:value', 'add', 'remove'].forEach(function (collectionEventName) {
      ['developer', 'entitlement', 'user'].forEach(function (collectionName) {
        _this2[collectionName].on(collectionEventName, function (model, options) {
          _this2.trigger('change:' + collectionName, _this2, _this2[collectionName], options);
        });
      });
    });
  }
});

exports.default = FeaturesModel;


},{"./feature-collection":771,"ampersand-state":675,"babel-runtime/core-js/object/keys":691}],774:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _device = require('./device');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_device).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


},{"./device":770}],775:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _ampersandCollection = require('ampersand-collection');

var _ampersandCollection2 = _interopRequireDefault(_ampersandCollection);

var _serviceModel = require('./service-model');

var _serviceModel2 = _interopRequireDefault(_serviceModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Collection of catalog services parsed from wdm registration.services and
 * registration.serviceHostMap.hostCatalog
 * @class
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var ServiceCollection = _ampersandCollection2.default.extend({
  mainIndex: 'service',
  model: _serviceModel2.default,

  /**
   * Mark the current host as failed and grab another url for connection
   * @param {string} uri Mark the host of this url as fail
   * @returns {string} new Url for connection
   */
  markFailedAndCycleUrl: function markFailedAndCycleUrl(uri) {
    if (!uri) {
      return _promise2.default.reject(new Error('`uri` is a required parameter'));
    }

    return this.inferServiceFromUrl(uri).then(function (service) {
      service.markHostFailed(uri);
      return service.cycleNextHost().then(function () {
        return service.url;
      });
    });
  },


  /**
   * Reset the available hosts if we are done trying all the host URLs
   * @param {string} uri to fetch the available hosts
   * @returns {string} new Url for connection
   */
  resetAllAndRetry: function resetAllAndRetry(uri) {
    if (!uri) {
      return _promise2.default.reject(new Error('`uri` is a required parameter'));
    }

    return this.inferServiceFromUrl(uri).then(function (service) {
      service.resetAllHosts();
      return service.url;
    });
  },


  /**
   * Find out what service this url belongs to (by looking at the host name)
   * @param {string} uri
   * @returns {Promise<ServiceModel>}
   */
  inferServiceFromUrl: function inferServiceFromUrl(uri) {
    var services = this.filter(function (service) {
      return service.doesUrlBelongToService(uri);
    });
    if (services.length >= 1) {
      return _promise2.default.resolve(services[0]);
    }

    return _promise2.default.reject(new Error('Unable to infer service for this url ' + uri));
  },


  /**
   * Find out what service this url belongs to, this returns the service name
   * instead of the service object
   * @param {string} uri Mark the host of this url as fail
   * @returns {Promise<ServiceModel.Service>}
   */
  inferServiceNameFromUrl: function inferServiceNameFromUrl(uri) {
    return this.inferServiceFromUrl(uri).then(function (service) {
      return service.service;
    });
  }
});

exports.default = ServiceCollection;


},{"./service-model":776,"ampersand-collection":838,"babel-runtime/core-js/promise":694}],776:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _some2 = require('lodash/some');

var _some3 = _interopRequireDefault(_some2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _ampersandState = require('ampersand-state');

var _ampersandState2 = _interopRequireDefault(_ampersandState);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Represent a service parsed from wdm registration.services and
 * registration.serviceHostMap.hostCatalog
 * @param {string} service Service name
 * @param {string} defaultUrl Url provided in registration.services
 * @param {Array<Host>} availableHosts Available datacenters from
 * registration.serviceHostMap sorted by priority
 * @param {string} url Basically is the defaultUrl replaced with host provided in
 * the catalog
 * @class
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var ServiceModel = _ampersandState2.default.extend({
  /**
    * @typedef {Object} Host - Represent a datacenter
    * @property {int} priority - Closer to 0 is higher priority.
    * @property {string} host - Host name.
    * @property {boolean} failed - True when cannot connect to url.
    */

  props: {
    service: 'string',
    defaultUrl: 'string',
    availableHosts: {
      type: 'array',
      default: function _default() {
        return [];
      }
    }
  },

  session: {
    currentHostIndex: {
      type: 'number',
      default: 0
    }
  },

  derived: {
    url: {
      deps: ['defaultUrl', 'availableHosts', 'currentHostIndex'],
      fn: function fn() {
        if (this.availableHosts.length === 0) {
          return this.defaultUrl;
        }
        var host = void 0;
        if (this.currentHostIndex >= this.availableHosts.length) {
          host = this.availableHosts[this.availableHosts.length - 1];
        } else {
          host = this.availableHosts[this.currentHostIndex];
        }

        return this._changeUrlHost(this.defaultUrl, host.host);
      }
    }
  },

  constructor: function constructor(attrs, options) {
    options = options || {};
    (0, _defaults3.default)(options, { parse: true });
    return (0, _apply2.default)(_ampersandState2.default.prototype.constructor, this, [attrs, options]);
  },


  idAttribute: 'service',

  // Override AmpersandState.serialize so we can return the latest url
  serialize: function serialize() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var attrs = (0, _apply2.default)(_ampersandState2.default.prototype.serialize, this, args);
    attrs.url = this.url;
    return attrs;
  },


  // Override parse
  parse: function parse(attrs) {
    if (!attrs) {
      return {};
    }

    if (attrs.availableHosts) {
      // ensure highest priority is at the top
      // using number value here instead boolean for IE and Edge
      // https://github.com/tc39/ecma262/issues/902
      attrs.availableHosts.sort(function (a, b) {
        return a.priority - b.priority;
      });
    }

    return attrs;
  },


  // Override set to make sure we always run parse()
  // See https://github.com/AmpersandJS/ampersand-state/issues/146 for related
  // bug
  set: function set(key, value, options) {
    var attrs = void 0;
    // Handle both `"key", value` and `{key: value}` -style arguments.
    // The next block is a direct copy from ampersand-state, so no need to test
    // both scenarios.
    /* istanbul ignore next */
    if ((0, _isObject3.default)(key) || key === null) {
      attrs = key;
      options = value;
    } else {
      attrs = {};
      attrs[key] = value;
    }

    attrs = this.parse(attrs, options);
    return (0, _apply2.default)(_ampersandState2.default.prototype.set, this, [attrs, options]);
  },


  /**
   * Mark the current host as failing or if a uri is provided, find the host
   * and mark it as fail
   * @param {string} uri Mark the host of this url as fail
   * @returns {undefined}
   */
  markHostFailed: function markHostFailed(uri) {
    var host = this.getCurrentHost();

    if (uri) {
      var urlObj = _url2.default.parse(uri);
      host = (0, _find3.default)(this.availableHosts, function (h) {
        return h.host === urlObj.host;
      });
    }

    if (host) {
      host.failed = true;
    }
  },


  /**
   * Return the next available host, which is usually the next higher priority
   * host that has not yet been marked as failed
   * @returns {Promise<Host>}
   */
  cycleNextHost: function cycleNextHost() {
    for (var i = 0; i < this.availableHosts.length; i += 1) {
      var host = this.availableHosts[i];
      if (!host.failed && this.currentHostIndex !== i) {
        this.currentHostIndex = i;
        return _promise2.default.resolve(host);
      }
    }
    // this means all hosts have failed
    this.currentHostIndex = 0;
    return _promise2.default.reject(new Error('All hosts have failed for ' + this.service));
  },


  /**
   * Check if a url comes from this service
   * @param {string} uri
   * @returns {Boolean}
   */
  doesUrlBelongToService: function doesUrlBelongToService(uri) {
    var urlObj = _url2.default.parse(uri);
    var hosts = this.availableHosts.map(function (h) {
      return h.host;
    });
    hosts.push(_url2.default.parse(this.defaultUrl).host);
    return (0, _some3.default)(hosts, function (host) {
      return host === urlObj.host;
    });
  },


  /**
   * Return the current host/datacenter
   * @returns {Host}
   */
  getCurrentHost: function getCurrentHost() {
    return this.availableHosts[this.currentHostIndex];
  },


  /**
   * Resets all host/datacenter for a retry
   * @returns {undefined}
   */
  resetAllHosts: function resetAllHosts() {
    this.availableHosts.forEach(function (host) {
      host.failed = false;
    });
  },


  /**
   * Replace provided url by the current active host
   * @param {string} uri
   * @returns {string} uri
   */
  replaceUrlWithCurrentHost: function replaceUrlWithCurrentHost(uri) {
    return this._changeUrlHost(uri, this.getCurrentHost().host);
  },
  _changeUrlHost: function _changeUrlHost(currentUrl, host) {
    var urlObj = _url2.default.parse(currentUrl);
    urlObj.host = host;
    return _url2.default.format(urlObj);
  }
});

exports.default = ServiceModel;


},{"ampersand-state":675,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"lodash/defaults":1618,"lodash/find":1627,"lodash/isObject":1659,"lodash/some":1696,"url":1765}],777:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.config = exports.DeviceUrlInterceptor = exports.UrlInterceptor = exports.EmbargoInterceptor = exports.ServiceModel = exports.ServiceCollection = exports.FeatureModel = exports.FeatureCollection = exports.FeaturesModel = exports.Device = exports.default = undefined;

var _device = require('./device');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_device).default;
  }
});
Object.defineProperty(exports, 'Device', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_device).default;
  }
});

var _featuresModel = require('./device/features-model');

Object.defineProperty(exports, 'FeaturesModel', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_featuresModel).default;
  }
});

var _featureCollection = require('./device/feature-collection');

Object.defineProperty(exports, 'FeatureCollection', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_featureCollection).default;
  }
});

var _featureModel = require('./device/feature-model');

Object.defineProperty(exports, 'FeatureModel', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_featureModel).default;
  }
});

var _serviceCollection = require('./device/service-collection');

Object.defineProperty(exports, 'ServiceCollection', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_serviceCollection).default;
  }
});

var _serviceModel = require('./device/service-model');

Object.defineProperty(exports, 'ServiceModel', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_serviceModel).default;
  }
});

var _embargo = require('./interceptors/embargo');

Object.defineProperty(exports, 'EmbargoInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_embargo).default;
  }
});

var _url = require('./interceptors/url');

Object.defineProperty(exports, 'UrlInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_url).default;
  }
});

var _deviceUrl = require('./interceptors/device-url');

Object.defineProperty(exports, 'DeviceUrlInterceptor', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_deviceUrl).default;
  }
});

var _config = require('./config');

Object.defineProperty(exports, 'config', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_config).default;
  }
});

var _sparkCore = require('@ciscospark/spark-core');

var _device2 = _interopRequireDefault(_device);

var _config2 = _interopRequireDefault(_config);

var _url2 = _interopRequireDefault(_url);

var _deviceUrl2 = _interopRequireDefault(_deviceUrl);

var _embargo2 = _interopRequireDefault(_embargo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

(0, _sparkCore.registerInternalPlugin)('device', _device2.default, {
  interceptors: {
    UrlInterceptor: _url2.default.create,
    DeviceUrlInterceptor: _deviceUrl2.default.create,
    EmbargoInterceptor: _embargo2.default.create
  },
  config: _config2.default,
  onBeforeLogout: function onBeforeLogout() {
    return this.unregister();
  }
});


},{"./config":769,"./device":774,"./device/feature-collection":771,"./device/feature-model":772,"./device/features-model":773,"./device/service-collection":775,"./device/service-model":776,"./interceptors/device-url":778,"./interceptors/embargo":779,"./interceptors/url":780,"@ciscospark/spark-core":804}],778:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _set2 = require('lodash/set');

var _set3 = _interopRequireDefault(_set2);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Adds 'cisco-device-url' header, as appropriate, to requests
 */
var DeviceUrlInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(DeviceUrlInterceptor, _Interceptor);

  function DeviceUrlInterceptor() {
    (0, _classCallCheck3.default)(this, DeviceUrlInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (DeviceUrlInterceptor.__proto__ || (0, _getPrototypeOf2.default)(DeviceUrlInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(DeviceUrlInterceptor, [{
    key: 'onRequest',


    /**
    * @see Interceptor#onRequest
    * @param {Object} options
    * @returns {Object}
    */
    value: function onRequest(options) {
      var _this2 = this;

      if (!this.spark.internal.device.url || options.headers && 'cisco-device-url' in options.headers && !options.headers['cisco-device-url']) {
        return _promise2.default.resolve(options);
      }

      return _promise2.default.resolve(options.service || this.spark.internal.device.determineService(options.uri)).then(function (service) {
        if (service && service !== 'oauth' && service !== 'saml') {
          (0, _set3.default)(options, 'headers[\'cisco-device-url\']', _this2.spark.internal.device.url);
        }
        return options;
      }).catch(function (err) {
        if (err.message.match(/does not reflect a known service/)) {
          return options;
        }

        throw err;
      });
    }
  }], [{
    key: 'create',

    /**
    * @returns {DeviceUrlInterceptor}
    */
    value: function create() {
      /* eslint no-invalid-this: [0] */
      return new DeviceUrlInterceptor({ spark: this });
    }
  }]);
  return DeviceUrlInterceptor;
}(_httpCore.Interceptor); /*!
                           * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                           */

exports.default = DeviceUrlInterceptor;


},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"lodash/set":1694}],779:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
var EmbargoInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(EmbargoInterceptor, _Interceptor);

  function EmbargoInterceptor() {
    (0, _classCallCheck3.default)(this, EmbargoInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (EmbargoInterceptor.__proto__ || (0, _getPrototypeOf2.default)(EmbargoInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(EmbargoInterceptor, [{
    key: 'onResponseError',


    /**
     * @see Interceptor#onResponseError
     * @param {Object} options
     * @param {Error} reason
     * @returns {Promise}
     */
    value: function onResponseError(options, reason) {
      if (reason.statusCode === 451) {
        this.spark.internal.device.clear();
        this.spark.credentials.clear();
        this.spark.logger.info('Received `HTTP 451 Unavailable For Legal Reasons`, discarding credentials and device registration');
      }

      return _promise2.default.reject(reason);
    }
  }], [{
    key: 'create',

    /**
     * @returns {EmbargoInterceptor}
     */
    value: function create() {
      /* eslint no-invalid-this: [0] */
      return new EmbargoInterceptor({ spark: this });
    }
  }]);
  return EmbargoInterceptor;
}(_httpCore.Interceptor); /*!
                           * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                           */

exports.default = EmbargoInterceptor;


},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],780:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pattern = /(?:^\/)|(?:\/$)/;

/**
 * @class
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var UrlInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(UrlInterceptor, _Interceptor);

  function UrlInterceptor() {
    (0, _classCallCheck3.default)(this, UrlInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (UrlInterceptor.__proto__ || (0, _getPrototypeOf2.default)(UrlInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(UrlInterceptor, [{
    key: 'onRequest',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @returns {Object}
     */
    value: function onRequest(options) {
      if (!options.uri) {
        this.checkOptions(options);
        this.normalizeOptions(options);

        return this.spark.internal.device.getServiceUrl(options.service).then(function (uri) {
          if (!uri) {
            return _promise2.default.reject(new Error('`' + options.service + '` is not a known service'));
          }

          // strip leading and trailing slashes before assembling the full uri
          if (options.resource) {
            uri = uri.replace(pattern, '') + '/' + options.resource.replace(pattern, '');
          }

          options.uri = uri;
          return options;
        });
      }

      return options;
    }

    /**
     * Verify that all required parameters have been specified.
     * @param {Object} options
     * @returns {Object}
     */

  }, {
    key: 'checkOptions',
    value: function checkOptions(options) {
      if (!options.api && !options.service) {
        throw new Error('A `service` or `uri` parameter is required');
      }

      if (!options.resource) {
        throw new Error('A `resource` parameter is required');
      }
    }

    /**
     * accept api or service and rename to service
     * @param {Object} options
     * @private
     * @returns {Object}
     */

  }, {
    key: 'normalizeOptions',
    value: function normalizeOptions(options) {
      if (options.service) {
        return;
      }

      (0, _assign2.default)(options, {
        service: options.service || options.api
      });

      (0, _deleteProperty2.default)(options, 'api');
    }
  }], [{
    key: 'create',

    /**
     * @returns {UrlInterceptor}
     */
    value: function create() {
      /* eslint no-invalid-this: [0] */
      return new UrlInterceptor({ spark: this });
    }
  }]);
  return UrlInterceptor;
}(_httpCore.Interceptor);

exports.default = UrlInterceptor;


},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708}],781:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _dec, _dec2, _desc, _value, _obj; /*!
                                       * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                       */

/* eslint camelcase: [0] */

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _common = require('@ciscospark/common');

var _sparkCore = require('@ciscospark/spark-core');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var OAUTH2_CSRF_TOKEN = 'oauth2-csrf-token';

/**
 * Browser support for OAuth2. Automatically parses the URL hash for an access
 * token
 * @class
 * @name AuthorizationBrowser
 */
var Authorization = _sparkCore.SparkPlugin.extend((_dec = (0, _common.whileInFlight)('isAuthorizing'), _dec2 = (0, _common.whileInFlight)('isAuthorizing'), (_obj = {
  derived: {
    /**
     * Alias of {@link AuthorizationBrowser#isAuthorizing}
     * @instance
     * @memberof AuthorizationBrowser
     * @type {boolean}
     */
    isAuthenticating: {
      deps: ['isAuthorizing'],
      fn: function fn() {
        return this.isAuthorizing;
      }
    }
  },

  session: {
    /**
     * Indicates if an Authorization Code exchange is inflight
     * @instance
     * @memberof AuthorizationBrowser
     * @type {boolean}
     */
    isAuthorizing: {
      default: false,
      type: 'boolean'
    },
    ready: {
      default: false,
      type: 'boolean'
    }
  },

  namespace: 'Credentials',

  /**
   * Initializer
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} attrs {@link AmpersandState}
   * @param {boolean} attrs.parse Controls whether or not the the url should get
   * parsed for an access token
   * @private
   * @returns {Authorization}
   */
  // eslint-disable-next-line complexity
  initialize: function initialize(attrs, options) {
    var _this = this;

    var ret = (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.initialize, this, [attrs, options]);
    // Reminder, we can't do parse based on config, because config is not
    // available until nextTick and we want to be able to throw errors found in
    // the url.
    if (attrs.parse === false) {
      this.ready = true;
      return ret;
    }
    var location = _url2.default.parse(this.spark.getWindow().location.href, true);
    this._checkForErrors(location);

    var hash = location.hash;
    if (!hash) {
      this.ready = true;
      return ret;
    }
    if (hash.includes('#')) {
      hash = hash.substr(1);
    }
    location.hash = _querystring2.default.parse(hash);
    if (location.hash.state) {
      location.hash.state = JSON.parse(_common.base64.decode(location.hash.state));
    }
    var tokenData = this._parseHash(location);
    if (!tokenData) {
      return ret;
    }
    this._cleanUrl(location);

    // Wait until nextTick in case `credentials` hasn't initialized yet
    process.nextTick(function () {
      _this.spark.credentials.set({ supertoken: tokenData });
      _this.ready = true;
    });

    return ret;
  },


  /**
   * Kicks off an oauth flow
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} options
   * @returns {Promise}
   */
  initiateLogin: function initiateLogin() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    options.state = options.state || {};
    options.state.csrf_token = this._generateSecurityToken();

    // If we're not explicitly a confidential client, assume we're a public
    // client
    if (this.config.clientType === 'confidential') {
      return this.initiateAuthorizationCodeGrant(options);
    }

    return this.initiateImplicitGrant(options);
  },

  /**
   * Kicks off the Authorization Code grant flow. Typically called via
   * {@link AuthorizationBrowser#initiateLogin}
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} options
   * @returns {Promise}
   */
  initiateImplicitGrant: function initiateImplicitGrant(options) {
    this.logger.info('authorization: initiating implicit grant flow');
    this.spark.getWindow().location = this.spark.credentials.buildLoginUrl((0, _assign2.default)({ response_type: 'token' }, options));
    return _promise2.default.resolve();
  },

  /**
   * Kicks off the Implicit Code grant flow. Typically called via
   * {@link AuthorizationBrowser#initiateLogin}
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} options
   * @returns {Promise}
   */
  initiateAuthorizationCodeGrant: function initiateAuthorizationCodeGrant(options) {
    this.logger.info('authorization: initiating authorization code grant flow');
    this.spark.getWindow().location = this.spark.credentials.buildLoginUrl((0, _assign2.default)({ response_type: 'code' }, options));
    return _promise2.default.resolve();
  },

  /**
   * Requests a Cisco Spark access token for a user already authenticated into
   * your product.
   *
   * Note: You'll need to supply a jwtRefreshCallback of the form
   * `Promise<jwt> = jwtRefreshCallback(spark)` for automatic token refresh to
   * work.
   *
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} options
   * @param {Object} options.jwt This is a jwt generated by your backend that
   * identifies a user in your system
   * @returns {Promise}
   */
  requestAccessTokenFromJwt: function requestAccessTokenFromJwt(_ref) {
    var _this2 = this;

    var jwt = _ref.jwt;

    return this.spark.request({
      method: 'POST',
      service: 'hydra',
      resource: 'jwt/login',
      headers: {
        authorization: jwt
      }
    }).then(function (_ref2) {
      var body = _ref2.body;
      return {
        access_token: body.token,
        token_type: 'Bearer',
        expires_in: body.expiresIn
      };
    }).then(function (token) {
      _this2.spark.credentials.set({
        supertoken: token
      });
    });
  },


  /**
   * Called by {@link SparkCore#logout()}. Redirects to the logout page
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} options
   * @param {boolean} options.noRedirect if true, does not redirect
   * @returns {Promise}
   */
  logout: function logout() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!options.noRedirect) {
      this.spark.getWindow().location = this.spark.credentials.buildLogoutUrl(options);
    }
  },


  /**
   * Checks if the result of the login redirect contains an error string
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} location
   * @private
   * @returns {Promise}
   */
  _checkForErrors: function _checkForErrors(location) {
    var query = location.query;
    if (query && query.error) {
      var ErrorConstructor = _sparkCore.grantErrors.select(query.error);
      throw new ErrorConstructor(query);
    }
  },


  /**
   * Removes no-longer needed values from the url (access token, csrf token, etc)
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} location
   * @private
   * @returns {Promise}
   */
  _cleanUrl: function _cleanUrl(location) {
    location = (0, _cloneDeep3.default)(location);
    if (this.spark.getWindow().history && this.spark.getWindow().history.replaceState) {
      ['access_token', 'token_type', 'expires_in', 'refresh_token', 'refresh_token_expires_in'].forEach(function (key) {
        return (0, _deleteProperty2.default)(location.hash, key);
      });
      location.hash.state = _common.base64.encode((0, _stringify2.default)((0, _omit3.default)(location.hash.state, 'csrf_token')));
      location.hash = _querystring2.default.stringify(location.hash);
      this.spark.getWindow().history.replaceState({}, null, _url2.default.format(location));
    }
  },


  /**
   * Generates a CSRF token and sticks in in sessionStorage
   * @instance
   * @memberof AuthorizationBrowser
   * @private
   * @returns {Promise}
   */
  _generateSecurityToken: function _generateSecurityToken() {
    this.logger.info('authorization: generating csrf token');

    var token = _uuid2.default.v4();
    this.spark.getWindow().sessionStorage.setItem('oauth2-csrf-token', token);
    return token;
  },


  /**
   * Parses the url hash into an access token object
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} location
   * @private
   * @returns {Object}
   */
  _parseHash: function _parseHash(location) {
    var hash = (0, _cloneDeep3.default)(location.hash);
    if (hash) {
      this._verifySecurityToken(hash);
    }
    if (!hash.access_token) {
      this.ready = true;
      return undefined;
    }
    if (hash.expires_in) {
      hash.expires_in = parseInt(hash.expires_in, 10);
    }
    if (hash.refresh_token_expires_in) {
      hash.refresh_token_expires_in = parseInt(hash.refresh_token_expires_in, 10);
    }
    return hash;
  },


  /**
   * Checks if the CSRF token in sessionStorage is the same as the one returned
   * in the url.
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} hash
   * @private
   * @returns {Promise}
   */
  _verifySecurityToken: function _verifySecurityToken(hash) {
    var sessionToken = this.spark.getWindow().sessionStorage.getItem(OAUTH2_CSRF_TOKEN);
    this.spark.getWindow().sessionStorage.removeItem(OAUTH2_CSRF_TOKEN);
    if (!sessionToken) {
      return;
    }

    if (!hash.state) {
      throw new Error('Expected CSRF token ' + sessionToken + ', but not found in redirect hash');
    }

    if (!hash.state.csrf_token) {
      throw new Error('Expected CSRF token ' + sessionToken + ', but not found in redirect hash');
    }

    var token = hash.state.csrf_token;

    if (token !== sessionToken) {
      throw new Error('CSRF token ' + token + ' does not match stored token ' + sessionToken);
    }
  },
  version: '1.32.5'
}, (_applyDecoratedDescriptor(_obj, 'initiateImplicitGrant', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initiateImplicitGrant'), _obj), _applyDecoratedDescriptor(_obj, 'initiateAuthorizationCodeGrant', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initiateAuthorizationCodeGrant'), _obj), _applyDecoratedDescriptor(_obj, 'requestAccessTokenFromJwt', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'requestAccessTokenFromJwt'), _obj)), _obj)));

exports.default = Authorization;


}).call(this,require('_process'))
},{"@ciscospark/common":731,"@ciscospark/spark-core":804,"_process":1743,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"lodash/cloneDeep":1612,"lodash/omit":1679,"querystring":1747,"url":1765,"uuid":868}],782:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

exports.default = {
  credentials: {
    /**
     * Controls whether {@link Authorization#initiateLogin()} requests a token
     * or an auth code. Anything other than 'confidential' will be treated as
     * 'public'
     * @private
     * @type {string}
     */
    clientType: 'public'
  }
};


},{}],783:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.config = exports.default = undefined;

var _authorization = require('./authorization');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_authorization).default;
  }
});

var _config = require('./config');

Object.defineProperty(exports, 'config', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_config).default;
  }
});

require('@ciscospark/internal-plugin-wdm');

var _sparkCore = require('@ciscospark/spark-core');

var _authorization2 = _interopRequireDefault(_authorization);

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var proxies = ['isAuthorizing', 'isAuthenticating'];

(0, _sparkCore.registerPlugin)('authorization', _authorization2.default, {
  config: _config2.default,
  proxies: proxies
});


},{"./authorization":781,"./config":782,"@ciscospark/internal-plugin-wdm":777,"@ciscospark/spark-core":804}],784:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pluginAuthorizationBrowser = require('@ciscospark/plugin-authorization-browser');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_pluginAuthorizationBrowser).default;
  }
});
Object.defineProperty(exports, 'config', {
  enumerable: true,
  get: function get() {
    return _pluginAuthorizationBrowser.config;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


},{"@ciscospark/plugin-authorization-browser":783}],785:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * @typedef {Object} LoggerConfig
 * @property {string} [level=process.env.LOGGER_LEVEL] - Maximum log level that
 * should be printed to the console. One of
 * silent|error|warn|log|info|debug|trace
 * @property {number} [historyLength=1000] - Maximum number of entries to store in the log buffer.
 * @example
 * {
 *   level: process.env.LOGGER_LEVEL,
 *   historyLength: 1000
 * }
 */

exports.default = {
  logger: {
    level: process.env.LOGGER_LEVEL,
    historyLength: 1000
  }
};


}).call(this,require('_process'))
},{"_process":1743}],786:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.levels = exports.default = undefined;

var _logger = require('./logger');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_logger).default;
  }
});
Object.defineProperty(exports, 'levels', {
  enumerable: true,
  get: function get() {
    return _logger.levels;
  }
});

var _sparkCore = require('@ciscospark/spark-core');

var _logger2 = _interopRequireDefault(_logger);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _sparkCore.registerPlugin)('logger', _logger2.default, {
  config: _config2.default,
  replace: true
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */


},{"./config":785,"./logger":787,"@ciscospark/spark-core":804}],787:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.levels = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _common = require('@ciscospark/common');

var _sparkCore = require('@ciscospark/spark-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var precedence = {
  silent: 0,
  error: 1,
  warn: 2,
  log: 3,
  info: 4,
  debug: 5,
  trace: 6
};

var levels = exports.levels = (0, _keys2.default)(precedence).filter(function (level) {
  return level !== 'silent';
});

var fallbacks = {
  error: ['log'],
  warn: ['error', 'log'],
  info: ['log'],
  debug: ['info', 'log'],
  trace: ['debug', 'info', 'log']
};

var authTokenKeyPattern = /[Aa]uthorization/;

/**
 * Recursively strips "authorization" fields from the specified object
 * @param {Object} object
 * @private
 * @returns {Object}
 */
function walkAndFilter(object) {
  if ((0, _isArray3.default)(object)) {
    return object.map(walkAndFilter);
  }
  if (!(0, _isObject3.default)(object)) {
    if ((0, _isString3.default)(object)) {
      if (_common.patterns.email.test(object)) {
        return '-- REDACTED --';
      }
    }
    return object;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)((0, _entries2.default)(object)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ref = _step.value;

      var _ref2 = (0, _slicedToArray3.default)(_ref, 2);

      var key = _ref2[0];
      var value = _ref2[1];

      if (authTokenKeyPattern.test(key)) {
        (0, _deleteProperty2.default)(object, key);
      } else {
        object[key] = walkAndFilter(value);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return object;
}

/**
 * @class
 */
var Logger = _sparkCore.SparkPlugin.extend({
  namespace: 'Logger',

  derived: {
    level: {
      cache: false,
      fn: function fn() {
        return this.getCurrentLevel();
      }
    }
  },
  session: {
    buffer: {
      type: 'array',
      default: function _default() {
        return [];
      }
    }
  },

  /**
   * Ensures auth headers don't get printed in logs
   * @param {Array<mixed>} args
   * @private
   * @memberof Logger
   * @returns {Array<mixed>}
   */
  filter: function filter() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args.map(function (arg) {
      // SparkHttpError already ensures auth tokens don't get printed, so, no
      // need to alter it here.
      if (arg instanceof Error) {
        // karma logs won't print subclassed errors correctly, so we need
        // explicitly call their tostring methods.
        if (process.env.NODE_ENV === 'test' && _common.inBrowser) {
          var ret = arg.toString();
          ret += 'BEGIN STACK';
          ret += arg.stack;
          ret += 'END STACK';
          return ret;
        }

        return arg;
      }

      arg = (0, _cloneDeep3.default)(arg);
      return walkAndFilter(arg);
    });
  },


  /**
   * Determines if the current level allows logs at the specified level to be
   * printed
   * @param {string} level
   * @private
   * @memberof Logger
   * @returns {boolean}
   */
  shouldPrint: function shouldPrint(level) {
    return precedence[level] <= precedence[this.getCurrentLevel()];
  },


  /**
   * Determines if the current level allows logs at the specified level to be
   * put into the log buffer. We're configuring it omit trace and debug logs
   * because there are *a lot* of debug logs that really don't provide value at
   * runtime (they're helpful for debugging locally, but really just pollute the
   * uploaded logs and push useful info out).
   * @param {string} level
   * @private
   * @memberof Logger
   * @returns {boolean}
   */
  shouldBuffer: function shouldBuffer(level) {
    return precedence[level] <= precedence.info;
  },


  /**
   * Indicates the current log level based on env vars, feature toggles, and
   * user type.
   * @instance
   * @memberof Logger
   * @private
   * @memberof Logger
   * @returns {string}
   */
  // eslint-disable-next-line complexity
  getCurrentLevel: function getCurrentLevel() {
    // If a level has been explicitly set via config, alway use it.
    if (this.config.level) {
      return this.config.level;
    }

    if (levels.includes(process.env.CISCOSPARK_LOG_LEVEL)) {
      return process.env.CISCOSPARK_LOG_LEVEL;
    }

    // Always use debug-level logging in test mode;
    if (process.env.NODE_ENV === 'test') {
      return 'trace';
    }

    // Use server-side-feature toggles to configure log levels
    var level = this.spark.internal.device && this.spark.internal.device.features.developer.get('log-level');
    if (level) {
      if (levels.includes(level)) {
        return level;
      }
    }

    return 'error';
  },
  version: '1.32.5'
});

levels.forEach(function (level) {
  var impls = fallbacks[level];
  var impl = level;
  if (impls) {
    impls = impls.slice();
    // eslint-disable-next-line no-console
    while (!console[impl]) {
      impl = impls.pop();
    }
  }

  // Much of the complexity in the following function is due to a test-mode-only
  // helper
  // eslint-disable-next-line complexity
  Logger.prototype[level] = function wrappedConsoleMethod() {
    try {
      var shouldPrint = this.shouldPrint(level);
      var shouldBuffer = this.shouldBuffer(level);
      if (!shouldBuffer && !shouldPrint) {
        return;
      }

      var filtered = this.filter.apply(this, arguments);
      var stringified = filtered.map(function (item) {
        if (item instanceof _sparkCore.SparkHttpError) {
          return item.toString();
        }
        return item;
      });

      if (shouldPrint) {
        var _console;

        // when logging an object in browsers, we tend to get a dynamic
        // reference, thus going back to look at the logged value doesn't
        // necessarily show the state at log time, thus we print the stringified
        // value.
        var toPrint = _common.inBrowser ? stringified : filtered;
        /* istanbul ignore if */
        if (process.env.NODE_ENV === 'test' && (0, _has3.default)(this, 'spark.internal.device.url')) {
          toPrint.unshift(this.spark.internal.device.url.slice(-3));
        }
        // eslint-disable-next-line no-console
        (_console = console)[impl].apply(_console, (0, _toConsumableArray3.default)(toPrint));
      }

      if (shouldBuffer) {
        stringified.unshift(Date.now());
        this.buffer.push(stringified);
        if (this.buffer.length > this.config.historyLength) {
          this.buffer.shift();
        }
      }
    } catch (reason) {
      /* istanbul ignore next */
      // eslint-disable-next-line no-console
      console.warn('failed to execute Logger#' + level, reason);
    }
  };
});

exports.default = Logger;


}).call(this,require('_process'))
},{"@ciscospark/common":731,"@ciscospark/spark-core":804,"_process":1743,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/entries":688,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/slicedToArray":709,"babel-runtime/helpers/toConsumableArray":710,"lodash/cloneDeep":1612,"lodash/has":1638,"lodash/isArray":1648,"lodash/isObject":1659,"lodash/isString":1662}],788:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

exports.default = {
  people: {
    batcherWait: 100,
    batcherMaxCalls: 10,
    batcherMaxWait: 1500,
    /**
     * optional flag that requires Hydra to send every type field,
     * even if the type is not "person" (e.g.: SX10, webhook_intergation, etc.)
     * @private
     */
    showAllTypes: false
  }
};


},{}],789:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _people = require('./people');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_people).default;
  }
});

var _sparkCore = require('@ciscospark/spark-core');

var _people2 = _interopRequireDefault(_people);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _sparkCore.registerPlugin)('people', _people2.default, {
  config: _config2.default
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */


},{"./config":788,"./people":791,"@ciscospark/spark-core":804}],790:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _sparkCore = require('@ciscospark/spark-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * @ignore
 */
var PersonUUIDRequestBatcher = _sparkCore.Batcher.extend({
  namespace: 'People',

  /**
   * @instance
   * @memberof PersonUUIDRequestBatcher
   * @param {HttpResponseObject} res
   * @returns {Promise}
   */
  handleHttpSuccess: function handleHttpSuccess(res) {
    var _this = this;

    return _promise2.default.all(res.body.items.map(function (personResponse) {
      return _this.handleItemSuccess(personResponse.id, personResponse);
    }));
  },
  handleItemFailure: function handleItemFailure(email, response) {
    return this.getDeferredForResponse(email).then(function (defer) {
      defer.reject(response);
    });
  },


  /**
   * @instance
   * @memberof PersonUUIDRequestBatcher
   * @param {string} email
   * @param {Object} response
   * @returns {Promise}
   */
  handleItemSuccess: function handleItemSuccess(email, response) {
    return this.getDeferredForResponse(email).then(function (defer) {
      defer.resolve(response);
    });
  },


  /**
   * @instance
   * @memberof PersonUUIDRequestBatcher
   * @param {string} uuidOrHydraId
   * @returns {Promise<string>}
   */
  fingerprintRequest: function fingerprintRequest(uuidOrHydraId) {
    var hydraId = this.spark.people.inferPersonIdFromUuid(uuidOrHydraId);
    return _promise2.default.resolve(hydraId);
  },


  /**
   * @instance
   * @memberof PersonUUIDRequestBatcher
   * @param {string} hydraId
   * @returns {Promise<string>}
   */
  fingerprintResponse: function fingerprintResponse(hydraId) {
    return _promise2.default.resolve(hydraId);
  },
  prepareRequest: function prepareRequest(ids) {
    return _promise2.default.resolve(ids.join());
  },


  /**
   * @instance
   * @memberof PersonUUIDRequestBatcher
   * @param {Object} ids
   * @returns {Promise<HttpResponseObject>}
   */
  submitHttpRequest: function submitHttpRequest(ids) {
    return this.spark.request({
      service: 'hydra',
      resource: 'people/?id=' + ids + '&showAllTypes=' + this.config.showAllTypes
    });
  }
}); /*!
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = PersonUUIDRequestBatcher;


},{"@ciscospark/spark-core":804,"babel-runtime/core-js/promise":694}],791:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _desc, _value, _obj; /*!
                          * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                          */

var _sparkCore = require('@ciscospark/spark-core');

var _common = require('@ciscospark/common');

var _peopleBatcher = require('./people-batcher');

var _peopleBatcher2 = _interopRequireDefault(_peopleBatcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @typedef {Object} PersonObject
 * @property {string} id - (server generated) Unique identifier for the person
 * @property {Array<email>} emails - Email addresses of the person
 * @property {string} displayName - Display name of the person
 * @property {isoDate} created - (server generated) The date and time that the person was created
 */

/**
 * @class
 */
var People = _sparkCore.SparkPlugin.extend((_obj = {
  namespace: 'People',

  children: {
    batcher: _peopleBatcher2.default
  },
  /**
   * Returns a single person by ID
   * @instance
   * @memberof People
   * @param {PersonObject|uuid|string} person
   * @returns {Promise<PersonObject>}
   * @example
   * ciscospark.rooms.create({title: 'Get Person Example'})
   *   .then(function(room) {
   *     return ciscospark.memberships.create({
   *       personEmail: 'alice@example.com',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(membership) {
   *     return ciscospark.people.get(membership.personId);
   *   })
   *   .then(function(alice) {
   *     var assert = require('assert');
   *     assert(alice.id);
   *     assert(Array.isArray(alice.emails));
   *     assert.equal(alice.emails.filter(function(email) {
   *       return email === 'alice@example.com';
   *     }).length, 1);
   *     assert(alice.displayName);
   *     assert(alice.created);
   *     return 'success';
   *   });
   *   // => success
   */
  get: function get(person) {
    if (!person) {
      return _promise2.default.reject(new Error('A person with an id is required'));
    }
    if (person === 'me') {
      return this._getMe();
    }
    var id = person.personId || person.id || person;
    return this.batcher.request(id);
  },


  /**
   * Returns a list of people
   * @instance
   * @memberof People
   * @param {Object | uuid[]} options or array of uuids
   * @param {email} options.email - Returns people with an email that contains this string
   * @param {string} options.displayName - Returns people with a name that contains this string
   * @param {bool} showAllTypes optional flag that requires Hydra to send every type field,
   * even if the type is not "person" (e.g.: SX10, webhook_intergation, etc.)
   * @returns {Promise<Page<PersonObject>>}
   * @example
   * var room;
   * ciscospark.rooms.create({title: 'List People Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.memberships.create({
   *       personEmail: 'alice@example.com',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function() {
   *     return ciscospark.memberships.create({
   *       personEmail: 'bob@example.com',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function() {
   *     return ciscospark.people.list({email: 'alice@example.com'});
   *   })
   *   .then(function(people) {
   *     var assert = require('assert');
   *     assert.equal(people.length, 1);
   *     var person = people.items[0];
   *     assert(person.id);
   *     assert(Array.isArray(person.emails));
   *     assert(person.displayName);
   *     assert(person.created);
   *     return 'success';
   *   });
   *   // => success
   *  @example <caption>Example usage of array method</caption>
   * var room;
   * var aliceId;
   * var bobId;
   * ciscospark.rooms.create({title: 'List People Array Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.memberships.create({
   *       personEmail: 'alice@example.com',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(membership) {
   *     aliceId = membership.personId;
   *   })
   *   .then(function() {
   *     return ciscospark.memberships.create({
   *       personEmail: 'bob@example.com',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(membership) {
   *     bobId = membership.personId;
   *   })
   *   .then(function() {
   *     return ciscospark.people.list([aliceId, bobId]);
   *   })
   *   .then(function(people) {
   *     var assert = require('assert');
   *     assert.equal(people.length, 2);
   *     var person = people.items[0];
   *     assert(person.id);
   *     assert(Array.isArray(person.emails));
   *     assert(person.displayName);
   *     assert(person.created);
   *     return 'success';
   *   });
   *   // => success
   */
  list: function list(options) {
    var _this = this;

    if (Array.isArray(options)) {
      var peopleIds = options;
      return _promise2.default.all(peopleIds.map(function (personId) {
        return _this.batcher.request(personId);
      }));
    }
    return this.request({
      service: 'hydra',
      resource: 'people',
      qs: options
    }).then(function (res) {
      return new _sparkCore.Page(res, _this.spark);
    });
  },


  /**
   * Converts a uuid to a hydra id without a network dip.
   * @param {string} id
   * @private
   * @returns {string}
   */
  inferPersonIdFromUuid: function inferPersonIdFromUuid(id) {
    // base64.validate seems to return true for uuids, so we need a different
    // check
    try {
      if (_common.base64.decode(id).includes('ciscospark://')) {
        return id;
      }
    } catch (err) {
      // ignore
    }
    return _common.base64.encode('ciscospark://us/PEOPLE/' + id);
  },
  _getMe: function _getMe() {
    return this.spark.request({
      service: 'hydra',
      resource: 'people/me'
    }).then(function (res) {
      return res.body;
    });
  },
  version: '1.32.5'
}, (_applyDecoratedDescriptor(_obj, '_getMe', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_getMe'), _obj)), _obj));

exports.default = People;


},{"./people-batcher":790,"@ciscospark/common":731,"@ciscospark/spark-core":804,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694}],792:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = boolToStatus;
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Helper for converting booleans into an sdp-style direction string
 * @param {Boolean} sending
 * @param {Boolean} receiving
 * @private
 * @returns {String}
 */
function boolToStatus(sending, receiving) {
  if (sending && receiving) {
    return 'sendrecv';
  }

  if (sending && !receiving) {
    return 'sendonly';
  }

  if (!sending && receiving) {
    return 'recvonly';
  }

  if (!sending && !receiving) {
    return 'inactive';
  }

  throw new Error('If you see this error, your JavaScript engine has a major flaw');
}


},{}],793:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ampersandState = require('ampersand-state');

var _ampersandState2 = _interopRequireDefault(_ampersandState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
var CallMembership = _ampersandState2.default.extend({
  idAttribute: '_id',

  props: {
    /**
     * Internal identifier for keeping track of memberships. Will be replaced at
     * some future point with a proper {@link CallMembership#id} field.
     * @instance
     * @memberof CallMembership
     * @private
     * @readonly
     */
    _id: {
      required: true,
      type: 'string'
    },

    /**
     * Indicates if the member is the current user. (mostly just to simplify
     * searching the CallMemberships array)
     * @instance
     * @memberof CallMembership
     * @private
     * @readonly
     */
    isSelf: {
      default: false,
      type: 'boolean'
    },

    /**
     * Indicates if the member started the call
     * @instance
     * @memberof CallMembership
     * @type {boolean}
     * @readonly
     */
    isInitiator: {
      default: false,
      required: true,
      type: 'boolean'
    },

    /**
     * @instance
     * @memberof CallMembership
     * @type {string}
     * @readonly
     */
    personId: {
      type: 'string'
    },

    /**
     * Mostly here for testing and potentially for widget support. Do not use.
     * @instance
     * @memberof CallMembership
     * @private
     * @type {string}
     * @readonly
     */
    personUuid: {
      require: true,
      type: 'string'
    },

    /**
     * Indicates the member's relationship with the call. One of
     * - notified - the party has been invited to the call but has not yet accepted
     * - connected - the party is participating in the call
     * - declined - the party chose not to accept the call
     * - disconnected - the party is no longer participating in the call
     * - waiting - reserved for future use
     * @instance
     * @memberof CallMembership
     * @type {string}
     * @readonly
     */
    state: {
      required: true,
      type: 'string',
      values: ['notified', 'connected', 'declined', 'disconnected', 'waiting']
    },

    /**
     * Indicates if the member has muted their microphone
     * @instance
     * @memberof CallMembership
     * @type {boolean}
     * @readonly
     */
    audioMuted: {
      default: false,
      type: 'boolean'
    },

    /**
     * Indicates if the member has disable their camera
     * @instance
     * @memberof CallMembership
     * @type {boolean}
     * @readonly
     */
    videoMuted: {
      default: false,
      type: 'boolean'
    }
  }
});

exports.default = CallMembership;


},{"ampersand-state":675}],794:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ampersandCollection = require('ampersand-collection');

var _ampersandCollection2 = _interopRequireDefault(_ampersandCollection);

var _ampersandCollectionLodashMixin = require('ampersand-collection-lodash-mixin');

var _ampersandCollectionLodashMixin2 = _interopRequireDefault(_ampersandCollectionLodashMixin);

var _callMembership = require('./call-membership');

var _callMembership2 = _interopRequireDefault(_callMembership);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * @name CallMemberships
 */
var CallMemberships = _ampersandCollection2.default.extend(_ampersandCollectionLodashMixin2.default, {
  model: _callMembership2.default,

  // Long-term, this should be membership id, but we don't have that yet.
  mainIndex: '_id'
});

exports.default = CallMemberships;


},{"./call-membership":793,"ampersand-collection":838,"ampersand-collection-lodash-mixin":672}],795:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _wrap2 = require('lodash/wrap');

var _wrap3 = _interopRequireDefault(_wrap2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _dec, _dec2, _dec3, _dec4, _desc, _value, _obj; /*!
                                                     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                                     */

/* eslint-env browser: true */

var _lodashDecorators = require('lodash-decorators');

var _sdpTransform = require('sdp-transform');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _sparkCore = require('@ciscospark/spark-core');

var _common = require('@ciscospark/common');

var _internalPluginLocus = require('@ciscospark/internal-plugin-locus');

var _mediaEngineWebrtc = require('@ciscospark/media-engine-webrtc');

var _mediaEngineWebrtc2 = _interopRequireDefault(_mediaEngineWebrtc);

var _stateParsers = require('./state-parsers');

var _boolToStatus = require('./bool-to-status');

var _boolToStatus2 = _interopRequireDefault(_boolToStatus);

var _callMemberships = require('./call-memberships');

var _callMemberships2 = _interopRequireDefault(_callMemberships);

var _filter = require('./stats/filter');

var _filter2 = _interopRequireDefault(_filter);

var _stream = require('./stats/stream');

var _stream2 = _interopRequireDefault(_stream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var deprecatedCallEventNames = ['ringing', 'connected', 'disconnected', 'replaced'];

/**
 * Pulls the direction line for the specified media kind from an sdp
 * @param {string} kind
 * @param {string} sdp
 * @private
 * @returns {string}
 */
function getMediaDirectionFromSDP(kind, sdp) {
  var parsed = typeof sdp === 'string' ? (0, _sdpTransform.parse)(sdp) : sdp;

  var media = void 0;
  if (kind === 'screen') {
    media = parsed.media.find(function (m) {
      return m.type === 'video' && m.content;
    });
  } else {
    media = parsed.media.find(function (m) {
      return m.type === kind;
    });
  }
  if (!media || !media.direction) {
    return 'inactive';
  }

  return media.direction;
}

/**
 * Reverses a media direction from offer to answer (e.g. sendonly -> recvonly)
 * @param {string} dir
 * @private
 * @returns {string}
 */
function reverseMediaDirection(dir) {
  switch (dir) {
    case 'inactive':
    case 'sendrecv':
      return dir;
    case 'sendonly':
      return 'recvonly';
    case 'recvonly':
      return 'sendonly';
    default:
      throw new Error('direction "' + dir + '" is not valid');
  }
}

/**
 * Helper for detmerming what mute value toggles to send to locus.
 * @private
 *
 * @param {string} kind
 * @param {string} offer
 * @param {string} answer
 * @returns {boolean}
 */
function didChange(kind, offer, answer) {
  var o = (0, _sdpTransform.parse)(offer).media.find(function (m) {
    return m.type === kind;
  });
  var a = (0, _sdpTransform.parse)(answer).media.find(function (m) {
    return m.type === kind;
  });

  if (!o && !a) {
    return false;
  }

  if (!o && a.direction.includes('send')) {
    return true;
  }

  if (!a && o.direction.includes('send')) {
    return true;
  }

  if (o.direction === a.direction) {
    return false;
  }

  if (o.direction.includes('send') && a.direction.includes('send') || !o.direction.includes('send') && !a.direction.includes('send')) {
    return false;
  }
  return true;
}

var capitalize = {
  audio: 'Audio',
  video: 'Video'
};

/**
 * @event ringing
 * @instance
 * @memberof Call
 * @deprecated with {@link PhoneConfig.enableExperimentalGroupCallingSupport}
 * enabled; instead, listen for {@link Call.membership:notified}
 */

/**
 * @event connected
 * @instance
 * @memberof Call
 * @deprecated with {@link PhoneConfig.enableExperimentalGroupCallingSupport}
 * enabled; instead, listen for {@link Call.active}
 */

/**
 * @event disconnected
 * @instance
 * @memberof Call
 * @deprecated with {@link PhoneConfig.enableExperimentalGroupCallingSupport}
 * enabled; instead, listen for {@link Call.inactive}
 */

/**
 * @event active
 * @instance
 * @memberof Call
 * @description only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event initializing
 * @instance
 * @memberof Call
 * @description only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event inactive
 * @instance
 * @memberof Call
 * @description only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event terminating
 * @instance
 * @memberof Call
 * @description only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event localMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event remoteMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event error
 * @instance
 * @memberof Call
 */

/**
 * @event membership:notified
 * @instance
 * @memberof Call
 * @type {CallMembership}
 * @description This replaces the {@link Call.ringing} event, but note that it's
 * subtly different. {@link Call.ringing} is emitted when the remote party calls
 * {@link Call#acknowledge()} whereas {@link Call.membership:notified} emits
 * shortly after (but as a direct result of) locally calling
 * {@link Phone#dial()}
 */

/**
 * @event membership:connected
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:declined
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:disconnected
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:waiting
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:change
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event memberships:add
 * @instance
 * @memberof Call
 * @description Emitted when a new {@link CallMembership} is added to
 * {@link Call#memberships}. Note that {@link CallMembership#state} still needs
 * to be read to determine if the instance represents someone actively
 * participating the call.
 */

/**
 * @event memberships:remove
 * @instance
 * @memberof Call
 * @description Emitted when a {@link CallMembership} is removed from
 * {@link Call#memberships}.
 */

/**
 * Payload for {@link Call#sendFeedback}
 * @typedef {Object} FeedbackObject
 * @property {number} userRating Number between 1 and 5 (5 being best) to let
 * the user score the call
 * @property {string} userComments Freeform feedback from the user about the
 * call
 * @property {Boolean} includeLogs set to true to submit client logs to the
 * Cisco Spark cloud. Note: at this time, all logs, not just call logs,
 * generated by the sdk will be uploaded to the Spark Cloud. Care has been taken
 * to avoid including PII in these logs, but if you've taken advantage of the
 * SDK's logger, you should make sure to avoid logging PII as well.
 */

/**
 * @class
 */
var Call = _sparkCore.SparkPlugin.extend((_dec = (0, _common.whileInFlight)('locusJoinInFlight'), _dec2 = (0, _common.deprecated)('Please use Call#reject()'), _dec3 = (0, _common.whileInFlight)('locusLeaveInFlight'), _dec4 = (0, _lodashDecorators.debounce)(), (_obj = {
  namespace: 'Phone',

  children: {
    media: _mediaEngineWebrtc2.default
  },

  collections: {
    /**
     * @instance
     * @memberof Call
     * @type CallMemberships
     */
    memberships: _callMemberships2.default
  },

  session: {
    activeParticipantsCount: {
      default: 0,
      required: true,
      type: 'number'
    },
    /**
     * Indicates if the other party in the call has turned off their microphone.
     * `undefined` for multiparty calls
     * @instance
     * @memberof Call
     * @readonly
     * @type {boolean}
     */
    remoteAudioMuted: {
      default: false,
      required: false,
      type: 'boolean'
    },

    /**
     * Indicates if the other party in the call has turned off their camera.
     * `undefined` for multiparty calls
     * @instance
     * @memberof Call
     * @readonly
     * @type {boolean}
     */
    remoteVideoMuted: {
      default: false,
      required: false,
      type: 'boolean'
    },

    correlationId: 'string',
    /**
     * @instance
     * @memberof Call
     * @readonly
     * @type {string}
     */
    facingMode: {
      type: 'string',
      values: ['user', 'environment']
    },
    /**
     * Derived from locus.id and locus.fullState.lastActive. Not actually a
     * "derived" property because it shouldn't be reset in event a locus
     * replacement. Marked as private because this isn't necessarily the callId
     * that we'll eventually expose as a first-class feature.
     * @instance
     * @memberof Call
     * @private
     * @readonly
     * @type {string}
     */
    internalCallId: {
      setOnce: true,
      type: 'string'
    },
    locus: 'object',
    /**
     * Returns the local MediaStream for the call. May initially be `null`
     * between the time @{Phone#dial is invoked and the  media stream is
     * acquired if {@link Phone#dial} is invoked without a `localMediaStream`
     * option.
     *
     * This property can also be set mid-call in which case the streams sent to
     * the remote party are replaced by this stream. On success, the
     * {@link Call}'s {@link localMediaStream:change} event fires, notifying any
     * listeners that we are now sending media from a new source.
     * @instance
     * @memberof Call
     * @type {MediaStream}
     */
    localMediaStream: 'object',

    locusJoinInFlight: {
      default: false,
      type: 'boolean'
    },
    locusLeaveInFlight: {
      default: false,
      type: 'boolean'
    },
    /**
     * Test helper. Shortcut to the current user's membership object. not
     * official for now, but may get published at some point
     * @instance
     * @memberof Call
     * @private
     * @type {CallMembership}
     */
    me: {
      type: 'object'
    }
  },

  // Note, in its current form, any derived property that is an object will emit
  // a change event everytime a locus gets replaced, even if no values change.
  // For the moment, this is probably ok; once we have multi-party, regular
  // change events on activeParticipants may be a problem.
  derived: {
    id: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return (0, _get3.default)(this, 'locus.url');
      }
    },
    isActive: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return !!(this.locus && (0, _stateParsers.isActive)(this.locus));
      }
    },
    joinedOnThisDevice: {
      deps: ['locus'],
      default: false,
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return !!(this.locus && (0, _stateParsers.joinedOnThisDevice)(this.spark, this.locus));
      }
    },
    locusUrl: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return (0, _get3.default)(this, 'locus.url');
      }
    },
    device: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return (0, _stateParsers.getThisDevice)(this.spark, this.locus);
      }
    },
    mediaConnection: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        var device = (0, _stateParsers.getThisDevice)(this.spark, this.locus);
        return (0, _get3.default)(device, 'mediaConnections[0]');
      }
    },
    mediaId: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        var device = (0, _stateParsers.getThisDevice)(this.spark, this.locus);
        return (0, _get3.default)(device, 'mediaConnections[0].mediaId');
      }
    },
    /**
     * The other participant in a two-party call. `undefined` for multiparty
     * calls
     * @instance
     * @memberof Call
     * @readyonly
     * @type {CallMembership}
     */
    remoteMember: {
      deps: ['memberships', 'locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        if ((0, _stateParsers.isCall)(this.locus)) {
          return this.memberships.find(function (m) {
            return !m.isSelf;
          });
        }

        return undefined;
      }
    },
    direction: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        // This seems brittle, but I can't come up with a better way. The only
        // way we should have a Call without a locus is if we just initiated a
        // call but haven't got the response from locus yet.
        if (!this.locus) {
          return 'out';
        }
        return (0, _stateParsers.direction)(this.locus);
      }
    },
    from: {
      deps: ['memberships'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        if (this.isCall) {
          return this.memberships.find(function (m) {
            return m.isInitiator;
          });
        }
        return undefined;
      }
    },
    to: {
      deps: ['memberships'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        if (this.isCall) {
          return this.memberships.find(function (m) {
            return !m.isInitiator;
          });
        }
        return undefined;
      }
    },
    /**
     * <b>active</b> - At least one person (not necessarily this user) is
     * participating in the call<br/>
     * <b>inactive</b> - No one is participating in the call<br/>
     * <b>initializing</b> - reserved for future use<br/>
     * <b>terminating</b> - reserved for future use<br/>
     * Only defined if
     * {@link PhoneConfig.enableExperimentalGroupCallingSupport} has been
     * enabled
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    state: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        if (this.config.enableExperimentalGroupCallingSupport) {
          return (0, _stateParsers.getState)(this.locus);
        }

        return undefined;
      }
    },
    /**
     * <b>initiated</b> - Offer was sent to remote party but they have not yet
     * accepted <br>
     * <b>ringing</b> - Remote party has acknowledged the call <br>
     * <b>connected</b> - At least one party is still on the call <br>
     * <b>disconnected</b> - All parties have dropped <br>
     * <b>replaced</b> - In (hopefully) rare cases, the underlying data backing
     * a Call instance may change in such a way that further interaction with
     * that Call is handled by a different instance. In such cases, the first
     * Call's status, will transition to `replaced`, which is almost the same
     * state as `disconnected`. Generally speaking, such a transition should not
     * happen for a Call instance that is actively sending/receiving media.
     * @deprecated The {@link Call#status} attribute will likely be replaced by
     * the {@link Call#state}.
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    status: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return (0, _stateParsers.getStatus)(this.spark, this.locus, this.previousAttributes().locus);
      }
    },
    /**
     * Access to the remote party’s `MediaStream`.
     * @instance
     * @memberof Call
     * @member {MediaStream}
     * @readonly
     */
    remoteMediaStream: {
      deps: ['media.remoteMediaStream'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return this.media.remoteMediaStream;
      }
    },
    /**
     * Access to the local party’s screen share `MediaStream`.
     * @instance
     * @memberof Call
     * @member {MediaStream}
     * @readonly
     */
    localScreenShare: {
      deps: ['media.localScreenShare'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return this.media.localScreenShare;
      }
    },
    receivingAudio: {
      deps: ['media.receivingAudio'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return this.media.receivingAudio;
      }
    },
    receivingVideo: {
      deps: ['media.receivingVideo'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return this.media.receivingVideo;
      }
    },
    sendingAudio: {
      deps: ['media.sendingAudio'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return this.media.sendingAudio;
      }
    },
    sendingVideo: {
      deps: ['media.sendingVideo'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return this.media.sendingVideo;
      }
    },
    isCall: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return (0, _stateParsers.isCall)(this.locus);
      }
    },
    supportsDtmf: {
      deps: ['locus'],
      /**
       * @private
       * @returns {mixed}
       */
      fn: function fn() {
        return (0, _get3.default)(this, 'locus.self.enableDTMF');
      }
    }
  },

  /**
   * Use to acknowledge (without answering) an incoming call. Will cause the
   * initiator's Call instance to emit the ringing event.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  acknowledge: function acknowledge() {
    var _this = this;

    this.logger.info('call: acknowledging');
    return this.spark.internal.locus.alert(this.locus).then(function (locus) {
      return _this.setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this.logger.info('call: acknowledged');
    }));
  },

  // Note: the `whileInFlight` decorator screws up name inferrence, so we need
  // to include @name below.
  /**
   * Answers an incoming call.
   * @instance
   * @name answer
   * @memberof Call
   * @param {Object} options
   * @param {MediaStreamConstraints} options.constraints
   * @returns {Promise}
   */
  answer: function answer(options) {
    var _this2 = this;

    this.logger.info('call: answering');
    if (!this.locus) {
      this.logger.info('call: no locus provided, answer() is a noop');
      return _promise2.default.resolve();
    }
    // Locus may think we're joined on this device if we e.g. reload the page,
    // so, we need to check if we also have a working peer connection
    // this.media.pc.remoteDescription.sdp is a temporary proxy for
    // pc.connectionState until chrome catches up to the spec
    if (this.joinedOnThisDevice && this.media.pc.remoteDescription && this.media.pc.remoteDescription.sdp) {
      this.logger.info('call: already joined on this device');
      return _promise2.default.resolve();
    }
    return this.createOrJoinLocus(this.locus, options).then((0, _common.tap)(function () {
      return _this2.logger.info('call: answered');
    }));
  },


  /**
   * Change the receiving media state. may induce a renegoatiation
   * @instance
   * @memberof Call
   * @param {string} kind one of "audio" or "video"
   * @param {boolean} value
   * @private
   * @returns {Promise}
   */
  changeReceivingMedia: function changeReceivingMedia(kind, value) {
    var _this3 = this;

    return new _promise2.default(function (resolve) {
      var sdp = (0, _sdpTransform.parse)(_this3.media.offerSdp);
      var section = (0, _find3.default)(sdp.media, { type: kind });
      // If the current offer is going to trigger a renegotiation, then we don't
      // need to renegotiate here.
      if (!section || !section.direction.includes('recv')) {
        _this3.logger.info('changeReceivingMedia: expecting to renegotiate, waiting for media to emit "answeraccepted"');
        _this3.media.once('answeraccepted', function () {
          return resolve(_this3.updateMuteToggles());
        });
      } else {
        _this3.logger.info('changeReceivingMedia: expecting to renegotiate, waiting for call to emit "change:receiving' + capitalize[kind] + '"');
        _this3.once('change:receiving' + capitalize[kind], function () {
          return resolve();
        });
      }

      var newDirection = (0, _boolToStatus2.default)(_this3.media['sending' + capitalize[kind]], value);
      _this3.media.setMedia(kind, newDirection);
    });
  },


  /**
   * Change the receiving media state. may induce a renegoatiation
   * @instance
   * @memberof Call
   * @param {string} kind one of "audio" or "video"
   * @param {boolean} value
   * @private
   * @returns {Promise}
   */
  changeSendingMedia: function changeSendingMedia(kind, value) {
    var _this4 = this;

    this.logger.info('changeSendingMedia: changing sending "' + kind + '" to "' + value + '"');
    return new _promise2.default(function (resolve) {
      var sdp = (0, _sdpTransform.parse)(_this4.media.offerSdp);
      var section = (0, _find3.default)(sdp.media, { type: kind });
      // If the current offer is going to trigger a renegotiation, then we don't
      // need to renegotiate here.
      if (!section || !section.direction.includes('send')) {
        _this4.logger.info('changeSendingMedia: expecting to renegotiate, waiting for media to emit "answeraccepted"');
        _this4.media.once('answeraccepted', function () {
          return resolve();
        });
      } else {
        _this4.logger.info('changeSendingMedia: expecting to renegotiate, waiting for call to emit "change:sending' + capitalize[kind] + '"');
        _this4.once('change:sending' + capitalize[kind], function () {
          return resolve(_this4.updateMuteToggles());
        });
      }

      var newDirection = (0, _boolToStatus2.default)(value, _this4.media['receiving' + capitalize[kind]]);
      _this4.media.setMedia(kind, newDirection);
    });
  },


  /**
   * Does the cleanup after a call has ended
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  cleanup: function cleanup() {
    var _this5 = this;

    return new _promise2.default(function (resolve) {
      // need to do this on next tick otherwise this.off() prevents remaining
      // events from being received (e.g. other listeners for `disconnected`
      // won't execute)
      process.nextTick(function () {
        _this5.media.stop();
        _this5.stopListening(_this5.spark.internal.mercury);
        _this5.off();
        resolve();
      });
    });
  },

  /**
   * Call and answer require nearly identical logic, so this method unifies them.
   * @instance
   * @memberof Call
   * @param {Object|locus} target
   * @param {Object} options
   * @todo remove 'locusMethodName' and move that logic to locus plugin
   * @todo move options and target processing to separate function
   * @todo rename to join()?
   * @returns {Promise}
   */
  createOrJoinLocus: function createOrJoinLocus(target) {
    var _this6 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (options.localMediaStream) {
      this.localMediaStream = options.localMediaStream;
    } else {
      if (!options.constraints) {
        options.constraints = {
          audio: true,
          video: {
            facingMode: {
              ideal: this.spark.phone.defaultFacingMode
            }
          }
        };
      }

      var mode = (0, _get3.default)(options, 'constraints.video.facingMode.ideal', (0, _get3.default)(options, 'constraints.video.facingMode.exact'));
      if (mode === 'user' || mode === 'environment') {
        this.facingMode = mode;
      }

      var recvOnly = !options.constraints.audio && !options.constraints.video;
      options.offerOptions = (0, _defaults3.default)(options.offerOptions, {
        offerToReceiveAudio: recvOnly || !!options.constraints.audio,
        offerToReceiveVideo: recvOnly || !!options.constraints.video
      });

      if (options.constraints.fake) {
        this.media.constraints.fake = true;
      }

      this.media.setMedia('audio', (0, _boolToStatus2.default)(options.constraints.audio, options.offerOptions.offerToReceiveAudio), options.constraints.audio);
      if ((0, _get3.default)(options, 'constraints.video.mediaSource') === 'screen' || (0, _get3.default)(options, 'constraints.video.mediaSource') === 'application') {
        this.media.setMedia('screen', 'sendonly');
      } else {
        this.media.setMedia('video', (0, _boolToStatus2.default)(options.constraints.video, options.offerOptions.offerToReceiveVideo), options.constraints.video);
      }
    }

    if (!target.correlationId) {
      options.correlationId = _uuid2.default.v4();
      this.correlationId = options.correlationId;
    }

    if (!this.correlationId) {
      this.correlationId = target.correlationId;
    }

    // reminder: not doing this copy in initialize() because config may not yet
    // be available
    this.media.bandwidthLimit = {
      audioBandwidthLimit: this.config.audioBandwidthLimit,
      videoBandwidthLimit: this.config.videoBandwidthLimit
    };

    return this.media.createOffer().then((0, _common.tap)(function () {
      return _this6.logger.info('created offer');
    })).then(function () {
      return _this6.spark.internal.locus.createOrJoin(target, (0, _assign2.default)({
        localSdp: _this6.media.offerSdp,
        correlationId: _this6.correlationId
      }, options));
    }).then((0, _common.tap)(function () {
      return _this6.logger.info('sent offer to locus');
    })).then((0, _common.tap)(function () {
      return _this6.logger.info('setting locus');
    })).then(function (locus) {
      return _this6.setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this6.logger.info('successfully set locus');
    })).then(function () {
      var answer = JSON.parse(_this6.mediaConnection.remoteSdp).sdp;
      _this6.logger.info('accepting answer');
      _this6.logger.info('peer state', _this6.media.pc && _this6.media.pc.signalingState);
      if (!_this6.media.ended) {
        return _this6.media.acceptAnswer(answer).then(function () {
          return _this6.logger.info('answer accepted');
        }).catch(function (err) {
          _this6.logger.error('failed to accept answer', err);
          return _promise2.default.reject(err);
        });
      }
      _this6.logger.info('call: already ended, not accepting answer');
      return _promise2.default.resolve();
    });
  },

  /**
   * Alias of {@link Call#reject}
   * @see {@link Call#reject}
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  decline: function decline() {
    return this.reject();
  },

  /**
   * Used by {@link Phone#dial} to initiate an outbound call
   * @instance
   * @memberof Call
   * @param {[type]} invitee
   * @param {[type]} options
   * @private
   * @returns {[type]}
   */
  dial: function dial(invitee, options) {
    var _this7 = this;

    this.locusJoinInFlight = true;
    this.logger.info('call: dialing');

    var target = invitee;

    if (_common.base64.validate(invitee)) {
      // eslint-disable-next-line no-unused-vars
      var parsed = _common.base64.decode(invitee).split('/');
      var resourceType = parsed[3];
      var id = parsed[4];
      if (resourceType === 'PEOPLE') {
        target = id;
      }

      if (resourceType === 'ROOM') {
        if (!(0, _get3.default)(this, 'config.enableExperimentalGroupCallingSupport')) {
          throw new Error('Group calling is not enabled. Please enable config.phone.enableExperimentalGroupCallingSupport');
        }

        target = {
          url: this.spark.internal.device.services.conversationServiceUrl + '/conversations/' + id + '/locus'
        };
      }
    }

    // Note: mercury.connect() will call device.register() if needed. We're not
    // using phone.register() here because it guarantees a device refresh, which
    // is probably unnecessary.
    this.spark.internal.mercury.connect().then(function () {
      return _this7.createOrJoinLocus(target, options);
    }).then((0, _common.tap)(function () {
      return _this7.logger.info('call: dialed');
    })).catch(function (reason) {
      _this7.trigger('error', reason);
    }).then(function () {
      _this7.locusJoinInFlight = false;
    });

    return this;
  },


  /**
   * Returns a {@link Readable} that emits {@link Call#media.pc}'s
   * {@link RTCStatsReport} every second.
   * @instance
   * @memberof Call
   * @returns {StatsStream}
   */
  getRawStatsStream: function getRawStatsStream() {
    return new _stream2.default(this.media.pc);
  },


  /**
   * Returns a {@link StatsStream} piped through a {@link StatsFilter}
   * @instance
   * @memberof Call
   * @returns {Readable}
   */
  getStatsStream: function getStatsStream() {
    return this.getRawStatsStream().pipe(new _filter2.default());
  },


  /**
   * Disconnects the active call. Applies to both incoming and outgoing calls.
   * This method may be invoked in any call state and the SDK should take care
   * to tear down the call and free up all resources regardless of the state.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  hangup: function hangup() {
    var _this8 = this;

    // Note: not a @oneFlight because this function must call itself
    if (this.direction === 'in' && !this.joinedOnThisDevice) {
      return this.reject();
    }

    this.logger.info('call: hanging up');

    this.media.stop();

    if (this.locusJoinInFlight) {
      this.logger.info('call: locus join in flight, waiting for rest call to complete before hanging up');
      return this.when('change:locusJoinInFlight').then(function () {
        return _this8.hangup();
      });
    }

    if (!this.locus) {
      return this.cleanup().then(function () {
        return _this8.logger.info('call: hang up complete, call never created');
      });
    }

    return this.leave();
  },


  /**
   * Initializer
   * @instance
   * @memberof Call
   * @private
   * @param {Object} attrs
   * @param {Object} options
   * @returns {undefined}
   */
  initialize: function initialize() {
    var _this9 = this;

    for (var _len = arguments.length, initArgs = Array(_len), _key = 0; _key < _len; _key++) {
      initArgs[_key] = arguments[_key];
    }

    (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.initialize, this, initArgs);

    this.on('change:activeParticipantsCount', function () {
      return _this9.onChangeActiveParticipantsCount.apply(_this9, arguments);
    });
    // This handler is untested because there's no way to provoke it. It's
    // probably actually only relevant for group calls.
    this.on('change:isActive', function () {
      return _this9.onChangeIsActive.apply(_this9, arguments);
    });
    this.on('change:localMediaStream', function () {
      return _this9.onChangeLocalMediaStream.apply(_this9, arguments);
    });
    // Reminder: this is not a derived property so that we can reassign the
    // stream midcall
    this.on('change:media.localMediaStream', function () {
      _this9.localMediaStream = _this9.media.localMediaStream;
    });
    this.on('change:remoteMember', function () {
      return _this9.onChangeRemoteMember.apply(_this9, arguments);
    });
    ['localMediaStream', 'remoteAudioMuted', 'remoteMediaStream', 'remoteVideoMuted', 'localScreenShare'].forEach(function (key) {
      _this9.on('change:' + key, function () {
        return _this9.trigger(key + ':change');
      });
    });
    this.on('replaced', function () {
      return _this9.cleanup();
    });

    this.listenTo(this.memberships, 'add', function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _this9.trigger.apply(_this9, ['memberships:add'].concat(args));
    });
    this.listenTo(this.memberships, 'change', function () {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return _this9.trigger.apply(_this9, ['membership:change'].concat(args));
    });
    this.listenTo(this.memberships, 'change:audioMuted', function () {
      return _this9.onMembershipsAudioMuted.apply(_this9, arguments);
    });
    this.listenTo(this.memberships, 'change:state', function () {
      return _this9.onMembershipsChangeState.apply(_this9, arguments);
    });
    this.listenTo(this.memberships, 'change:videoMuted', function () {
      return _this9.onMembershipsVideoMuted.apply(_this9, arguments);
    });
    this.listenTo(this.memberships, 'remove', function () {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return _this9.trigger.apply(_this9, ['memberships:remove'].concat(args));
    });

    this.listenTo(this.spark.internal.mercury, 'event:locus', function (event) {
      return _this9.onLocusEvent(event);
    });
    this.listenTo(this.spark.internal.mercury, 'event:locus.difference', function (event) {
      return _this9.onLocusEvent(event);
    });

    this.listenTo(this.media, 'error', function (error) {
      return _this9.trigger('error', error);
    });
    this.listenTo(this.media, 'internalTrackUpdate', function () {
      _this9.trigger('remoteMediaStream:change');
    });
    this.listenTo(this.media, 'negotiationneeded', function () {
      return _this9.onMediaNegotiationNeeded.apply(_this9, arguments);
    });

    if (this.locus) {
      this.internalCallId = (0, _stateParsers.makeInternalCallId)(this.locus);
    } else {
      this.once('change:locus', function () {
        _this9.internalCallId = (0, _stateParsers.makeInternalCallId)(_this9.locus);
      });
    }

    this.memberships.listenToAndRun(this, 'change:locus', function () {
      if (_this9.locus && _this9.locus.participants) {
        // Reminder: we're parsing here instead of CallMembership(s) so that we
        // can avoid making those classes spark aware and therefore keep them a
        // lot simpler
        _this9.memberships.set((0, _stateParsers.participantsToCallMemberships)(_this9.spark, _this9.locus));
        _this9.me = _this9.memberships.find(function (m) {
          return m.isSelf;
        });
      }
    });

    if (this.config.enableExperimentalGroupCallingSupport) {
      this.on('inactive', function () {
        return _this9.hangup();
      });
      this.on('inactive', function () {
        return _this9.cleanup();
      });

      this.on('change:state', function () {
        process.nextTick(function () {
          return _this9.trigger(_this9.state);
        });
      });
      this.on = (0, _wrap3.default)(this.on, function (fn, eventName) {
        for (var _len5 = arguments.length, rest = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
          rest[_key5 - 2] = arguments[_key5];
        }

        if (deprecatedCallEventNames.includes(eventName)) {
          throw new Error('The "' + eventName + '" event is no longer valid with "enableExperimentalGroupCallingSupport===true"');
        }

        return (0, _apply2.default)(fn, _this9, [eventName].concat(rest));
      });
    } else {
      this.on('disconnected', function () {
        return _this9.hangup();
      });
      this.on('disconnected', function () {
        return _this9.cleanup();
      });

      this.on('change:status', function () {
        process.nextTick(function () {
          return _this9.trigger(_this9.status);
        });
      });
    }
  },

  /**
   * Does the internal work necessary to end a call while allowing hangup() to
   * call itself without getting stuck in promise change because of oneFlight
   * The name of this function is temporary to address the no-underscore-dangle
   * rule. A future commit in this PR will rename all of the
   * reject/end/hangup/finish functions to be more meaningful and not just be
   * synonyms the same word.
   * @private
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  leave: function leave() {
    var _this10 = this;

    this.logger.info('leave: attempting to leave locus');
    var status = (0, _get3.default)(this, this.config.enableExperimentalGroupCallingSupport ? 'me.state' : 'status');
    if (status === 'disconnected') {
      this.logger.info('already hung up, not calling locus again');
      return _promise2.default.resolve();
    }

    if (status === 'declined') {
      this.logger.info('call was declined, not leaving again');
      return _promise2.default.resolve();
    }

    if (status !== 'connected') {
      this.logger.info('call is neither connected, disconnected, or declined, declining instead of leaving');
      return this.decline();
    }

    this.logger.info('leave: leaving locus');
    return this.spark.internal.locus.leave(this.locus).catch(function (err) {
      _this10.logger.error('leave: locus leave error: ', err.stack || err.toString());
      return _promise2.default.reject(err);
    }).then((0, _common.tap)(function () {
      return _this10.logger.info('leave ' + _this10.locus.id + ': finished leaving via locus');
    })).then((0, _common.tap)(function () {
      return _this10.logger.info('leave ' + _this10.locus.id + ': setting locus');
    })).then(function (locus) {
      return _this10.setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this10.logger.info('leave ' + _this10.locus.id + ': finished setting locus');
    }))
    // Note: not stopping event-listening here; that'll happening
    // automatically when `disconnected` fires.
    .then((0, _common.tap)(function () {
      return _this10.logger.info('call: hung up');
    }));
  },


  /**
   * Handles an incoming mercury event if relevant to this call.
   * @instance
   * @memberof Call
   * @param {Types~MercuryEvent} event
   * @private
   * @returns {undefined}
   */
  onLocusEvent: function onLocusEvent(event) {
    var _this11 = this;

    var devices = (0, _get3.default)(event, 'data.locus.self.devices');
    var device = devices && (0, _find3.default)(devices, function (item) {
      return item.url === _this11.spark.internal.device.url;
    });

    var internalCallId = this.locus && (0, _stateParsers.makeInternalCallId)(event.data.locus);
    if (internalCallId === this.internalCallId || device && this.correlationId === device.correlationId) {
      this.logger.info('locus event: ' + event.data.eventType);
      this.setLocus(event.data.locus);
    }

    if (event.data.locus.replaces) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(event.data.locus.replaces), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var replaced = _step.value;

          if (replaced.locusUrl + '_' + replaced.lastActive === this.internalCallId) {
            this.setLocus(event.data.locus);
            this.logger.info('locus replacement event: ' + event.data.eventType, this.locusUrl, '->', event.data.locus.url);
            return;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  },


  /**
   * Event handler
   * @instance
   * @memberof Call
   * @private
   * @returns {undefined}
   */
  onMembershipsAudioMuted: function onMembershipsAudioMuted() {
    if (this.remoteMember) {
      this.remoteAudioMuted = this.remoteMember.audioMuted;
    }
  },


  /**
   * Event handler
   * @instance
   * @memberof Call
   * @private
   * @returns {undefined}
   */
  onMembershipsVideoMuted: function onMembershipsVideoMuted() {
    if (this.remoteMember) {
      this.remoteVideoMuted = this.remoteMember.videoMuted;
    }
  },


  /**
   * Event handler
   * @instance
   * @memberof Call
   * @private
   * @returns {undefined}
   */
  onChangeRemoteMember: function onChangeRemoteMember() {
    if (this.remoteMember) {
      this.remoteAudioMuted = this.remoteMember.audioMuted;
      this.remoteVideoMuted = this.remoteMember.videoMuted;
    } else {
      this.remoteAudioMuted = undefined;
      this.remoteVideoMuted = undefined;
    }
  },


  /**
   * Event handler
   * @instance
   * @memberof Call
   * @param {Membership} model
   * @private
   * @returns {undefined}
   */
  onMembershipsChangeState: function onMembershipsChangeState(model) {
    this.activeParticipantsCount = this.memberships.filter(function (m) {
      return m.state === 'connected';
    }).length;

    this.trigger('membership:' + model.state, model);
  },

  /**
   * Event handler
   * @instance
   * @memberof Call
   * @private
   * @returns {undefined}
   */
  onMediaNegotiationNeeded: function onMediaNegotiationNeeded() {
    var _this12 = this;

    this.media.createOffer().then(function () {
      return _this12.updateMedia({
        sdp: _this12.media.offerSdp,
        mediaId: _this12.mediaId
      });
    }).then(function () {
      return _this12.pollForExpectedLocusAndSdp();
    }).then(function () {
      var _JSON$parse = JSON.parse(_this12.mediaConnection.remoteSdp),
          sdp = _JSON$parse.sdp;

      return _this12.media.acceptAnswer(sdp);
    }).catch(function (reason) {
      return _this12.emit('error', reason);
    });
  },


  /**
   * Event handler
   * @instance
   * @memberof Call
   * @private
   * @returns {undefined}
   */
  onChangeLocalMediaStream: function onChangeLocalMediaStream() {
    var _this13 = this;

    if (this.localMediaStream && this.localMediaStream !== this.media.localMediaStream) {
      ['audio', 'video'].forEach(function (kind) {
        // eslint-disable-next-line max-nested-callbacks
        var track = _this13.localMediaStream.getTracks().find(function (t) {
          return t.kind === kind;
        });
        if (track) {
          _this13.media.setMedia(kind, (0, _boolToStatus2.default)(track.enabled, _this13['receiving' + capitalize[kind]]), track);
        } else {
          _this13.media.setMedia(kind, (0, _boolToStatus2.default)(false, _this13['receiving' + capitalize[kind]]));
        }
      });
      this.localMediaStream = this.media.localMediaStream;
    }
  },


  /**
   * Event handler
   * @instance
   * @memberof Call
   * @private
   * @returns {undefined}
   */
  onChangeIsActive: function onChangeIsActive() {
    if (!this.isActive) {
      if (this.joinedOnThisDevice) {
        this.logger.info('call: hanging up due to locus going inactive');
        this.hangup();
      }
    }
  },


  /**
   * Event handler
   * @instance
   * @memberof Call
   * @private
   * @returns {undefined}
   */
  onChangeActiveParticipantsCount: function onChangeActiveParticipantsCount() {
    if (!this.joinedOnThisDevice) {
      return;
    }

    if (this.activeParticipantsCount !== 1) {
      return;
    }

    if (this.isCall && !this.config.hangupIfLastActive.call) {
      return;
    }

    if (!this.isCall && !this.config.hangupIfLastActive.meeting) {
      return;
    }

    var previousLocus = this.previousAttributes().locus;
    if (!previousLocus) {
      return;
    }

    if ((0, _stateParsers.activeParticipants)(previousLocus).length > 1) {
      this.logger.info('call: hanging up due to last participant in call');
      this.hangup();
    }
  },

  /**
   * The response to a PUT to LOCUS/media may not be fully up-to-date when we
   * receive it. This method polls locus until we get a locus with the status
   * properties we expect (or three errors occur)
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise<Types~Locus>}
   */
  pollForExpectedLocusAndSdp: function pollForExpectedLocusAndSdp() {
    var _this14 = this;

    return new _promise2.default(function (resolve, reject) {
      var offer = (0, _sdpTransform.parse)(_this14.media.offerSdp);

      var audioOfferDir = getMediaDirectionFromSDP('audio', offer);
      var videoOfferDir = getMediaDirectionFromSDP('video', offer);
      var screenOfferDir = getMediaDirectionFromSDP('screen', offer);

      var self = _this14;
      var count = 0;
      var validate = function validate() {
        count += 1;
        try {
          _this14.logger.info('iteration ' + count + ': checking if current locus has the expected audio and video directions');
          if (isExpectedDirection(JSON.parse(_this14.mediaConnection.remoteSdp).sdp)) {
            _this14.logger.info('iteration ' + count + ': the current locus sdp has the expected audio and video directions');
            try {
              _this14.validateLocusMediaState(_this14.locus);
              _this14.logger.info('iteration ' + count + ': the current locus has the expected audio and video directions; not syncing');
              resolve();
              return;
            } catch (err) {
              _this14.logger.info('iteration ' + count + ': the current locus does not have the expected audio and video directions; syncing');
            }
          } else {
            _this14.logger.info('iteration ' + count + ': the current locus sdp does not have the expected audio and video directions; syncing');
          }

          if (count > 4) {
            reject(new Error('After ' + count + ' attempts polling locus'));
            return;
          }

          setTimeout(function () {
            return _this14.spark.internal.locus.sync(_this14.locus).then(function (locus) {
              return _this14.setLocus(locus);
            }).then(validate).catch(reject);
          }, 1000 * Math.pow(2, count));
        } catch (err) {
          reject(err);
        }
      };

      validate();
      /**
       * Determine if the incoming sdp has the expected media directions
       * @private
       * @param {string} sdp
       * @returns {boolean}
       */
      function isExpectedDirection(sdp) {
        var answer = (0, _sdpTransform.parse)(sdp);

        var audioAnswerDir = getMediaDirectionFromSDP('audio', answer);
        var videoAnswerDir = getMediaDirectionFromSDP('video', answer);
        var screenAnswerDir = getMediaDirectionFromSDP('screen', answer);

        var expectedAudioAnswerDir = reverseMediaDirection(audioOfferDir);
        var expectedVideoAnswerDir = reverseMediaDirection(videoOfferDir);
        var expectedScreenAnswerDir = reverseMediaDirection(screenOfferDir);

        self.logger.info('audio: ' + audioOfferDir + ', ' + audioAnswerDir + ', ' + expectedAudioAnswerDir);
        self.logger.info('video: ' + videoOfferDir + ', ' + videoAnswerDir + ', ' + expectedVideoAnswerDir);
        self.logger.info('screen: ' + screenOfferDir + ', ' + screenAnswerDir + ', ' + expectedScreenAnswerDir);

        // eslint-disable-next-line max-len
        return audioAnswerDir === expectedAudioAnswerDir && videoAnswerDir === expectedVideoAnswerDir && screenAnswerDir === expectedScreenAnswerDir;
      }
    });
  },


  /**
   * Tells locus we're done sharing some or all of our screen.
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  releaseFloor: function releaseFloor() {
    var _this15 = this;

    this.logger.info('call: releasing floor grant');
    return _promise2.default.resolve().then((0, _stateParsers.waitForMediaShare)(this)).then(function (mediaShare) {
      return _this15.spark.internal.locus.releaseFloorGrant(_this15.locus, mediaShare);
    });
  },

  /**
   * Rejects an incoming call. Only applies to incoming calls. Invoking this
   * method on an outgoing call is a no-op.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  reject: function reject() {
    var _this16 = this;

    if (this.direction === 'out') {
      return _promise2.default.resolve();
    }

    this.logger.info('call: rejecting');
    /* eslint no-invalid-this: [0] */
    return this.spark.internal.locus.decline(this.locus).then(function (locus) {
      return _this16.setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this16.cleanup();
    })).then((0, _common.tap)(function () {
      return _this16.logger.info('call: rejected');
    }));
  },


  /**
   * Tells locus we'd like to share some or all of our screen.
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  requestFloor: function requestFloor() {
    var _this17 = this;

    this.logger.info('call: requesting floor grant');
    return _promise2.default.resolve().then((0, _stateParsers.waitForMediaShare)(this)).then(function (mediaShare) {
      return _this17.spark.internal.locus.requestFloorGrant(_this17.locus, mediaShare);
    });
  },


  /**
   * Assigns a new locus to this.locus according to locus sequencing rules
   * @instance
   * @memberof Call
   * @param {Types~Locus} incoming
   * @param {boolean} recursing - when true, indicates that this method has
   * called itself and we should fall back to {@link locus.get()} instead of
   * calling {@link locus.sync()}
   * @private
   * @returns {Promise}
   */
  setLocus: function setLocus(incoming) {
    var _this18 = this;

    var recursing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var current = this.locus;
    if (!current) {
      this.locus = incoming;
      return _promise2.default.resolve();
    }
    var action = this.spark.internal.locus.compare(current, incoming);

    switch (action) {
      case _internalPluginLocus.USE_INCOMING:
        this.locus = this.spark.internal.locus.merge(this.locus, incoming);
        if (this.device) {
          this.correlationId = this.device.correlationId;
        }
        break;
      case _internalPluginLocus.FETCH:
        if (recursing) {
          this.logger.info('call: fetching locus according to sequencing algorithm');
          return this.spark.internal.locus.get(current).then(function (locus) {
            return _this18.setLocus(locus, true);
          });
        }

        this.logger.info('call: syncing locus according to sequencing algorithm');

        return this.spark.internal.locus.sync(current).then(function (locus) {
          return _this18.setLocus(locus, true);
        });

      default:
      // do nothing
    }

    return _promise2.default.resolve();
  },


  /**
   * Send DTMF tones to the current call
   * @instance
   * @memberof Call
   * @param {string} tones
   * @returns {Promise}
   */
  sendDtmf: function sendDtmf(tones) {
    if (!this.supportsDtmf) {
      return _promise2.default.reject(new Error('this call does not support dtmf'));
    }

    return this.spark.internal.locus.sendDtmf(this.locus, tones);
  },


  /**
   * Sends feedback about the call to the Cisco Spark cloud
   * @instance
   * @memberof Call
   * @param {FeedbackObject} feedback
   * @returns {Promise}
   */
  sendFeedback: function sendFeedback(feedback) {
    return this.spark.internal.metrics.submit('meetup_call_user_rating', feedback);
  },


  /**
   * Shares a particular application as a second stream in the call
   * @returns {Promise}
   */
  startApplicationShare: function startApplicationShare() {
    var _this19 = this;

    this.logger.info('call: sharing application');
    return new _promise2.default(function (resolve) {
      _this19.media.once('answeraccepted', resolve);
      _this19.media.setMedia('screen', 'sendonly', {
        mediaSource: 'application'
      });
    }).then(function () {
      return _this19.requestFloor();
    });
  },


  /**
   * Shares the whole screen as a second stream in the call
   * @returns {Promise}
   */
  startScreenShare: function startScreenShare() {
    var _this20 = this;

    this.logger.info('call: sharing screen');

    return new _promise2.default(function (resolve) {
      _this20.media.once('answeraccepted', resolve);
      _this20.media.setMedia('screen', 'sendonly', {
        mediaSource: 'screen'
      });
    }).then(function () {
      return _this20.requestFloor();
    });
  },


  /**
   * Start receiving audio
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startReceivingAudio: function startReceivingAudio() {
    return this.changeReceivingMedia('audio', true);
  },


  /**
   * Start receiving video
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startReceivingVideo: function startReceivingVideo() {
    return this.changeReceivingMedia('video', true);
  },


  /**
   * Starts sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingAudio: function startSendingAudio() {
    return this.changeSendingMedia('audio', true);
  },


  /**
   * Starts sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingVideo: function startSendingVideo() {
    return this.changeSendingMedia('video', true);
  },


  /**
   * Stops sharing an application or whole screen media stream
   * @returns {Promise}
   */
  stopScreenShare: function stopScreenShare() {
    var _this21 = this;

    this.logger.info('call: stopping screen/application share');

    return this.releaseFloor().then(function () {
      return new _promise2.default(function (resolve) {
        _this21.media.once('answeraccepted', resolve);
        _this21.media.setMedia('screen', 'inactive');
      });
    });
  },


  /**
   * Stop receiving audio
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopReceivingAudio: function stopReceivingAudio() {
    return this.changeReceivingMedia('audio', false);
  },


  /**
   * Stop receiving video
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopReceivingVideo: function stopReceivingVideo() {
    return this.changeReceivingMedia('video', false);
  },


  /**
   * Stops sending audio to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingAudio: function stopSendingAudio() {
    return this.changeSendingMedia('audio', false);
  },


  /**
   * Stops sending video to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingVideo: function stopSendingVideo() {
    return this.changeSendingMedia('video', false);
  },


  /**
   * Replaces the current mediaStrem with one with identical constraints, except
   * for an opposite facing mode. If the current facing mode cannot be
   * determined, the facing mode will be set to `user`. If the call is audio
   * only, this function will throw.
   * @instance
   * @memberof Call
   * @returns {undefined}
   */
  toggleFacingMode: function toggleFacingMode() {
    var _this22 = this;

    if (!this.sendingVideo) {
      throw new Error('Cannot toggle facingMode if we\'re not sending video');
    }

    if (this.facingMode !== 'user' && this.facingMode !== 'environment') {
      throw new Error('Cannot determine current facing mode; specify a new localMediaStream to change cameras');
    }

    var constraint = {
      facingMode: {
        ideal: this.facingMode === 'user' ? 'environment' : 'user'
      }
    };

    this.media.setMedia('video', (0, _boolToStatus2.default)(true, this.sendingVideo), constraint);
    return new _promise2.default(function (resolve) {
      _this22.media.once('change:answerSdp', function () {
        _this22.facingMode = constraint.facingMode.ideal;
        resolve();
      });
    });
  },


  /**
   * Toggles receiving audio from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingAudio: function toggleReceivingAudio() {
    return this.receivingAudio ? this.stopReceivingAudio() : this.startReceivingAudio();
  },


  /**
   * Toggles receiving video from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingVideo: function toggleReceivingVideo() {
    return this.receivingVideo ? this.stopReceivingVideo() : this.startReceivingVideo();
  },


  /**
   * Toggles sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingAudio: function toggleSendingAudio() {
    return this.sendingAudio ? this.stopSendingAudio() : this.startSendingAudio();
  },


  /**
   * Toggles sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingVideo: function toggleSendingVideo() {
    return this.sendingVideo ? this.stopSendingVideo() : this.startSendingVideo();
  },


  /**
   * Changes the status of media
   * @instance
   * @memberof Call
   * @param {Object} payload
   * @private
   * @returns {Promise}
   */
  updateMedia: function updateMedia(payload) {
    var _this23 = this;

    if (payload.sdp && !payload.sdp.includes('b=')) {
      throw new Error('outbound sdp should always have a \'b=\' line');
    }
    return this.spark.internal.locus.updateMedia(this.locus, payload).then(function (locus) {
      return _this23.setLocus(locus);
    });
  },

  /**
   * Tells locus we've got a new media direction
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  updateMuteToggles: function updateMuteToggles() {
    var _this24 = this;

    return this.updateMedia({
      sdp: this.media.offerSdp,
      mediaId: this.mediaId,
      audioMuted: didChange('audio', this.media.offerSdp, this.media.answerSdp) ? this.sendingAudio : !this.sendingAudio,
      videoMuted: didChange('video', this.media.offerSdp, this.media.answerSdp) ? this.sendingVideo : !this.sendingVideo
    }).then(function () {
      return _this24.waitForExpectedLocus();
    });
  },


  /**
   * Checks that this.locus has the expected state
   * @instance
   * @memberof Call
   * @param {Types~Locus} locus
   * @private
   * @returns {Promise}
   */
  validateLocusMediaState: function validateLocusMediaState(locus) {
    var locusAudio = locus.self.status.audioStatus.toLowerCase();
    var mediaAudio = this.media.audioDirection;

    if (locusAudio !== mediaAudio) {
      this.logger.warn('locus: expected audio ' + locusAudio + ' (locus) to equal ' + mediaAudio + ' (local media)');
      throw new Error('locus.self.status.audioStatus indicates the received DTO is out of date');
    }

    var locusVideo = locus.self.status.videoStatus.toLowerCase();
    var mediaVideo = this.media.videoDirection;
    if (locusVideo !== mediaVideo) {
      this.logger.warn('locus: expected video ' + locusVideo + ' (locus) to equal ' + mediaVideo + ' (local media)');
      throw new Error('locus.self.status.videoStatus indicates the received DTO is out of date');
    }

    return locus;
  },


  /**
   * Waits until this.locus describes the expected state
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  waitForExpectedLocus: function waitForExpectedLocus() {
    var _this25 = this;

    return new _promise2.default(function (resolve) {
      var listener = function listener() {
        try {
          _this25.validateLocusMediaState(_this25.locus);
          _this25.off('change:locus', listener);
          resolve();
        } catch (err) {
          _this25.logger.warn('locus: current locus not in expected state; waiting for next locus');
        }
      };
      _this25.on('change:locus', listener);
      listener();
    });
  },
  version: '1.32.6'
}, (_applyDecoratedDescriptor(_obj, 'acknowledge', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'acknowledge'), _obj), _applyDecoratedDescriptor(_obj, 'answer', [_common.oneFlight, _dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'answer'), _obj), _applyDecoratedDescriptor(_obj, 'createOrJoinLocus', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'createOrJoinLocus'), _obj), _applyDecoratedDescriptor(_obj, 'decline', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'decline'), _obj), _applyDecoratedDescriptor(_obj, 'dial', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'dial'), _obj), _applyDecoratedDescriptor(_obj, 'leave', [_common.oneFlight, _dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'leave'), _obj), _applyDecoratedDescriptor(_obj, 'onMediaNegotiationNeeded', [_dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'onMediaNegotiationNeeded'), _obj), _applyDecoratedDescriptor(_obj, 'pollForExpectedLocusAndSdp', [_common.retry], (0, _getOwnPropertyDescriptor2.default)(_obj, 'pollForExpectedLocusAndSdp'), _obj), _applyDecoratedDescriptor(_obj, 'reject', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'reject'), _obj), _applyDecoratedDescriptor(_obj, 'updateMuteToggles', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'updateMuteToggles'), _obj)), _obj)));

Call.make = function make(attrs, options) {
  return new Call(attrs, options);
};

exports.default = Call;


}).call(this,require('_process'))
},{"./bool-to-status":792,"./call-memberships":794,"./state-parsers":800,"./stats/filter":801,"./stats/stream":802,"@ciscospark/common":731,"@ciscospark/internal-plugin-locus":754,"@ciscospark/media-engine-webrtc":43,"@ciscospark/spark-core":804,"_process":1743,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"lodash-decorators":1349,"lodash/defaults":1618,"lodash/find":1627,"lodash/get":1636,"lodash/wrap":1715,"sdp-transform":865,"uuid":868}],796:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _ampersandCollection = require('ampersand-collection');

var _ampersandCollection2 = _interopRequireDefault(_ampersandCollection);

var _call = require('./call');

var _call2 = _interopRequireDefault(_call);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var Calls = _ampersandCollection2.default.extend({
  model: _call2.default,

  mainIndex: 'internalCallId',

  indexes: ['correlationId'],

  /**
   * Initializer
   * @private
   * @param {Object} attrs
   * @param {Object} options
   * @returns {undefined}
   */
  initialize: function initialize() {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_ampersandCollection2.default.prototype.initialize, this, args);

    this.on('add', function (call) {
      _this.listenTo(call, 'change:state', function () {
        if (call.config.enableExperimentalGroupCallingSupport) {
          if (call.state === 'inactive') {
            _this.remove(call);
          }
        } else if (call.status === 'disconnected') {
          _this.remove(call);
        }
      });
    });
  },


  /**
   * Indicates if this collection already contains the specified locus
   * @param {Types~Locus} locus
   * @returns {boolean}
   */
  has: function has(locus) {
    var found = this.get(locus.url + '_' + locus.fullState.lastActive);
    if (found) {
      return true;
    }

    if (locus.replaces) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(locus.replaces), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var replaced = _step.value;

          if (this.get(replaced.locusUrl + '_' + replaced.lastActive)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    return false;
  }
});

exports.default = Calls;


},{"./call":795,"ampersand-collection":838,"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/reflect/apply":695}],797:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * @typedef {Object} PhoneConfig
 * @property {number} [audioBandwidthLimit=64000]
 * @property {number} [videoBandwidthLimit=1000000]
 * @property {boolean} [enableExperimentalGroupCallingSupport=false] - Group
 * calling support should work, but necessarily introduces some breaking changes
 * to the API. In order to get feedback, we're keeping the API unchanged by
 * default and requiring folks to opt-in to these breakages. As these changes
 * evolve, you may see some breaking changes that don't necessarily follow
 * semantic versioning. When we're ready to drop the "experimental" moniker,
 * we'll release an official SemVer Major bump.
 * @example
 * {
 *   audioBandwidthLimit: 64000,
 *   videoBandwidthLimit: 1000000,
 *   enableExperimentalGroupCallingSupport: false,
 *   hangupIfLastActive: {
 *     call: true,
 *     meeting: false
 *   }
 * }
 */

/**
 * @typedef {Object} HangupBehavior
 * @memberof PhoneConfig
 * @property {boolean} [call=true] -  Indicates if a call (i.e. two-party
 * audio-video experience) should be ended automatically if the current user is
 * the last active member of the experience.
 * @property {boolean} [meeting=false] - Indicates if a meeting (i.e.
 * multi-party audio-video experience) should be ended automatically if the
 * current user is the last active member of the experience
 */

exports.default = {
  phone: {
    audioBandwidthLimit: 64000,
    videoBandwidthLimit: 1000000,
    enableExperimentalGroupCallingSupport: false,
    hangupIfLastActive: {
      call: true,
      meeting: false
    }
  }
};


},{}],798:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatsStream = exports.StatsFilter = exports.remoteParticipant = exports.boolToStatus = exports.Call = exports.phoneEvents = undefined;

var _phone = require('./phone');

Object.defineProperty(exports, 'phoneEvents', {
  enumerable: true,
  get: function get() {
    return _phone.events;
  }
});

var _call = require('./call');

Object.defineProperty(exports, 'Call', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_call).default;
  }
});

var _boolToStatus = require('./bool-to-status');

Object.defineProperty(exports, 'boolToStatus', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_boolToStatus).default;
  }
});

var _stateParsers = require('./state-parsers');

Object.defineProperty(exports, 'remoteParticipant', {
  enumerable: true,
  get: function get() {
    return _stateParsers.remoteParticipant;
  }
});

var _filter = require('./stats/filter');

Object.defineProperty(exports, 'StatsFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_filter).default;
  }
});

var _stream = require('./stats/stream');

Object.defineProperty(exports, 'StatsStream', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_stream).default;
  }
});

require('@ciscospark/internal-plugin-locus');

require('@ciscospark/internal-plugin-metrics');

require('@ciscospark/plugin-people');

var _sparkCore = require('@ciscospark/spark-core');

var _phone2 = _interopRequireDefault(_phone);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

exports.default = _phone2.default;


(0, _sparkCore.registerPlugin)('phone', _phone2.default, { config: _config2.default });


},{"./bool-to-status":792,"./call":795,"./config":797,"./phone":799,"./state-parsers":800,"./stats/filter":801,"./stats/stream":802,"@ciscospark/internal-plugin-locus":754,"@ciscospark/internal-plugin-metrics":767,"@ciscospark/plugin-people":789,"@ciscospark/spark-core":804}],799:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.events = undefined;

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _sparkCore = require('@ciscospark/spark-core');

var _mediaEngineWebrtc = require('@ciscospark/media-engine-webrtc');

var _mediaEngineWebrtc2 = _interopRequireDefault(_mediaEngineWebrtc);

var _call = require('./call');

var _call2 = _interopRequireDefault(_call);

var _stateParsers = require('./state-parsers');

var _calls = require('./calls');

var _calls2 = _interopRequireDefault(_calls);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var events = exports.events = {
  CALL_CREATED: 'call:created',
  CALL_INCOMING: 'call:incoming'
};

/**
 * Call Created Event
 *
 * Emitted when a call begins outside of the sdk
 *
 * @event call:created
 * @instance
 * @memberof Phone
 * @type {Object}
 * @property {Call} call The created call
 */

/**
 * Incoming Call Event
 *
 * Emitted when a call begins and when {@link Phone#register} is invoked and
 * there are active calls.
 *
 * @event call:incoming
 * @instance
 * @memberof Phone
 * @type {Object}
 * @property {Call} call The incoming call
 */

/**
 * @class
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var Phone = _sparkCore.SparkPlugin.extend({
  collections: {
    emittedCalls: _calls2.default
  },

  session: {
    /**
     * Indicates whether or not the WebSocket is connected
     * @instance
     * @memberof Phone
     * @member {Boolean}
     * @readonly
     */
    connected: {
      default: false,
      type: 'boolean'
    },
    /**
     * Specifies the facingMode to be used by {@link Phone#dial} and
     * {@link Call#answer} when no constraint is specified. Does not apply if
     * - a {@link MediaStream} is passed to {@link Phone#dial} or
     * {@link Call#answer}
     * - constraints are passed to {@link Phone#dial} or  {@link Call#answer}
     * The only valid values are `user` and `environment`. For any other values,
     * you must provide your own constrains or {@link MediaStream}
     * @default `user`
     * @instance
     * @memberof Phone
     * @type {string}
     */
    defaultFacingMode: {
      default: 'user',
      type: 'string',
      values: ['user', 'environment']
    },
    /**
     * indicates whether or not the client is registered with the Cisco Spark
     * cloud
     * @instance
     * @memberof Phone
     * @member {Boolean}
     * @readonly
     */
    registered: {
      default: false,
      type: 'boolean'
    }
  },

  namespace: 'phone',

  /**
   * Indicates if the current browser appears to support webrtc calling. Note:
   * at this time, there's no way to determine if the current browser supports
   * h264 without asking for camera permissions
   * @instance
   * @memberof Phone
   * @returns {Promise<Boolean>}
   */
  isCallingSupported: function isCallingSupported() {
    return new _promise2.default(function (resolve) {
      // I'm not thrilled by this, but detectrtc breaks the global namespace in
      // a way that screws up the browserOnly/nodeOnly test helpers.
      // eslint-disable-next-line global-require
      var DetectRTC = require('detectrtc');
      resolve(DetectRTC.isWebRTCSupported);
    });
  },


  /**
   * Registers the client with the Cisco Spark cloud and starts listening for
   * WebSocket events.
   *
   * Subsequent calls refresh the device registration.
   * @instance
   * @memberof Phone
   * @returns {Promise}
   */
  register: function register() {
    var _this = this;

    // Ideally, we could call spark.refresh via spark-core, but it doesn't know
    // about the wdm plugin, and all of the leaky abstractions I can think of
    // seem risky.

    return this.spark.internal.device.refresh().then(function () {
      if (_this.connected) {
        return _promise2.default.resolve();
      }
      return _promise2.default.all([_this.emittedCalls.reset(), _this.spark.internal.mercury.when('event:mercury.buffer_state').then(function (_ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 1),
            message = _ref2[0];

        if (message.data.bufferState.locus === 'UNKNOWN') {
          return _this.listActiveCalls();
        }
        return _promise2.default.resolve();
      }), _this.spark.internal.mercury.connect()]);
    });
  },


  /**
   * Disconnects from WebSocket and unregisters from the Cisco Spark cloud.
   *
   * Subsequent calls will be a noop.
   * @instance
   * @memberof Phone
   * @returns {Promise}
   */
  deregister: function deregister() {
    var _this2 = this;

    return this.spark.internal.mercury.disconnect().then(function () {
      return _this2.spark.internal.device.unregister();
    });
  },


  /**
   * Create a MediaStream to be used for video preview.
   *
   * Note: You must explicitly pass the resultant stream to {@link Call#answer()}
   * or {@link Phone#dial()}
   * @instance
   * @memberof Phone
   * @param {Object|MediaStreamConstraints} options
   * @param {MediaStreamConstraints} options.constraints
   * @returns {Promise<MediaStream>}
   */
  createLocalMediaStream: function createLocalMediaStream() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var constraints = options.constraints || options;
    (0, _defaults3.default)(constraints, {
      audio: true,
      video: true
    });

    return _mediaEngineWebrtc2.default.getUserMedia(constraints);
  },


  /**
   * Fetches a list of all of the current user's active calls
   * @instance
   * @memberOf Phone
   * @returns {Promise<Call[]>}
   */
  listActiveCalls: function listActiveCalls() {
    var _this3 = this;

    return this.spark.internal.locus.list().then(function (loci) {
      // emittedCalls is a collection, convert to array
      var calls = _this3.emittedCalls.map(function (e) {
        return e;
      });
      if (!loci) {
        return calls;
      }
      loci.forEach(function (locus) {
        if (!_this3.emittedCalls.has(locus)) {
          var callItem = _call2.default.make({ locus: locus, parent: _this3.spark });
          calls.push(callItem);
          _this3.emittedCalls.add(callItem);
          _this3._triggerCallEvents(callItem, locus);
        }
      });
      return calls;
    });
  },


  /**
   * Initializer
   * @instance
   * @memberof Phone
   * @param {Object} attrs
   * @param {Object} options
   * @private
   * @returns {undefined}
   */
  initialize: function initialize() {
    var _this4 = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.initialize, this, args);

    this.listenTo(this.spark.internal.mercury, 'event:locus', function (event) {
      return _this4.onLocusEvent(event);
    });

    // Note: we need to manually wire up change:connected because derived props
    // can't read through this.parent
    this.listenTo(this.spark.internal.mercury, 'change:connected', function () {
      _this4.connected = _this4.spark.internal.mercury.connected;
      _this4.registered = !!_this4.spark.internal.device.url && _this4.connected;
    });

    // Note: we need to manually wire up change:url because derived props
    // can't read through this.parent
    this.listenTo(this.spark.internal.device, 'change:url', function () {
      _this4.registered = !!_this4.spark.internal.device.url && _this4.connected;
    });
  },


  /**
   * Determines if the {@link call:incoming} event should be emitted for the
   * specified {@link Types~MercuryEvent}
   * @emits call:incoming
   * @instance
   * @memberof Phone
   * @param {Types~MercuryEvent} event
   * @private
   * @returns {undefined}
   */
  onLocusEvent: function onLocusEvent(event) {
    // We only want to handle calls we are not aware of
    if (this.emittedCalls.has(event.data.locus)) {
      return;
    }

    // Create call object and store in emittedCalls
    var call = _call2.default.make({
      locus: event.data.locus
    }, {
      parent: this.spark
    });
    this.emittedCalls.add(call);

    // Trigger events as necessary
    this._triggerCallEvents(call, event.data.locus);
  },


  /**
   * Place a call to the specified dialString. A dial string may be an email
   * address or sip uri.
   * If you set {@link config.phone.enableExperimentalGroupCallingSupport} to
   * `true`, the dialString may also be a room id.
   * @instance
   * @memberof Phone
   * @param {string} dialString
   * @param {Object} options
   * @param {MediaStreamConstraints} options.constraints
   * @param {MediaStream} options.localMediaStream if no stream is specified, a
   * new one will be created based on options.constraints
   * @returns {Call}
   */
  dial: function dial(dialString, options) {
    var call = _call2.default.make({}, { parent: this.spark });

    call.dial(dialString, options);
    this.emittedCalls.add(call);
    return call;
  },


  /**
   * Triggers call events for a given call/locus
   * @param {Call} call
   * @param {Types~Locus} locus
   * @returns {undefined}
   */
  _triggerCallEvents: function _triggerCallEvents(call, locus) {
    this.trigger(events.CALL_CREATED, call);

    if ((0, _stateParsers.shouldRing)(locus)) {
      if ((0, _stateParsers.isCall)(locus) || !(0, _stateParsers.isCall)(locus) && (0, _get3.default)(this, 'config.enableExperimentalGroupCallingSupport')) {
        this.trigger(events.CALL_INCOMING, call);
      }
    }
  },
  version: '1.32.6'
});

exports.default = Phone;


},{"./call":795,"./calls":796,"./state-parsers":800,"@ciscospark/media-engine-webrtc":43,"@ciscospark/spark-core":804,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/slicedToArray":709,"detectrtc":1308,"lodash/defaults":1618,"lodash/get":1636}],800:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _filter2 = require('lodash/filter');

var _filter3 = _interopRequireDefault(_filter2);

exports.activeParticipants = activeParticipants;
exports.direction = direction;
exports.waitForMediaShare = waitForMediaShare;
exports.isActive = isActive;
exports.isCall = isCall;
exports.joined = joined;
exports.joinedOnThisDevice = joinedOnThisDevice;
exports.participantsToCallMemberships = participantsToCallMemberships;
exports.participantToCallMembership = participantToCallMembership;
exports.participantStateToCallMembershipState = participantStateToCallMembershipState;
exports.makeInternalCallId = makeInternalCallId;
exports.mediaDirection = mediaDirection;
exports.participantIsJoined = participantIsJoined;
exports.remoteParticipant = remoteParticipant;
exports.remoteParticipants = remoteParticipants;
exports.remoteAudioMuted = remoteAudioMuted;
exports.remoteVideoMuted = remoteVideoMuted;
exports.shouldRing = shouldRing;
exports.getState = getState;
exports.getStatus = getStatus;
exports.getThisDevice = getThisDevice;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Finds the Locus's active participants
 * @param {Types~Locus} locus
 * @private
 * @returns {Array<Types~LocusParticipant>}
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

function activeParticipants(locus) {
  return (0, _filter3.default)(locus.participants, { state: 'JOINED' });
}

/**
 * Indicates if the locus was activated form this device
 * @param {Types~Locus} locus
 * @private
 * @returns {string} unknown|in|out
 */
function direction(locus) {
  if (!locus || !locus.self) {
    return 'unknown';
  }
  return locus.self.isCreator ? 'out' : 'in';
}

/**
 * Finds the media share share for the call, potentially setting up event
 * listeners to wait for a new Locus
 * @param {Call} call
 * @private
 * @returns {Promise<Types~MediaShare>}
 */
function waitForMediaShare(call) {
  return function curriedFindShare() {
    var promise = new _promise2.default(function (resolve, reject) {
      /**
       * Searches the call's current locus for the screen share entry in media
       * shares
       *
       * @returns {undefined}
       */
      function findShare() {
        try {
          call.logger.info('checking for media share');
          var mediaShare = call.locus.mediaShares.find(function (share) {
            return share.name === 'content';
          });
          if (!mediaShare) {
            call.logger.info('did not find media share, waiting for next locus change');
            call.once('change:locus', findShare);
            return;
          }

          call.logger.info('found media share');
          resolve(mediaShare);
        } catch (err) {
          call.logger.error('something unexpected happened');
          call.logger.error(err);
          reject(err);
        }
      }

      findShare();
    });

    return _promise2.default.race([promise, new _promise2.default(function (resolve, reject) {
      return setTimeout(reject(new Error('Could not find media share after 10000ms')), 10000);
    })]);
  };
}

/**
 * Indicates of the specified locus is active
 * @param {Types~Locus} locus
 * @private
 * @returns {Boolean}
 */
function isActive(locus) {
  return locus.fullState.state === 'ACTIVE';
}

/**
 * Indicates if the specified locus represents a call (in other words, has
 * exactly two participants)
 * @param {Types~Locus} locus
 * @private
 * @returns {Boolean}
 */
function isCall(locus) {
  return locus && locus.fullState && locus.fullState.type === 'CALL';
}

/**
 * Indicates if the current user has joined the Locus
 * @param {Types~Locus} locus
 * @private
 * @returns {Boolean}
 */
function joined(locus) {
  return Boolean(locus.self && participantIsJoined(locus.self));
}

/**
 * Indicates if this device has joined the locus
 * @param {ProxySpark} spark
 * @param {Types~Locus} locus
 * @private
 * @returns {Boolean}
 */
function joinedOnThisDevice(spark, locus) {
  return joined(locus) && spark.internal.device.url === locus.self.deviceUrl;
}

/**
 * Converts a list of participants to a list of memberships
 * @param {SparkCore} spark
 * @param {Types~Locus} locus
 * @private
 * @returns {Array<CallMembership>}
 */
function participantsToCallMemberships(spark, locus) {
  var users = new _map2.default();
  var devices = new _map2.default();

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(locus.participants), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var participant = _step.value;

      if (participant.type === 'USER') {
        users.set(participant.url, participant);
      } else if (participant.type === 'RESOURCE_ROOM') {
        devices.set(participant.url, participant);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var memberships = [];
  users.forEach(function (participant) {
    var membership = participantToCallMembership(spark, locus, participant);
    if (participant.devices) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(participant.devices), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var device = _step2.value;

          if (device.state === 'JOINED' && (0, _get3.default)(device, 'intent.type') === 'OBSERVE') {
            var deviceParticipant = devices.get(device.url);
            membership.audioMuted = remoteAudioMuted(deviceParticipant);
            membership.videoMuted = remoteVideoMuted(deviceParticipant);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    memberships.push(membership);
  });

  return memberships;
}

/**
 * Converts a single participant to a membership
 * @param {SparkCore} spark
 * @param {Types~Locus} locus
 * @param {Object} participant
 * @private
 * @returns {CallMembership}
 */
function participantToCallMembership(spark, locus, participant) {
  var personId = void 0,
      personUuid = void 0;
  if (!participant.person.isExternal) {
    personUuid = participant.person.id;
    personId = spark.people.inferPersonIdFromUuid(participant.person.id);
  }

  return {
    _id: participant.id,
    isSelf: locus.self.url === participant.url,
    isInitiator: participant.isCreator || false,
    personUuid: personUuid,
    personId: personId,
    state: participantStateToCallMembershipState(participant),
    audioMuted: remoteAudioMuted(participant),
    videoMuted: remoteVideoMuted(participant)
  };
}

/**
 *
 * Maps participant details to membership state enum
 * @param {LocusParticipant} participant
 * @private
 * @returns {string}
 */
function participantStateToCallMembershipState(participant) {
  var state = participant.state && participant.state.toLowerCase();
  switch (state) {
    case 'idle':
      return 'notified';
    case 'joined':
      return 'connected';
    case 'left':
      return 'disconnected';
    default:
      return state;
  }
}

/**
 * Creates a unique identifier for a call (but not necessarily the "callId" that
 * we'll someday expose as a first-class property)
 *
 * @param {Object} locus
 * @private
 * @returns {string}
 */
function makeInternalCallId(locus) {
  return locus.url + '_' + locus.fullState.lastActive;
}

/**
 * Indicates the direction of the specified media type for the specified
 * participant
 * @param {string} mediaType
 * @param {Types~LocusParticipant} participant
 * @private
 * @returns {string} One of `sendonly`, `recvonly`, `sendrecv`, or `inactive`
 */
function mediaDirection(mediaType, participant) {
  if (!participant) {
    return 'inactive';
  }

  if (!participant.status) {
    return 'inactive';
  }

  return (participant.status[mediaType + 'Status'] || 'inactive').toLowerCase();
}

/**
 * Indicates if the specified participant has joined the Locus
 * @param {Types~LocusParticipant} participant
 * @private
 * @returns {Boolean}
 */
function participantIsJoined(participant) {
  return participant && participant.state === 'JOINED';
}

/**
 * Finds the party in the call that is not the current user
 * @param {Types~Locus} locus
 * @private
 * @returns {Types~LocusParticipant}
 */
function remoteParticipant(locus) {
  return remoteParticipants(locus)[0];
}

/**
 * Finds all participants of the Locus that are not the current user
 * @param {Types~Locus} locus
 * @private
 * @returns {Types~LocusParticipant}
 */
function remoteParticipants(locus) {
  return locus.participants.filter(function (participant) {
    return participant.type === 'USER' && participant.url !== locus.self.url;
  });
}

/**
 * Indicates if the remote party is sending audio
 * @param {Types~LocusParticipant} participant
 * @private
 * @returns {Boolean}
 */
function remoteAudioMuted(participant) {
  return participantIsJoined(participant) && !participant.status.audioStatus.includes('SEND');
}

/**
 * Indicates if the remote party is sending video
 * @param {Types~LocusParticipant} participant
 * @private
 * @returns {Boolean}
 */
function remoteVideoMuted(participant) {
  return participantIsJoined(participant) && !participant.status.videoStatus.includes('SEND');
}

/**
 * Indicates if the `call:incoming` event should be fired for the specified Locus
 * @param {Types~Locus} locus Event which delivered the Locus
 * @param {ProxySpark} spark
 * @private
 * @returns {Boolean}
 */
function shouldRing(locus) {
  return (0, _get3.default)(locus, 'self.alertType.action') !== 'NONE';
}

/**
 * Determines the call state from a locus object
 * @param {Types~Locus} locus
 * @private
 * @returns {string}
 */
function getState(locus) {
  return locus && locus.fullState && locus.fullState.state.toLowerCase();
}

// there's really no good way to split getStatus() up that won't make it less readable
/* eslint-disable complexity */
/**
 * Determines the call state from a locus object. avoids the caching caused by
 * amp state because that leads to out-of-order updates
 * @param {ProxySpark} spark
 * @param {Types~Locus} locus
 * @param {Types~Locus} previousLocus
 * @private
 * @returns {string}
 */
function getStatus(spark, locus, previousLocus) {
  if (locus) {
    var remote = remoteParticipant(locus);

    if (remote) {
      if (joinedOnThisDevice(spark, locus) && remote && participantIsJoined(remote)) {
        return 'connected';
      }
      if (locus.replaces) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = (0, _getIterator3.default)(locus.replaces), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var replaced = _step3.value;

            if (replaced.locusUrl === previousLocus.url && replaced.lastActive === (0, _get3.default)(previousLocus, 'fullState.lastActive')) {
              return 'replaced';
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      var local = locus.self;
      if (remote.state === 'LEFT' || local.state === 'LEFT') {
        return 'disconnected';
      }

      if (remote.state === 'DECLINED') {
        return 'disconnected';
      }

      if (remote.state === 'NOTIFIED') {
        return 'ringing';
      }
    }
  }
  return 'initiated';
}

/**
 * Finds the `self` entry for the specified locus
 * @param {ProxySpark} spark
 * @param {Types~Locus} locus
 * @returns {Object}
 */
function getThisDevice(spark, locus) {
  return locus && locus.self && locus.self.devices.find(function (item) {
    return item.url === spark.internal.device.url;
  });
}


},{"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"lodash/filter":1626,"lodash/get":1636}],801:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _stream = require('stream');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Reforms the interesting data from an RTCStatsReport into something grokkable
 */
var StatsFilter = function (_Transform) {
  (0, _inherits3.default)(StatsFilter, _Transform);

  /**
   * Tells the Stream we're operating in objectMode
   * @private
   */
  function StatsFilter() {
    (0, _classCallCheck3.default)(this, StatsFilter);
    return (0, _possibleConstructorReturn3.default)(this, (StatsFilter.__proto__ || (0, _getPrototypeOf2.default)(StatsFilter)).call(this, { objectMode: true }));
  }

  /**
   * Filters out just the interesting part of a RTCStatsReport
   * @param {RTCStatsReport} report
   * @param {*} encoding
   * @param {Function} callback
   * @private
   * @returns {undefined}
   */


  (0, _createClass3.default)(StatsFilter, [{
    key: '_transform',
    value: function _transform(report, encoding, callback) {
      if (!report) {
        callback();
        return;
      }

      var incomingAudio = {
        local: null,
        remote: null
      };
      var incomingVideo = {
        local: null,
        remote: null
      };
      var outgoingAudio = {
        local: null,
        remote: null
      };
      var outgoingVideo = {
        local: null,
        remote: null
      };

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(report.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;

          if (item.type === 'outbound-rtp' && !item.isRemote && item.mediaType === 'audio') {
            outgoingAudio.local = item;
            outgoingAudio.remote = report.get(item.remoteId);
          }

          if (item.type === 'outbound-rtp' && !item.isRemote && item.mediaType === 'video') {
            outgoingVideo.local = item;
            outgoingVideo.remote = report.get(item.remoteId);
          }

          if (item.type === 'inbound-rtp' && !item.isRemote && item.mediaType === 'audio') {
            incomingAudio.local = item;
            incomingAudio.remote = report.get(item.remoteId);
          }

          if (item.type === 'inbound-rtp' && !item.isRemote && item.mediaType === 'video') {
            incomingVideo.local = item;
            incomingVideo.remote = report.get(item.remoteId);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.push({
        incomingAudio: incomingAudio,
        incomingVideo: incomingVideo,
        outgoingAudio: outgoingAudio,
        outgoingVideo: outgoingVideo
      });

      callback();
    }
  }]);
  return StatsFilter;
}(_stream.Transform);

exports.default = StatsFilter;


},{"babel-runtime/core-js/get-iterator":679,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"stream":1762}],802:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _stream = require('stream');

var _events = require('events');

var _commonTimers = require('@ciscospark/common-timers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var emittersByPc = new _weakMap2.default(); /* eslint-disable require-jsdoc */

var pcsByEmitter = new _weakMap2.default();
var emittersByStream = new _weakMap2.default();
var timersByEmitter = new _weakMap2.default();

/**
 * Helper function that ensures no matter how many stats streams we create, we
 * don't poll the PeerConnection more than once per interval.
 * @param {EventEmitter} emitter
 * @private
 * @returns {undefined}
 */
function schedule(emitter) {
  var timer = (0, _commonTimers.safeSetTimeout)(function () {
    var pc = pcsByEmitter.get(emitter);
    pc.getStats().then(function (stats) {
      emitter.emit('data', stats);
      // "closed" is supposed to be part of the {@link RTCPeerConnectionState}
      // enum according to spec, but at time of writing, was still implemented
      // in the {@link RTCSignalingState} enum.
      if (!(pc.signalingState === 'closed' || pc.connectionState === 'closed')) {
        schedule(emitter);
      }
    }).catch(function (err) {
      emitter.emit('error', err);
    });
  }, 1000);

  timersByEmitter.set(emitter, timer);
}

/**
 * Polls an {@link RTCPeerConnection} once per second and emits its
 * {@link RTCStatsReport}
 */

var StatsStream = function (_Readable) {
  (0, _inherits3.default)(StatsStream, _Readable);

  /**
   * @private
   * @param {RTCPeerConnection} pc
   */
  function StatsStream(pc) {
    (0, _classCallCheck3.default)(this, StatsStream);

    var _this = (0, _possibleConstructorReturn3.default)(this, (StatsStream.__proto__ || (0, _getPrototypeOf2.default)(StatsStream)).call(this, { objectMode: true }));

    if (!emittersByPc.has(pc)) {
      emittersByPc.set(pc, new _events.EventEmitter());
    }
    var emitter = emittersByPc.get(pc);

    if (!emittersByStream.has(_this)) {
      emittersByStream.set(_this, emitter);
    }
    if (!pcsByEmitter.has(emitter)) {
      pcsByEmitter.set(emitter, pc);
    }

    emitter.once('error', function (err) {
      _this.emit('error', err);
    });
    return _this;
  }

  /**
   * See NodeJS Docs
   * @private
   * @returns {undefined}
   */


  (0, _createClass3.default)(StatsStream, [{
    key: '_read',
    value: function _read() {
      var _this2 = this;

      var emitter = emittersByStream.get(this);

      emitter.once('data', function (data) {
        if (!_this2.isPaused()) {
          _this2.push(data);
        }
      });

      if (!timersByEmitter.has(emitter)) {
        schedule(emitter);
      }
    }
  }]);
  return StatsStream;
}(_stream.Readable);

exports.default = StatsStream;


},{"@ciscospark/common-timers":41,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"events":1737,"stream":1762}],803:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./lib/storage":830,"_process":1743,"dup":131}],804:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./config":803,"./interceptors/auth":805,"./interceptors/network-timing":806,"./interceptors/payload-transformer":807,"./interceptors/rate-limit":808,"./interceptors/redirect":809,"./interceptors/request-event":810,"./interceptors/request-logger":811,"./interceptors/request-timing":812,"./interceptors/response-logger":813,"./interceptors/spark-tracking-id":814,"./interceptors/spark-user-agent":815,"./lib/batcher":816,"./lib/credentials":819,"./lib/page":823,"./lib/spark-http-error":825,"./lib/spark-plugin":827,"./lib/storage":830,"./plugins/logger":834,"./spark-core":835,"dup":132}],805:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":133}],806:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":134}],807:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":135}],808:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"@ciscospark/http-core":742,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":136}],809:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":137,"lodash/clone":1611}],810:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":138,"lodash/get":1636}],811:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"@ciscospark/http-core":742,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":139,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isString":1662,"lodash/omit":1679,"util":1769}],812:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":140}],813:[function(require,module,exports){
(function (Buffer,process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _httpCore = require('@ciscospark/http-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

var ResponseLoggerInterceptor = function (_Interceptor) {
  (0, _inherits3.default)(ResponseLoggerInterceptor, _Interceptor);

  function ResponseLoggerInterceptor() {
    (0, _classCallCheck3.default)(this, ResponseLoggerInterceptor);
    return (0, _possibleConstructorReturn3.default)(this, (ResponseLoggerInterceptor.__proto__ || (0, _getPrototypeOf2.default)(ResponseLoggerInterceptor)).apply(this, arguments));
  }

  (0, _createClass3.default)(ResponseLoggerInterceptor, [{
    key: 'onResponse',


    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @param {HttpResponse} response
     * @returns {Object}
     */
    value: function onResponse(options, response) {
      var now = new Date();
      this.printResponseHeader(options, response);

      var logger = (0, _get3.default)(this, 'spark.logger', console);
      if (process.env.ENABLE_VERBOSE_NETWORK_LOGGING) {
        logger.info('timestamp (end): ', now.getTime(), now.toISOString());
        if (typeof response.body === 'string' || Buffer.isBuffer(response.body)) {
          logger.info('Response: ', 'Not printed, it`s probably a file');
        } else if ((0, _typeof3.default)(response.body) === 'object') {
          try {
            logger.info('Response: ', _util2.default.inspect((0, _omit3.default)(response.body, 'features'), { depth: null }));
          } catch (err) {
            logger.info('Response: ', '[Not Serializable]', err);
          }
        }
      }
      logger.info('\\**********************************************************************/');

      return response;
    }

    /**
     * @see Interceptor#onRequest
     * @param {Object} options
     * @param {Object} reason
     * @returns {Object}
     */

  }, {
    key: 'onResponseError',
    value: function onResponseError(options, reason) {
      var now = new Date();
      this.printResponseHeader(options, reason);

      var logger = (0, _get3.default)(this, 'spark.logger', console);
      if (process.env.ENABLE_VERBOSE_NETWORK_LOGGING) {
        logger.info('timestamp (end): ', now.getTime(), now.toISOString());
        try {
          logger.error('Response: ', _util2.default.inspect(reason.body, { depth: null }));
        } catch (err) {
          logger.error('Response: ', reason.body);
        }
      }
      logger.info('\\**********************************************************************/');

      return _promise2.default.reject(reason);
    }

    /**
     * Prints the basic header
     * @param {Object} options
     * @param {HttpResponse|SparkHttpError} response
     * @returns {undefined}
     */

  }, {
    key: 'printResponseHeader',
    value: function printResponseHeader(options, response) {
      var logger = (0, _get3.default)(this, 'spark.logger', console);
      logger.info('Status Code:', response.statusCode);
      logger.info('WEBEX_TRACKINGID:', (0, _get3.default)(options, 'headers.trackingid') || (0, _get3.default)(response, 'headers.trackingid'));
      logger.info('Network duration:', options.$timings.networkEnd - options.$timings.networkStart);
      logger.info('Processing duration:', options.$timings.requestEnd - options.$timings.requestStart);
    }
  }], [{
    key: 'create',

    /**
     * @returns {ResponseLoggerInterceptor}
     */
    value: function create() {
      return new ResponseLoggerInterceptor({ spark: this });
    }
  }]);
  return ResponseLoggerInterceptor;
}(_httpCore.Interceptor);

exports.default = ResponseLoggerInterceptor;


}).call(this,{"isBuffer":require("../../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")},require('_process'))
},{"../../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":1740,"@ciscospark/http-core":742,"_process":1743,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/promise":694,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"babel-runtime/helpers/typeof":711,"lodash/get":1636,"lodash/omit":1679,"util":1769}],814:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":142}],815:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"@ciscospark/common":731,"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":143,"lodash/get":1636}],816:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"./spark-http-error":825,"./spark-plugin":827,"@ciscospark/common":731,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"dup":144,"lodash/has":1638}],817:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"../spark-plugin":827,"../storage/decorators":828,"./grant-errors":818,"./scope":820,"./token":822,"./token-collection":821,"@ciscospark/common":731,"@ciscospark/common-timers":41,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"dup":145,"lodash/clone":1611,"lodash/cloneDeep":1612,"lodash/isEmpty":1653,"lodash/isObject":1659,"querystring":1747,"url":1765}],818:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"@ciscospark/common":731,"babel-runtime/core-js/object/define-properties":686,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":146}],819:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"../../spark-core":835,"./credentials":817,"./grant-errors":818,"./scope":820,"./token":822,"dup":147}],820:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"dup":148}],821:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"./token":822,"ampersand-collection":838,"dup":149}],822:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"../spark-http-error":825,"../spark-plugin":827,"./grant-errors":818,"./scope":820,"@ciscospark/common":731,"@ciscospark/common-timers":41,"_process":1743,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/helpers/slicedToArray":709,"dup":150,"lodash/pick":1685}],823:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"babel-runtime/core-js/symbol/iterator":702,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":151}],824:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":152,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],825:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"@ciscospark/http-core":742,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/define-property":697,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":153}],826:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/reflect/define-property":697,"dup":154,"lodash/get":1636,"lodash/has":1638,"lodash/isArray":1648,"lodash/isFunction":1656,"lodash/merge":1674,"lodash/union":1710}],827:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"./storage":830,"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"dup":155,"lodash/cloneDeep":1612,"lodash/isObject":1659,"lodash/omit":1679,"util":1769}],828:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"./errors":829,"@ciscospark/common":731,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/set":700,"babel-runtime/helpers/defineProperty":706,"babel-runtime/helpers/toConsumableArray":710,"babel-runtime/helpers/typeof":711,"dup":156,"lodash/curry":1615,"lodash/debounce":1617,"lodash/identity":1641,"lodash/result":1692,"lodash/wrap":1715}],829:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"@ciscospark/common":731,"babel-runtime/core-js/object/get-prototype-of":690,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/inherits":707,"babel-runtime/helpers/possibleConstructorReturn":708,"dup":157}],830:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"./decorators":828,"./errors":829,"./make-spark-plugin-store.js":831,"./make-spark-store.js":832,"./memory-store-adapter":833,"dup":158}],831:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"./errors":829,"@ciscospark/common":731,"_process":1743,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":159,"lodash/isArray":1648,"lodash/isObject":1659,"lodash/result":1692}],832:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"@ciscospark/common":731,"ampersand-events":673,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705,"dup":160}],833:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"./errors":829,"babel-runtime/core-js/map":682,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"dup":161}],834:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"../lib/spark-plugin":827,"../spark-core":835,"_process":1743,"dup":162}],835:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./config":803,"./interceptors/auth":805,"./interceptors/network-timing":806,"./interceptors/payload-transformer":807,"./interceptors/rate-limit":808,"./interceptors/redirect":809,"./interceptors/request-event":810,"./interceptors/request-logger":811,"./interceptors/request-timing":812,"./interceptors/response-logger":813,"./interceptors/spark-tracking-id":814,"./interceptors/spark-user-agent":815,"./lib/spark-core-plugin-mixin":824,"./lib/spark-http-error":825,"./lib/spark-internal-core-plugin-mixin":826,"./lib/storage":830,"./spark-internal-core":836,"@ciscospark/common":731,"@ciscospark/http-core":742,"_process":1743,"ampersand-state":675,"babel-runtime/core-js/object/assign":684,"babel-runtime/core-js/object/get-own-property-descriptor":689,"babel-runtime/core-js/object/keys":691,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/apply":695,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/helpers/toConsumableArray":710,"dup":163,"events":1737,"lodash/defaults":1618,"lodash/get":1636,"lodash/has":1638,"lodash/isFunction":1656,"lodash/isString":1662,"lodash/last":1669,"lodash/merge":1674,"lodash/omit":1679,"lodash/set":1694,"lodash/unset":1712,"util":1769,"uuid":868}],836:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"ampersand-state":675,"babel-runtime/core-js/object/keys":691,"dup":164,"util":1769}],837:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _sparkCore = require('@ciscospark/spark-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var namespaces = new _weakMap2.default(); /*!
                                           * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                           */

/* eslint-env browser */

var loggers = new _weakMap2.default();

/**
 * localStorage adapter for spark-core storage layer
 */

var StorageAdapterLocalStorage = function () {
  /**
   * @constructs {StorageAdapterLocalStorage}
   * @param {string} basekey localStorage key underwhich all namespaces will be
   * stored
   */
  function StorageAdapterLocalStorage(basekey) {
    (0, _classCallCheck3.default)(this, StorageAdapterLocalStorage);

    /**
     * localStorage binding
     */
    this.Bound = function () {
      /**
       * @constructs {Bound}
       * @param {string} namespace
       * @param {Object} options
       */
      function _class(namespace, options) {
        (0, _classCallCheck3.default)(this, _class);

        namespaces.set(this, namespace);
        loggers.set(this, options.logger);
      }

      /**
       * @private
       * @returns {rawData}
       */


      (0, _createClass3.default)(_class, [{
        key: '_getRawData',
        value: function _getRawData() {
          var rawData = localStorage.getItem(basekey);
          return rawData ? JSON.parse(rawData) : {};
        }

        /**
         * @private
         * @returns {mixed}
         */

      }, {
        key: '_load',
        value: function _load() {
          var allData = this._getRawData();
          return allData[namespaces.get(this)] || {};
        }

        /**
         * @param {Object} data
         * @private
         * @returns {undefined}
         */

      }, {
        key: '_save',
        value: function _save(data) {
          var allData = this._getRawData();
          allData[namespaces.get(this)] = data;

          localStorage.setItem(basekey, (0, _stringify2.default)(allData));
        }

        /**
         * Clears the localStorage
         * @param {string} key
         * @returns {Promise}
         */

      }, {
        key: 'clear',
        value: function clear() {
          loggers.get(this).info('local-storage-store-adapter: clearing localStorage');
          return _promise2.default.resolve(localStorage.removeItem(basekey));
        }

        /**
         * Removes the specified key
         * @param {string} key
         * @returns {Promise}
         */

      }, {
        key: 'del',
        value: function del(key) {
          var _this = this;

          return new _promise2.default(function (resolve) {
            loggers.get(_this).info('local-storage-store-adapter: deleting `' + key + '`');
            var data = _this._load();
            (0, _deleteProperty2.default)(data, key);
            _this._save(data);
            resolve();
          });
        }

        /**
         * Retrieves the data at the specified key
         * @param {string} key
         * @returns {Promise<mixed>}
         */

      }, {
        key: 'get',
        value: function get(key) {
          var _this2 = this;

          return new _promise2.default(function (resolve, reject) {
            loggers.get(_this2).info('local-storage-store-adapter: reading `' + key + '`');
            var data = _this2._load();
            var value = data[key];
            if (typeof value !== 'undefined') {
              return resolve(value);
            }

            return reject(new _sparkCore.NotFoundError('No value found for ' + key));
          });
        }

        /**
         * Stores the specified value at the specified key
         * @param {string} key
         * @param {mixed} value
         * @returns {Promise}
         */

      }, {
        key: 'put',
        value: function put(key, value) {
          var _this3 = this;

          return new _promise2.default(function (resolve) {
            loggers.get(_this3).info('local-storage-store-adapter: writing `' + key + '`');
            var data = _this3._load();
            data[key] = value;
            _this3._save(data);
            resolve();
          });
        }
      }]);
      return _class;
    }();
  }

  /**
   * Returns an adapter bound to the specified namespace
   * @param {string} namespace
   * @param {Object} options
   * @returns {Promise<Bound>}
   */


  (0, _createClass3.default)(StorageAdapterLocalStorage, [{
    key: 'bind',
    value: function bind(namespace, options) {
      options = options || {};
      if (!namespace) {
        return _promise2.default.reject(new Error('`namespace` is required'));
      }

      if (!options.logger) {
        return _promise2.default.reject(new Error('`options.logger` is required'));
      }

      options.logger.info('local-storage-store-adapter: returning binding');

      return _promise2.default.resolve(new this.Bound(namespace, options));
    }
  }]);
  return StorageAdapterLocalStorage;
}();

exports.default = StorageAdapterLocalStorage;


},{"@ciscospark/spark-core":804,"babel-runtime/core-js/json/stringify":681,"babel-runtime/core-js/promise":694,"babel-runtime/core-js/reflect/delete-property":698,"babel-runtime/core-js/weak-map":703,"babel-runtime/helpers/classCallCheck":704,"babel-runtime/helpers/createClass":705}],838:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"ampersand-class-extend":671,"ampersand-events":673,"dup":165,"lodash/assign":1606,"lodash/bind":1610,"lodash/isArray":1648}],839:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],840:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./private/utils":853,"dup":22}],841:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./applyDecorators":839,"./autobind":840,"./debounce":842,"./decorate":843,"./deprecate":844,"./enumerable":845,"./extendDescriptor":846,"./lazy-initialize":847,"./memoize":848,"./mixin":849,"./nonconfigurable":850,"./nonenumerable":851,"./override":852,"./profile":854,"./readonly":855,"./suppress-warnings":856,"./throttle":857,"./time":858,"dup":23}],842:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./private/utils":853,"dup":24}],843:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"./private/utils":853,"dup":25}],844:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./private/utils":853,"dup":26}],845:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./private/utils":853,"dup":27}],846:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./private/utils":853,"dup":28}],847:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./private/utils":853,"dup":29}],848:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./private/utils":853,"dup":30}],849:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./private/utils":853,"dup":31}],850:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./private/utils":853,"dup":32}],851:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./private/utils":853,"dup":33}],852:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./private/utils":853,"dup":34}],853:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"../lazy-initialize":847,"dup":35}],854:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./private/utils":853,"dup":36}],855:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./private/utils":853,"dup":37}],856:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./private/utils":853,"dup":38}],857:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./private/utils":853,"dup":39}],858:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./private/utils":853,"dup":40}],859:[function(require,module,exports){
arguments[4][186][0].apply(exports,arguments)
},{"dup":186}],860:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./formats":859,"./parse":861,"./stringify":862,"dup":187}],861:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"./utils":863,"dup":188}],862:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"./formats":859,"./utils":863,"dup":189}],863:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],864:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"dup":84}],865:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"./parser":866,"./writer":867,"dup":85}],866:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"./grammar":864,"dup":86}],867:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"./grammar":864,"dup":87}],868:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"./v1":871,"./v4":872,"dup":191}],869:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"dup":192}],870:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"dup":193}],871:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./lib/bytesToUuid":869,"./lib/rng":870,"dup":194}],872:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"./lib/bytesToUuid":869,"./lib/rng":870,"dup":195}],873:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;
},{"../../modules/_core":1035,"../../modules/core.regexp.escape":1131}],874:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;
},{"../../modules/_core":916,"../../modules/es6.array.from":985,"../../modules/es6.string.iterator":1005}],875:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');
},{"../modules/core.get-iterator":983,"../modules/es6.string.iterator":1005,"../modules/web.dom.iterable":1014}],876:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.is-iterable');
},{"../modules/core.is-iterable":984,"../modules/es6.string.iterator":1005,"../modules/web.dom.iterable":1014}],877:[function(require,module,exports){
var core  = require('../../modules/_core')
  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};
},{"../../modules/_core":916}],878:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
module.exports = require('../modules/_core').Map;
},{"../modules/_core":916,"../modules/es6.map":987,"../modules/es6.object.to-string":997,"../modules/es6.string.iterator":1005,"../modules/es7.map.to-json":1008,"../modules/web.dom.iterable":1014}],879:[function(require,module,exports){
require('../../modules/es6.number.is-nan');
module.exports = require('../../modules/_core').Number.isNaN;
},{"../../modules/_core":916,"../../modules/es6.number.is-nan":988}],880:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;
},{"../../modules/_core":916,"../../modules/es6.object.assign":989}],881:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};
},{"../../modules/_core":916,"../../modules/es6.object.create":990}],882:[function(require,module,exports){
require('../../modules/es6.object.define-properties');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperties(T, D){
  return $Object.defineProperties(T, D);
};
},{"../../modules/_core":916,"../../modules/es6.object.define-properties":991}],883:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};
},{"../../modules/_core":916,"../../modules/es6.object.define-property":992}],884:[function(require,module,exports){
require('../../modules/es7.object.entries');
module.exports = require('../../modules/_core').Object.entries;
},{"../../modules/_core":916,"../../modules/es7.object.entries":1009}],885:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-descriptor');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyDescriptor(it, key){
  return $Object.getOwnPropertyDescriptor(it, key);
};
},{"../../modules/_core":916,"../../modules/es6.object.get-own-property-descriptor":993}],886:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/_core').Object.getPrototypeOf;
},{"../../modules/_core":916,"../../modules/es6.object.get-prototype-of":994}],887:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;
},{"../../modules/_core":916,"../../modules/es6.object.keys":995}],888:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;
},{"../../modules/_core":916,"../../modules/es6.object.set-prototype-of":996}],889:[function(require,module,exports){
require('../../modules/es7.object.values');
module.exports = require('../../modules/_core').Object.values;
},{"../../modules/_core":916,"../../modules/es7.object.values":1010}],890:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
module.exports = require('../modules/_core').Promise;
},{"../modules/_core":916,"../modules/es6.object.to-string":997,"../modules/es6.promise":998,"../modules/es6.string.iterator":1005,"../modules/web.dom.iterable":1014}],891:[function(require,module,exports){
require('../../modules/es6.reflect.apply');
module.exports = require('../../modules/_core').Reflect.apply;
},{"../../modules/_core":916,"../../modules/es6.reflect.apply":999}],892:[function(require,module,exports){
require('../../modules/es6.reflect.construct');
module.exports = require('../../modules/_core').Reflect.construct;
},{"../../modules/_core":916,"../../modules/es6.reflect.construct":1000}],893:[function(require,module,exports){
require('../../modules/es6.reflect.define-property');
module.exports = require('../../modules/_core').Reflect.defineProperty;
},{"../../modules/_core":916,"../../modules/es6.reflect.define-property":1001}],894:[function(require,module,exports){
require('../../modules/es6.reflect.delete-property');
module.exports = require('../../modules/_core').Reflect.deleteProperty;
},{"../../modules/_core":916,"../../modules/es6.reflect.delete-property":1002}],895:[function(require,module,exports){
require('../../modules/es6.reflect.get-own-property-descriptor');
module.exports = require('../../modules/_core').Reflect.getOwnPropertyDescriptor;
},{"../../modules/_core":916,"../../modules/es6.reflect.get-own-property-descriptor":1003}],896:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
module.exports = require('../modules/_core').Set;
},{"../modules/_core":916,"../modules/es6.object.to-string":997,"../modules/es6.set":1004,"../modules/es6.string.iterator":1005,"../modules/es7.set.to-json":1011,"../modules/web.dom.iterable":1014}],897:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;
},{"../../modules/_core":916,"../../modules/es6.object.to-string":997,"../../modules/es6.symbol":1006,"../../modules/es7.symbol.async-iterator":1012,"../../modules/es7.symbol.observable":1013}],898:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');
},{"../../modules/_wks-ext":980,"../../modules/es6.string.iterator":1005,"../../modules/web.dom.iterable":1014}],899:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/web.dom.iterable');
require('../modules/es6.weak-map');
module.exports = require('../modules/_core').WeakMap;
},{"../modules/_core":916,"../modules/es6.object.to-string":997,"../modules/es6.weak-map":1007,"../modules/web.dom.iterable":1014}],900:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],901:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],902:[function(require,module,exports){
module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};
},{}],903:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":936}],904:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":926}],905:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":972,"./_to-iobject":974,"./_to-length":975}],906:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":908,"./_ctx":918,"./_iobject":933,"./_to-length":975,"./_to-object":976}],907:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":935,"./_is-object":936,"./_wks":981}],908:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":907}],909:[function(require,module,exports){
'use strict';
var aFunction  = require('./_a-function')
  , isObject   = require('./_is-object')
  , invoke     = require('./_invoke')
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};
},{"./_a-function":900,"./_invoke":932,"./_is-object":936}],910:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof')
  , TAG = require('./_wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./_cof":911,"./_wks":981}],911:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],912:[function(require,module,exports){
'use strict';
var dP          = require('./_object-dp').f
  , create      = require('./_object-create')
  , redefineAll = require('./_redefine-all')
  , ctx         = require('./_ctx')
  , anInstance  = require('./_an-instance')
  , defined     = require('./_defined')
  , forOf       = require('./_for-of')
  , $iterDefine = require('./_iter-define')
  , step        = require('./_iter-step')
  , setSpecies  = require('./_set-species')
  , DESCRIPTORS = require('./_descriptors')
  , fastKey     = require('./_meta').fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./_an-instance":902,"./_ctx":918,"./_defined":919,"./_descriptors":920,"./_for-of":926,"./_iter-define":939,"./_iter-step":941,"./_meta":945,"./_object-create":948,"./_object-dp":949,"./_redefine-all":962,"./_set-species":965}],913:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof')
  , from    = require('./_array-from-iterable');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};
},{"./_array-from-iterable":904,"./_classof":910}],914:[function(require,module,exports){
'use strict';
var redefineAll       = require('./_redefine-all')
  , getWeak           = require('./_meta').getWeak
  , anObject          = require('./_an-object')
  , isObject          = require('./_is-object')
  , anInstance        = require('./_an-instance')
  , forOf             = require('./_for-of')
  , createArrayMethod = require('./_array-methods')
  , $has              = require('./_has')
  , arrayFind         = createArrayMethod(5)
  , arrayFindIndex    = createArrayMethod(6)
  , id                = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(that){
  return that._l || (that._l = new UncaughtFrozenStore);
};
var UncaughtFrozenStore = function(){
  this.a = [];
};
var findUncaughtFrozen = function(store, key){
  return arrayFind(store.a, function(it){
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key){
    var entry = findUncaughtFrozen(this, key);
    if(entry)return entry[1];
  },
  has: function(key){
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value){
    var entry = findUncaughtFrozen(this, key);
    if(entry)entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function(key){
    var index = arrayFindIndex(this.a, function(it){
      return it[0] === key;
    });
    if(~index)this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var data = getWeak(anObject(key), true);
    if(data === true)uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};
},{"./_an-instance":902,"./_an-object":903,"./_array-methods":906,"./_for-of":926,"./_has":928,"./_is-object":936,"./_meta":945,"./_redefine-all":962}],915:[function(require,module,exports){
'use strict';
var global         = require('./_global')
  , $export        = require('./_export')
  , meta           = require('./_meta')
  , fails          = require('./_fails')
  , hide           = require('./_hide')
  , redefineAll    = require('./_redefine-all')
  , forOf          = require('./_for-of')
  , anInstance     = require('./_an-instance')
  , isObject       = require('./_is-object')
  , setToStringTag = require('./_set-to-string-tag')
  , dP             = require('./_object-dp').f
  , each           = require('./_array-methods')(0)
  , DESCRIPTORS    = require('./_descriptors');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function(target, iterable){
      anInstance(target, C, NAME, '_c');
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        anInstance(this, C, KEY);
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)dP(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./_an-instance":902,"./_array-methods":906,"./_descriptors":920,"./_export":924,"./_fails":925,"./_for-of":926,"./_global":927,"./_hide":929,"./_is-object":936,"./_meta":945,"./_object-dp":949,"./_redefine-all":962,"./_set-to-string-tag":966}],916:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],917:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp')
  , createDesc      = require('./_property-desc');

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};
},{"./_object-dp":949,"./_property-desc":961}],918:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":900}],919:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],920:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":925}],921:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":927,"./_is-object":936}],922:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],923:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys')
  , gOPS    = require('./_object-gops')
  , pIE     = require('./_object-pie');
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};
},{"./_object-gops":954,"./_object-keys":957,"./_object-pie":958}],924:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , ctx       = require('./_ctx')
  , hide      = require('./_hide')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;
},{"./_core":916,"./_ctx":918,"./_global":927,"./_hide":929}],925:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],926:[function(require,module,exports){
var ctx         = require('./_ctx')
  , call        = require('./_iter-call')
  , isArrayIter = require('./_is-array-iter')
  , anObject    = require('./_an-object')
  , toLength    = require('./_to-length')
  , getIterFn   = require('./core.get-iterator-method')
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;
},{"./_an-object":903,"./_ctx":918,"./_is-array-iter":934,"./_iter-call":937,"./_to-length":975,"./core.get-iterator-method":982}],927:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],928:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],929:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":920,"./_object-dp":949,"./_property-desc":961}],930:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":927}],931:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":920,"./_dom-create":921,"./_fails":925}],932:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],933:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":911}],934:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./_iterators')
  , ITERATOR   = require('./_wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./_iterators":942,"./_wks":981}],935:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":911}],936:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],937:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./_an-object":903}],938:[function(require,module,exports){
'use strict';
var create         = require('./_object-create')
  , descriptor     = require('./_property-desc')
  , setToStringTag = require('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":929,"./_object-create":948,"./_property-desc":961,"./_set-to-string-tag":966,"./_wks":981}],939:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./_library')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , hide           = require('./_hide')
  , has            = require('./_has')
  , Iterators      = require('./_iterators')
  , $iterCreate    = require('./_iter-create')
  , setToStringTag = require('./_set-to-string-tag')
  , getPrototypeOf = require('./_object-gpo')
  , ITERATOR       = require('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":924,"./_has":928,"./_hide":929,"./_iter-create":938,"./_iterators":942,"./_library":944,"./_object-gpo":955,"./_redefine":963,"./_set-to-string-tag":966,"./_wks":981}],940:[function(require,module,exports){
var ITERATOR     = require('./_wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./_wks":981}],941:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],942:[function(require,module,exports){
module.exports = {};
},{}],943:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./_object-keys":957,"./_to-iobject":974}],944:[function(require,module,exports){
module.exports = true;
},{}],945:[function(require,module,exports){
var META     = require('./_uid')('meta')
  , isObject = require('./_is-object')
  , has      = require('./_has')
  , setDesc  = require('./_object-dp').f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !require('./_fails')(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
},{"./_fails":925,"./_has":928,"./_is-object":936,"./_object-dp":949,"./_uid":978}],946:[function(require,module,exports){
var global    = require('./_global')
  , macrotask = require('./_task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = require('./_cof')(process) == 'process';

module.exports = function(){
  var head, last, notify;

  var flush = function(){
    var parent, fn;
    if(isNode && (parent = process.domain))parent.exit();
    while(head){
      fn   = head.fn;
      head = head.next;
      try {
        fn();
      } catch(e){
        if(head)notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if(parent)parent.enter();
  };

  // Node.js
  if(isNode){
    notify = function(){
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if(Observer){
    var toggle = true
      , node   = document.createTextNode('');
    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
    notify = function(){
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if(Promise && Promise.resolve){
    var promise = Promise.resolve();
    notify = function(){
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function(){
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function(fn){
    var task = {fn: fn, next: undefined};
    if(last)last.next = task;
    if(!head){
      head = task;
      notify();
    } last = task;
  };
};
},{"./_cof":911,"./_global":927,"./_task":971}],947:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":925,"./_iobject":933,"./_object-gops":954,"./_object-keys":957,"./_object-pie":958,"./_to-object":976}],948:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":903,"./_dom-create":921,"./_enum-bug-keys":922,"./_html":930,"./_object-dps":950,"./_shared-key":967}],949:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":903,"./_descriptors":920,"./_ie8-dom-define":931,"./_to-primitive":977}],950:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":903,"./_descriptors":920,"./_object-dp":949,"./_object-keys":957}],951:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":920,"./_has":928,"./_ie8-dom-define":931,"./_object-pie":958,"./_property-desc":961,"./_to-iobject":974,"./_to-primitive":977}],952:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject')
  , gOPN      = require('./_object-gopn').f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":953,"./_to-iobject":974}],953:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":922,"./_object-keys-internal":956}],954:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],955:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = require('./_has')
  , toObject    = require('./_to-object')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":928,"./_shared-key":967,"./_to-object":976}],956:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":905,"./_has":928,"./_shared-key":967,"./_to-iobject":974}],957:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":922,"./_object-keys-internal":956}],958:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],959:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":916,"./_export":924,"./_fails":925}],960:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject')
  , isEnum    = require('./_object-pie').f;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};
},{"./_object-keys":957,"./_object-pie":958,"./_to-iobject":974}],961:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],962:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function(target, src, safe){
  for(var key in src){
    if(safe && target[key])target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};
},{"./_hide":929}],963:[function(require,module,exports){
module.exports = require('./_hide');
},{"./_hide":929}],964:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":903,"./_ctx":918,"./_is-object":936,"./_object-gopd":951}],965:[function(require,module,exports){
'use strict';
var global      = require('./_global')
  , core        = require('./_core')
  , dP          = require('./_object-dp')
  , DESCRIPTORS = require('./_descriptors')
  , SPECIES     = require('./_wks')('species');

module.exports = function(KEY){
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./_core":916,"./_descriptors":920,"./_global":927,"./_object-dp":949,"./_wks":981}],966:[function(require,module,exports){
var def = require('./_object-dp').f
  , has = require('./_has')
  , TAG = require('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":928,"./_object-dp":949,"./_wks":981}],967:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":968,"./_uid":978}],968:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":927}],969:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./_an-object')
  , aFunction = require('./_a-function')
  , SPECIES   = require('./_wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./_a-function":900,"./_an-object":903,"./_wks":981}],970:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":919,"./_to-integer":973}],971:[function(require,module,exports){
var ctx                = require('./_ctx')
  , invoke             = require('./_invoke')
  , html               = require('./_html')
  , cel                = require('./_dom-create')
  , global             = require('./_global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./_cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./_cof":911,"./_ctx":918,"./_dom-create":921,"./_global":927,"./_html":930,"./_invoke":932}],972:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":973}],973:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],974:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":919,"./_iobject":933}],975:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":973}],976:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":919}],977:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":936}],978:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],979:[function(require,module,exports){
var global         = require('./_global')
  , core           = require('./_core')
  , LIBRARY        = require('./_library')
  , wksExt         = require('./_wks-ext')
  , defineProperty = require('./_object-dp').f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};
},{"./_core":916,"./_global":927,"./_library":944,"./_object-dp":949,"./_wks-ext":980}],980:[function(require,module,exports){
exports.f = require('./_wks');
},{"./_wks":981}],981:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":927,"./_shared":968,"./_uid":978}],982:[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./_classof":910,"./_core":916,"./_iterators":942,"./_wks":981}],983:[function(require,module,exports){
var anObject = require('./_an-object')
  , get      = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./_an-object":903,"./_core":916,"./core.get-iterator-method":982}],984:[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').isIterable = function(it){
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    || Iterators.hasOwnProperty(classof(O));
};
},{"./_classof":910,"./_core":916,"./_iterators":942,"./_wks":981}],985:[function(require,module,exports){
'use strict';
var ctx            = require('./_ctx')
  , $export        = require('./_export')
  , toObject       = require('./_to-object')
  , call           = require('./_iter-call')
  , isArrayIter    = require('./_is-array-iter')
  , toLength       = require('./_to-length')
  , createProperty = require('./_create-property')
  , getIterFn      = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":917,"./_ctx":918,"./_export":924,"./_is-array-iter":934,"./_iter-call":937,"./_iter-detect":940,"./_to-length":975,"./_to-object":976,"./core.get-iterator-method":982}],986:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables')
  , step             = require('./_iter-step')
  , Iterators        = require('./_iterators')
  , toIObject        = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./_add-to-unscopables":901,"./_iter-define":939,"./_iter-step":941,"./_iterators":942,"./_to-iobject":974}],987:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.1 Map Objects
module.exports = require('./_collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./_collection":915,"./_collection-strong":912}],988:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number){
    return number != number;
  }
});
},{"./_export":924}],989:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":924,"./_object-assign":947}],990:[function(require,module,exports){
var $export = require('./_export')
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: require('./_object-create')});
},{"./_export":924,"./_object-create":948}],991:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperties: require('./_object-dps')});
},{"./_descriptors":920,"./_export":924,"./_object-dps":950}],992:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":920,"./_export":924,"./_object-dp":949}],993:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = require('./_to-iobject')
  , $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./_object-gopd":951,"./_object-sap":959,"./_to-iobject":974}],994:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = require('./_to-object')
  , $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});
},{"./_object-gpo":955,"./_object-sap":959,"./_to-object":976}],995:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":957,"./_object-sap":959,"./_to-object":976}],996:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});
},{"./_export":924,"./_set-proto":964}],997:[function(require,module,exports){

},{}],998:[function(require,module,exports){
'use strict';
var LIBRARY            = require('./_library')
  , global             = require('./_global')
  , ctx                = require('./_ctx')
  , classof            = require('./_classof')
  , $export            = require('./_export')
  , isObject           = require('./_is-object')
  , aFunction          = require('./_a-function')
  , anInstance         = require('./_an-instance')
  , forOf              = require('./_for-of')
  , speciesConstructor = require('./_species-constructor')
  , task               = require('./_task').set
  , microtask          = require('./_microtask')()
  , PROMISE            = 'Promise'
  , TypeError          = global.TypeError
  , process            = global.process
  , $Promise           = global[PROMISE]
  , process            = global.process
  , isNode             = classof(process) == 'process'
  , empty              = function(){ /* empty */ }
  , Internal, GenericPromiseCapability, Wrapper;

var USE_NATIVE = !!function(){
  try {
    // correct subclassing with @@species support
    var promise     = $Promise.resolve(1)
      , FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec){ exec(empty, empty); };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch(e){ /* empty */ }
}();

// helpers
var sameConstructor = function(a, b){
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var newPromiseCapability = function(C){
  return sameConstructor($Promise, C)
    ? new PromiseCapability(C)
    : new GenericPromiseCapability(C);
};
var PromiseCapability = GenericPromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject  = aFunction(reject);
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(promise, isReject){
  if(promise._n)return;
  promise._n = true;
  var chain = promise._c;
  microtask(function(){
    var value = promise._v
      , ok    = promise._s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , domain  = reaction.domain
        , result, then;
      try {
        if(handler){
          if(!ok){
            if(promise._h == 2)onHandleUnhandled(promise);
            promise._h = 1;
          }
          if(handler === true)result = value;
          else {
            if(domain)domain.enter();
            result = handler(value);
            if(domain)domain.exit();
          }
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if(isReject && !promise._h)onUnhandled(promise);
  });
};
var onUnhandled = function(promise){
  task.call(global, function(){
    var value = promise._v
      , abrupt, handler, console;
    if(isUnhandled(promise)){
      abrupt = perform(function(){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if(abrupt)throw abrupt.error;
  });
};
var isUnhandled = function(promise){
  if(promise._h == 1)return false;
  var chain = promise._a || promise._c
    , i     = 0
    , reaction;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var onHandleUnhandled = function(promise){
  task.call(global, function(){
    var handler;
    if(isNode){
      process.emit('rejectionHandled', promise);
    } else if(handler = global.onrejectionhandled){
      handler({promise: promise, reason: promise._v});
    }
  });
};
var $reject = function(value){
  var promise = this;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if(!promise._a)promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function(value){
  var promise = this
    , then;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if(promise === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      microtask(function(){
        var wrapper = {_w: promise, _d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch(e){
    $reject.call({_w: promise, _d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor){
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch(err){
      $reject.call(this, err);
    }
  };
  Internal = function Promise(executor){
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail   = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if(this._a)this._a.push(reaction);
      if(this._s)notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
  PromiseCapability = function(){
    var promise  = new Internal;
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject  = ctx($reject, promise, 1);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = newPromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
    var capability = newPromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter){
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject;
    var abrupt = perform(function(){
      var values    = []
        , index     = 0
        , remaining = 1;
      forOf(iterable, false, function(promise){
        var $index        = index++
          , alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled  = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./_a-function":900,"./_an-instance":902,"./_classof":910,"./_core":916,"./_ctx":918,"./_export":924,"./_for-of":926,"./_global":927,"./_is-object":936,"./_iter-detect":940,"./_library":944,"./_microtask":946,"./_redefine-all":962,"./_set-species":965,"./_set-to-string-tag":966,"./_species-constructor":969,"./_task":971,"./_wks":981}],999:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export   = require('./_export')
  , aFunction = require('./_a-function')
  , anObject  = require('./_an-object')
  , rApply    = (require('./_global').Reflect || {}).apply
  , fApply    = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function(){
  rApply(function(){});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList){
    var T = aFunction(target)
      , L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});
},{"./_a-function":900,"./_an-object":903,"./_export":924,"./_fails":925,"./_global":927}],1000:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export    = require('./_export')
  , create     = require('./_object-create')
  , aFunction  = require('./_a-function')
  , anObject   = require('./_an-object')
  , isObject   = require('./_is-object')
  , fails      = require('./_fails')
  , bind       = require('./_bind')
  , rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function(){
  function F(){}
  return !(rConstruct(function(){}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function(){
  rConstruct(function(){});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /*, newTarget*/){
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
    if(Target == newTarget){
      // w/o altered newTarget, optimization for 0-4 arguments
      switch(args.length){
        case 0: return new Target;
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args));
    }
    // with altered newTarget, not support built-in constructors
    var proto    = newTarget.prototype
      , instance = create(isObject(proto) ? proto : Object.prototype)
      , result   = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});
},{"./_a-function":900,"./_an-object":903,"./_bind":909,"./_export":924,"./_fails":925,"./_global":927,"./_is-object":936,"./_object-create":948}],1001:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP          = require('./_object-dp')
  , $export     = require('./_export')
  , anObject    = require('./_an-object')
  , toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function(){
  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes){
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_an-object":903,"./_export":924,"./_fails":925,"./_object-dp":949,"./_to-primitive":977}],1002:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export  = require('./_export')
  , gOPD     = require('./_object-gopd').f
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});
},{"./_an-object":903,"./_export":924,"./_object-gopd":951}],1003:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD     = require('./_object-gopd')
  , $export  = require('./_export')
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return gOPD.f(anObject(target), propertyKey);
  }
});
},{"./_an-object":903,"./_export":924,"./_object-gopd":951}],1004:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.2 Set Objects
module.exports = require('./_collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./_collection":915,"./_collection-strong":912}],1005:[function(require,module,exports){
'use strict';
var $at  = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":939,"./_string-at":970}],1006:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global         = require('./_global')
  , has            = require('./_has')
  , DESCRIPTORS    = require('./_descriptors')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , META           = require('./_meta').KEY
  , $fails         = require('./_fails')
  , shared         = require('./_shared')
  , setToStringTag = require('./_set-to-string-tag')
  , uid            = require('./_uid')
  , wks            = require('./_wks')
  , wksExt         = require('./_wks-ext')
  , wksDefine      = require('./_wks-define')
  , keyOf          = require('./_keyof')
  , enumKeys       = require('./_enum-keys')
  , isArray        = require('./_is-array')
  , anObject       = require('./_an-object')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , createDesc     = require('./_property-desc')
  , _create        = require('./_object-create')
  , gOPNExt        = require('./_object-gopn-ext')
  , $GOPD          = require('./_object-gopd')
  , $DP            = require('./_object-dp')
  , $keys          = require('./_object-keys')
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f  = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./_library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./_an-object":903,"./_descriptors":920,"./_enum-keys":923,"./_export":924,"./_fails":925,"./_global":927,"./_has":928,"./_hide":929,"./_is-array":935,"./_keyof":943,"./_library":944,"./_meta":945,"./_object-create":948,"./_object-dp":949,"./_object-gopd":951,"./_object-gopn":953,"./_object-gopn-ext":952,"./_object-gops":954,"./_object-keys":957,"./_object-pie":958,"./_property-desc":961,"./_redefine":963,"./_set-to-string-tag":966,"./_shared":968,"./_to-iobject":974,"./_to-primitive":977,"./_uid":978,"./_wks":981,"./_wks-define":979,"./_wks-ext":980}],1007:[function(require,module,exports){
'use strict';
var each         = require('./_array-methods')(0)
  , redefine     = require('./_redefine')
  , meta         = require('./_meta')
  , assign       = require('./_object-assign')
  , weak         = require('./_collection-weak')
  , isObject     = require('./_is-object')
  , getWeak      = meta.getWeak
  , isExtensible = Object.isExtensible
  , uncaughtFrozenStore = weak.ufstore
  , tmp          = {}
  , InternalMap;

var wrapper = function(get){
  return function WeakMap(){
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      var data = getWeak(key);
      if(data === true)return uncaughtFrozenStore(this).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')('WeakMap', wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  InternalMap = weak.getConstructor(wrapper);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    redefine(proto, key, function(a, b){
      // store frozen objects on internal weakmap shim
      if(isObject(a) && !isExtensible(a)){
        if(!this._f)this._f = new InternalMap;
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
},{"./_array-methods":906,"./_collection":915,"./_collection-weak":914,"./_is-object":936,"./_meta":945,"./_object-assign":947,"./_redefine":963}],1008:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Map', {toJSON: require('./_collection-to-json')('Map')});
},{"./_collection-to-json":913,"./_export":924}],1009:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export  = require('./_export')
  , $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./_export":924,"./_object-to-array":960}],1010:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export')
  , $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});
},{"./_export":924,"./_object-to-array":960}],1011:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Set', {toJSON: require('./_collection-to-json')('Set')});
},{"./_collection-to-json":913,"./_export":924}],1012:[function(require,module,exports){
require('./_wks-define')('asyncIterator');
},{"./_wks-define":979}],1013:[function(require,module,exports){
require('./_wks-define')('observable');
},{"./_wks-define":979}],1014:[function(require,module,exports){
require('./es6.array.iterator');
var global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , TO_STRING_TAG = require('./_wks')('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}
},{"./_global":927,"./_hide":929,"./_iterators":942,"./_wks":981,"./es6.array.iterator":986}],1015:[function(require,module,exports){
arguments[4][900][0].apply(exports,arguments)
},{"dup":900}],1016:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function(it, msg){
  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
  return +it;
};
},{"./_cof":1030}],1017:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};
},{"./_hide":1052,"./_wks":1129}],1018:[function(require,module,exports){
arguments[4][902][0].apply(exports,arguments)
},{"dup":902}],1019:[function(require,module,exports){
arguments[4][903][0].apply(exports,arguments)
},{"./_is-object":1061,"dup":903}],1020:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object')
  , toIndex  = require('./_to-index')
  , toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
  var O     = toObject(this)
    , len   = toLength(O.length)
    , to    = toIndex(target, len)
    , from  = toIndex(start, len)
    , end   = arguments.length > 2 ? arguments[2] : undefined
    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
    , inc   = 1;
  if(from < to && to < from + count){
    inc  = -1;
    from += count - 1;
    to   += count - 1;
  }
  while(count-- > 0){
    if(from in O)O[to] = O[from];
    else delete O[to];
    to   += inc;
    from += inc;
  } return O;
};
},{"./_to-index":1117,"./_to-length":1120,"./_to-object":1121}],1021:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object')
  , toIndex  = require('./_to-index')
  , toLength = require('./_to-length');
module.exports = function fill(value /*, start = 0, end = @length */){
  var O      = toObject(this)
    , length = toLength(O.length)
    , aLen   = arguments.length
    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
    , end    = aLen > 2 ? arguments[2] : undefined
    , endPos = end === undefined ? length : toIndex(end, length);
  while(endPos > index)O[index++] = value;
  return O;
};
},{"./_to-index":1117,"./_to-length":1120,"./_to-object":1121}],1022:[function(require,module,exports){
arguments[4][904][0].apply(exports,arguments)
},{"./_for-of":1049,"dup":904}],1023:[function(require,module,exports){
arguments[4][905][0].apply(exports,arguments)
},{"./_to-index":1117,"./_to-iobject":1119,"./_to-length":1120,"dup":905}],1024:[function(require,module,exports){
arguments[4][906][0].apply(exports,arguments)
},{"./_array-species-create":1027,"./_ctx":1037,"./_iobject":1057,"./_to-length":1120,"./_to-object":1121,"dup":906}],1025:[function(require,module,exports){
var aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , IObject   = require('./_iobject')
  , toLength  = require('./_to-length');

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};
},{"./_a-function":1015,"./_iobject":1057,"./_to-length":1120,"./_to-object":1121}],1026:[function(require,module,exports){
arguments[4][907][0].apply(exports,arguments)
},{"./_is-array":1059,"./_is-object":1061,"./_wks":1129,"dup":907}],1027:[function(require,module,exports){
arguments[4][908][0].apply(exports,arguments)
},{"./_array-species-constructor":1026,"dup":908}],1028:[function(require,module,exports){
arguments[4][909][0].apply(exports,arguments)
},{"./_a-function":1015,"./_invoke":1056,"./_is-object":1061,"dup":909}],1029:[function(require,module,exports){
arguments[4][910][0].apply(exports,arguments)
},{"./_cof":1030,"./_wks":1129,"dup":910}],1030:[function(require,module,exports){
arguments[4][911][0].apply(exports,arguments)
},{"dup":911}],1031:[function(require,module,exports){
arguments[4][912][0].apply(exports,arguments)
},{"./_an-instance":1018,"./_ctx":1037,"./_defined":1039,"./_descriptors":1040,"./_for-of":1049,"./_iter-define":1065,"./_iter-step":1067,"./_meta":1074,"./_object-create":1078,"./_object-dp":1079,"./_redefine-all":1098,"./_set-species":1103,"dup":912}],1032:[function(require,module,exports){
arguments[4][913][0].apply(exports,arguments)
},{"./_array-from-iterable":1022,"./_classof":1029,"dup":913}],1033:[function(require,module,exports){
arguments[4][914][0].apply(exports,arguments)
},{"./_an-instance":1018,"./_an-object":1019,"./_array-methods":1024,"./_for-of":1049,"./_has":1051,"./_is-object":1061,"./_meta":1074,"./_redefine-all":1098,"dup":914}],1034:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , $export           = require('./_export')
  , redefine          = require('./_redefine')
  , redefineAll       = require('./_redefine-all')
  , meta              = require('./_meta')
  , forOf             = require('./_for-of')
  , anInstance        = require('./_an-instance')
  , isObject          = require('./_is-object')
  , fails             = require('./_fails')
  , $iterDetect       = require('./_iter-detect')
  , setToStringTag    = require('./_set-to-string-tag')
  , inheritIfRequired = require('./_inherit-if-required');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  var fixMethod = function(KEY){
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a){
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance             = new C
      // early implementations not supports chaining
      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same
      , BUGGY_ZERO = !IS_WEAK && fails(function(){
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C()
          , index     = 5;
        while(index--)$instance[ADDER](index, index);
        return !$instance.has(-0);
      });
    if(!ACCEPT_ITERABLES){
      C = wrapper(function(target, iterable){
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base, target, C);
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
    // weak collections should not contains .clear method
    if(IS_WEAK && proto.clear)delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./_an-instance":1018,"./_export":1044,"./_fails":1046,"./_for-of":1049,"./_global":1050,"./_inherit-if-required":1055,"./_is-object":1061,"./_iter-detect":1066,"./_meta":1074,"./_redefine":1099,"./_redefine-all":1098,"./_set-to-string-tag":1104}],1035:[function(require,module,exports){
arguments[4][916][0].apply(exports,arguments)
},{"dup":916}],1036:[function(require,module,exports){
arguments[4][917][0].apply(exports,arguments)
},{"./_object-dp":1079,"./_property-desc":1097,"dup":917}],1037:[function(require,module,exports){
arguments[4][918][0].apply(exports,arguments)
},{"./_a-function":1015,"dup":918}],1038:[function(require,module,exports){
'use strict';
var anObject    = require('./_an-object')
  , toPrimitive = require('./_to-primitive')
  , NUMBER      = 'number';

module.exports = function(hint){
  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};
},{"./_an-object":1019,"./_to-primitive":1122}],1039:[function(require,module,exports){
arguments[4][919][0].apply(exports,arguments)
},{"dup":919}],1040:[function(require,module,exports){
arguments[4][920][0].apply(exports,arguments)
},{"./_fails":1046,"dup":920}],1041:[function(require,module,exports){
arguments[4][921][0].apply(exports,arguments)
},{"./_global":1050,"./_is-object":1061,"dup":921}],1042:[function(require,module,exports){
arguments[4][922][0].apply(exports,arguments)
},{"dup":922}],1043:[function(require,module,exports){
arguments[4][923][0].apply(exports,arguments)
},{"./_object-gops":1085,"./_object-keys":1088,"./_object-pie":1089,"dup":923}],1044:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , hide      = require('./_hide')
  , redefine  = require('./_redefine')
  , ctx       = require('./_ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;
},{"./_core":1035,"./_ctx":1037,"./_global":1050,"./_hide":1052,"./_redefine":1099}],1045:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function(KEY){
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch(e){
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch(f){ /* empty */ }
  } return true;
};
},{"./_wks":1129}],1046:[function(require,module,exports){
arguments[4][925][0].apply(exports,arguments)
},{"dup":925}],1047:[function(require,module,exports){
'use strict';
var hide     = require('./_hide')
  , redefine = require('./_redefine')
  , fails    = require('./_fails')
  , defined  = require('./_defined')
  , wks      = require('./_wks');

module.exports = function(KEY, length, exec){
  var SYMBOL   = wks(KEY)
    , fns      = exec(defined, SYMBOL, ''[KEY])
    , strfn    = fns[0]
    , rxfn     = fns[1];
  if(fails(function(){
    var O = {};
    O[SYMBOL] = function(){ return 7; };
    return ''[KEY](O) != 7;
  })){
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function(string, arg){ return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function(string){ return rxfn.call(string, this); }
    );
  }
};
},{"./_defined":1039,"./_fails":1046,"./_hide":1052,"./_redefine":1099,"./_wks":1129}],1048:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function(){
  var that   = anObject(this)
    , result = '';
  if(that.global)     result += 'g';
  if(that.ignoreCase) result += 'i';
  if(that.multiline)  result += 'm';
  if(that.unicode)    result += 'u';
  if(that.sticky)     result += 'y';
  return result;
};
},{"./_an-object":1019}],1049:[function(require,module,exports){
arguments[4][926][0].apply(exports,arguments)
},{"./_an-object":1019,"./_ctx":1037,"./_is-array-iter":1058,"./_iter-call":1063,"./_to-length":1120,"./core.get-iterator-method":1130,"dup":926}],1050:[function(require,module,exports){
arguments[4][927][0].apply(exports,arguments)
},{"dup":927}],1051:[function(require,module,exports){
arguments[4][928][0].apply(exports,arguments)
},{"dup":928}],1052:[function(require,module,exports){
arguments[4][929][0].apply(exports,arguments)
},{"./_descriptors":1040,"./_object-dp":1079,"./_property-desc":1097,"dup":929}],1053:[function(require,module,exports){
arguments[4][930][0].apply(exports,arguments)
},{"./_global":1050,"dup":930}],1054:[function(require,module,exports){
arguments[4][931][0].apply(exports,arguments)
},{"./_descriptors":1040,"./_dom-create":1041,"./_fails":1046,"dup":931}],1055:[function(require,module,exports){
var isObject       = require('./_is-object')
  , setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};
},{"./_is-object":1061,"./_set-proto":1102}],1056:[function(require,module,exports){
arguments[4][932][0].apply(exports,arguments)
},{"dup":932}],1057:[function(require,module,exports){
arguments[4][933][0].apply(exports,arguments)
},{"./_cof":1030,"dup":933}],1058:[function(require,module,exports){
arguments[4][934][0].apply(exports,arguments)
},{"./_iterators":1068,"./_wks":1129,"dup":934}],1059:[function(require,module,exports){
arguments[4][935][0].apply(exports,arguments)
},{"./_cof":1030,"dup":935}],1060:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object')
  , floor    = Math.floor;
module.exports = function isInteger(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
};
},{"./_is-object":1061}],1061:[function(require,module,exports){
arguments[4][936][0].apply(exports,arguments)
},{"dup":936}],1062:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object')
  , cof      = require('./_cof')
  , MATCH    = require('./_wks')('match');
module.exports = function(it){
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};
},{"./_cof":1030,"./_is-object":1061,"./_wks":1129}],1063:[function(require,module,exports){
arguments[4][937][0].apply(exports,arguments)
},{"./_an-object":1019,"dup":937}],1064:[function(require,module,exports){
arguments[4][938][0].apply(exports,arguments)
},{"./_hide":1052,"./_object-create":1078,"./_property-desc":1097,"./_set-to-string-tag":1104,"./_wks":1129,"dup":938}],1065:[function(require,module,exports){
arguments[4][939][0].apply(exports,arguments)
},{"./_export":1044,"./_has":1051,"./_hide":1052,"./_iter-create":1064,"./_iterators":1068,"./_library":1070,"./_object-gpo":1086,"./_redefine":1099,"./_set-to-string-tag":1104,"./_wks":1129,"dup":939}],1066:[function(require,module,exports){
arguments[4][940][0].apply(exports,arguments)
},{"./_wks":1129,"dup":940}],1067:[function(require,module,exports){
arguments[4][941][0].apply(exports,arguments)
},{"dup":941}],1068:[function(require,module,exports){
arguments[4][942][0].apply(exports,arguments)
},{"dup":942}],1069:[function(require,module,exports){
arguments[4][943][0].apply(exports,arguments)
},{"./_object-keys":1088,"./_to-iobject":1119,"dup":943}],1070:[function(require,module,exports){
module.exports = false;
},{}],1071:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;
},{}],1072:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x){
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};
},{}],1073:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
},{}],1074:[function(require,module,exports){
arguments[4][945][0].apply(exports,arguments)
},{"./_fails":1046,"./_has":1051,"./_is-object":1061,"./_object-dp":1079,"./_uid":1126,"dup":945}],1075:[function(require,module,exports){
var Map     = require('./es6.map')
  , $export = require('./_export')
  , shared  = require('./_shared')('metadata')
  , store   = shared.store || (shared.store = new (require('./es6.weak-map')));

var getOrCreateMetadataMap = function(target, targetKey, create){
  var targetMetadata = store.get(target);
  if(!targetMetadata){
    if(!create)return undefined;
    store.set(target, targetMetadata = new Map);
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if(!keyMetadata){
    if(!create)return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map);
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function(target, targetKey){
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
    , keys        = [];
  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
  return keys;
};
var toMetaKey = function(it){
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function(O){
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};
},{"./_export":1044,"./_shared":1106,"./es6.map":1161,"./es6.weak-map":1267}],1076:[function(require,module,exports){
arguments[4][946][0].apply(exports,arguments)
},{"./_cof":1030,"./_global":1050,"./_task":1116,"dup":946}],1077:[function(require,module,exports){
arguments[4][947][0].apply(exports,arguments)
},{"./_fails":1046,"./_iobject":1057,"./_object-gops":1085,"./_object-keys":1088,"./_object-pie":1089,"./_to-object":1121,"dup":947}],1078:[function(require,module,exports){
arguments[4][948][0].apply(exports,arguments)
},{"./_an-object":1019,"./_dom-create":1041,"./_enum-bug-keys":1042,"./_html":1053,"./_object-dps":1080,"./_shared-key":1105,"dup":948}],1079:[function(require,module,exports){
arguments[4][949][0].apply(exports,arguments)
},{"./_an-object":1019,"./_descriptors":1040,"./_ie8-dom-define":1054,"./_to-primitive":1122,"dup":949}],1080:[function(require,module,exports){
arguments[4][950][0].apply(exports,arguments)
},{"./_an-object":1019,"./_descriptors":1040,"./_object-dp":1079,"./_object-keys":1088,"dup":950}],1081:[function(require,module,exports){
// Forced replacement prototype accessors methods
module.exports = require('./_library')|| !require('./_fails')(function(){
  var K = Math.random();
  // In FF throws only define methods
  __defineSetter__.call(null, K, function(){ /* empty */});
  delete require('./_global')[K];
});
},{"./_fails":1046,"./_global":1050,"./_library":1070}],1082:[function(require,module,exports){
arguments[4][951][0].apply(exports,arguments)
},{"./_descriptors":1040,"./_has":1051,"./_ie8-dom-define":1054,"./_object-pie":1089,"./_property-desc":1097,"./_to-iobject":1119,"./_to-primitive":1122,"dup":951}],1083:[function(require,module,exports){
arguments[4][952][0].apply(exports,arguments)
},{"./_object-gopn":1084,"./_to-iobject":1119,"dup":952}],1084:[function(require,module,exports){
arguments[4][953][0].apply(exports,arguments)
},{"./_enum-bug-keys":1042,"./_object-keys-internal":1087,"dup":953}],1085:[function(require,module,exports){
arguments[4][954][0].apply(exports,arguments)
},{"dup":954}],1086:[function(require,module,exports){
arguments[4][955][0].apply(exports,arguments)
},{"./_has":1051,"./_shared-key":1105,"./_to-object":1121,"dup":955}],1087:[function(require,module,exports){
arguments[4][956][0].apply(exports,arguments)
},{"./_array-includes":1023,"./_has":1051,"./_shared-key":1105,"./_to-iobject":1119,"dup":956}],1088:[function(require,module,exports){
arguments[4][957][0].apply(exports,arguments)
},{"./_enum-bug-keys":1042,"./_object-keys-internal":1087,"dup":957}],1089:[function(require,module,exports){
arguments[4][958][0].apply(exports,arguments)
},{"dup":958}],1090:[function(require,module,exports){
arguments[4][959][0].apply(exports,arguments)
},{"./_core":1035,"./_export":1044,"./_fails":1046,"dup":959}],1091:[function(require,module,exports){
arguments[4][960][0].apply(exports,arguments)
},{"./_object-keys":1088,"./_object-pie":1089,"./_to-iobject":1119,"dup":960}],1092:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN     = require('./_object-gopn')
  , gOPS     = require('./_object-gops')
  , anObject = require('./_an-object')
  , Reflect  = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
  var keys       = gOPN.f(anObject(it))
    , getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
},{"./_an-object":1019,"./_global":1050,"./_object-gopn":1084,"./_object-gops":1085}],1093:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat
  , $trim       = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str){
  var string = $trim(String(str), 3)
    , result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;
},{"./_global":1050,"./_string-trim":1114,"./_string-ws":1115}],1094:[function(require,module,exports){
var $parseInt = require('./_global').parseInt
  , $trim     = require('./_string-trim').trim
  , ws        = require('./_string-ws')
  , hex       = /^[\-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;
},{"./_global":1050,"./_string-trim":1114,"./_string-ws":1115}],1095:[function(require,module,exports){
'use strict';
var path      = require('./_path')
  , invoke    = require('./_invoke')
  , aFunction = require('./_a-function');
module.exports = function(/* ...pargs */){
  var fn     = aFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that = this
      , aLen = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !aLen)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(aLen > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
},{"./_a-function":1015,"./_invoke":1056,"./_path":1096}],1096:[function(require,module,exports){
module.exports = require('./_global');
},{"./_global":1050}],1097:[function(require,module,exports){
arguments[4][961][0].apply(exports,arguments)
},{"dup":961}],1098:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function(target, src, safe){
  for(var key in src)redefine(target, key, src[key], safe);
  return target;
};
},{"./_redefine":1099}],1099:[function(require,module,exports){
var global    = require('./_global')
  , hide      = require('./_hide')
  , has       = require('./_has')
  , SRC       = require('./_uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./_core":1035,"./_global":1050,"./_has":1051,"./_hide":1052,"./_uid":1126}],1100:[function(require,module,exports){
module.exports = function(regExp, replace){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(it).replace(regExp, replacer);
  };
};
},{}],1101:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],1102:[function(require,module,exports){
arguments[4][964][0].apply(exports,arguments)
},{"./_an-object":1019,"./_ctx":1037,"./_is-object":1061,"./_object-gopd":1082,"dup":964}],1103:[function(require,module,exports){
'use strict';
var global      = require('./_global')
  , dP          = require('./_object-dp')
  , DESCRIPTORS = require('./_descriptors')
  , SPECIES     = require('./_wks')('species');

module.exports = function(KEY){
  var C = global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./_descriptors":1040,"./_global":1050,"./_object-dp":1079,"./_wks":1129}],1104:[function(require,module,exports){
arguments[4][966][0].apply(exports,arguments)
},{"./_has":1051,"./_object-dp":1079,"./_wks":1129,"dup":966}],1105:[function(require,module,exports){
arguments[4][967][0].apply(exports,arguments)
},{"./_shared":1106,"./_uid":1126,"dup":967}],1106:[function(require,module,exports){
arguments[4][968][0].apply(exports,arguments)
},{"./_global":1050,"dup":968}],1107:[function(require,module,exports){
arguments[4][969][0].apply(exports,arguments)
},{"./_a-function":1015,"./_an-object":1019,"./_wks":1129,"dup":969}],1108:[function(require,module,exports){
var fails = require('./_fails');

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};
},{"./_fails":1046}],1109:[function(require,module,exports){
arguments[4][970][0].apply(exports,arguments)
},{"./_defined":1039,"./_to-integer":1118,"dup":970}],1110:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp')
  , defined  = require('./_defined');

module.exports = function(that, searchString, NAME){
  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};
},{"./_defined":1039,"./_is-regexp":1062}],1111:[function(require,module,exports){
var $export = require('./_export')
  , fails   = require('./_fails')
  , defined = require('./_defined')
  , quot    = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function(string, tag, attribute, value) {
  var S  = String(defined(string))
    , p1 = '<' + tag;
  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function(NAME, exec){
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function(){
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};
},{"./_defined":1039,"./_export":1044,"./_fails":1046}],1112:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length')
  , repeat   = require('./_string-repeat')
  , defined  = require('./_defined');

module.exports = function(that, maxLength, fillString, left){
  var S            = String(defined(that))
    , stringLength = S.length
    , fillStr      = fillString === undefined ? ' ' : String(fillString)
    , intMaxLength = toLength(maxLength);
  if(intMaxLength <= stringLength || fillStr == '')return S;
  var fillLen = intMaxLength - stringLength
    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":1039,"./_string-repeat":1113,"./_to-length":1120}],1113:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');

module.exports = function repeat(count){
  var str = String(defined(this))
    , res = ''
    , n   = toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
},{"./_defined":1039,"./_to-integer":1118}],1114:[function(require,module,exports){
var $export = require('./_export')
  , defined = require('./_defined')
  , fails   = require('./_fails')
  , spaces  = require('./_string-ws')
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
},{"./_defined":1039,"./_export":1044,"./_fails":1046,"./_string-ws":1115}],1115:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
},{}],1116:[function(require,module,exports){
arguments[4][971][0].apply(exports,arguments)
},{"./_cof":1030,"./_ctx":1037,"./_dom-create":1041,"./_global":1050,"./_html":1053,"./_invoke":1056,"dup":971}],1117:[function(require,module,exports){
arguments[4][972][0].apply(exports,arguments)
},{"./_to-integer":1118,"dup":972}],1118:[function(require,module,exports){
arguments[4][973][0].apply(exports,arguments)
},{"dup":973}],1119:[function(require,module,exports){
arguments[4][974][0].apply(exports,arguments)
},{"./_defined":1039,"./_iobject":1057,"dup":974}],1120:[function(require,module,exports){
arguments[4][975][0].apply(exports,arguments)
},{"./_to-integer":1118,"dup":975}],1121:[function(require,module,exports){
arguments[4][976][0].apply(exports,arguments)
},{"./_defined":1039,"dup":976}],1122:[function(require,module,exports){
arguments[4][977][0].apply(exports,arguments)
},{"./_is-object":1061,"dup":977}],1123:[function(require,module,exports){
'use strict';
if(require('./_descriptors')){
  var LIBRARY             = require('./_library')
    , global              = require('./_global')
    , fails               = require('./_fails')
    , $export             = require('./_export')
    , $typed              = require('./_typed')
    , $buffer             = require('./_typed-buffer')
    , ctx                 = require('./_ctx')
    , anInstance          = require('./_an-instance')
    , propertyDesc        = require('./_property-desc')
    , hide                = require('./_hide')
    , redefineAll         = require('./_redefine-all')
    , toInteger           = require('./_to-integer')
    , toLength            = require('./_to-length')
    , toIndex             = require('./_to-index')
    , toPrimitive         = require('./_to-primitive')
    , has                 = require('./_has')
    , same                = require('./_same-value')
    , classof             = require('./_classof')
    , isObject            = require('./_is-object')
    , toObject            = require('./_to-object')
    , isArrayIter         = require('./_is-array-iter')
    , create              = require('./_object-create')
    , getPrototypeOf      = require('./_object-gpo')
    , gOPN                = require('./_object-gopn').f
    , getIterFn           = require('./core.get-iterator-method')
    , uid                 = require('./_uid')
    , wks                 = require('./_wks')
    , createArrayMethod   = require('./_array-methods')
    , createArrayIncludes = require('./_array-includes')
    , speciesConstructor  = require('./_species-constructor')
    , ArrayIterators      = require('./es6.array.iterator')
    , Iterators           = require('./_iterators')
    , $iterDetect         = require('./_iter-detect')
    , setSpecies          = require('./_set-species')
    , arrayFill           = require('./_array-fill')
    , arrayCopyWithin     = require('./_array-copy-within')
    , $DP                 = require('./_object-dp')
    , $GOPD               = require('./_object-gopd')
    , dP                  = $DP.f
    , gOPD                = $GOPD.f
    , RangeError          = global.RangeError
    , TypeError           = global.TypeError
    , Uint8Array          = global.Uint8Array
    , ARRAY_BUFFER        = 'ArrayBuffer'
    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
    , PROTOTYPE           = 'prototype'
    , ArrayProto          = Array[PROTOTYPE]
    , $ArrayBuffer        = $buffer.ArrayBuffer
    , $DataView           = $buffer.DataView
    , arrayForEach        = createArrayMethod(0)
    , arrayFilter         = createArrayMethod(2)
    , arraySome           = createArrayMethod(3)
    , arrayEvery          = createArrayMethod(4)
    , arrayFind           = createArrayMethod(5)
    , arrayFindIndex      = createArrayMethod(6)
    , arrayIncludes       = createArrayIncludes(true)
    , arrayIndexOf        = createArrayIncludes(false)
    , arrayValues         = ArrayIterators.values
    , arrayKeys           = ArrayIterators.keys
    , arrayEntries        = ArrayIterators.entries
    , arrayLastIndexOf    = ArrayProto.lastIndexOf
    , arrayReduce         = ArrayProto.reduce
    , arrayReduceRight    = ArrayProto.reduceRight
    , arrayJoin           = ArrayProto.join
    , arraySort           = ArrayProto.sort
    , arraySlice          = ArrayProto.slice
    , arrayToString       = ArrayProto.toString
    , arrayToLocaleString = ArrayProto.toLocaleString
    , ITERATOR            = wks('iterator')
    , TAG                 = wks('toStringTag')
    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
    , DEF_CONSTRUCTOR     = uid('def_constructor')
    , ALL_CONSTRUCTORS    = $typed.CONSTR
    , TYPED_ARRAY         = $typed.TYPED
    , VIEW                = $typed.VIEW
    , WRONG_LENGTH        = 'Wrong length!';

  var $map = createArrayMethod(1, function(O, length){
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function(){
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
    new Uint8Array(1).set({});
  });

  var strictToLength = function(it, SAME){
    if(it === undefined)throw TypeError(WRONG_LENGTH);
    var number = +it
      , length = toLength(it);
    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
    return length;
  };

  var toOffset = function(it, BYTES){
    var offset = toInteger(it);
    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function(it){
    if(isObject(it) && TYPED_ARRAY in it)return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function(C, length){
    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function(O, list){
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function(C, list){
    var index  = 0
      , length = list.length
      , result = allocate(C, length);
    while(length > index)result[index] = list[index++];
    return result;
  };

  var addGetter = function(it, key, internal){
    dP(it, key, {get: function(){ return this._d[internal]; }});
  };

  var $from = function from(source /*, mapfn, thisArg */){
    var O       = toObject(source)
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , iterFn  = getIterFn(O)
      , i, length, values, result, step, iterator;
    if(iterFn != undefined && !isArrayIter(iterFn)){
      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
        values.push(step.value);
      } O = values;
    }
    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/*...items*/){
    var index  = 0
      , length = arguments.length
      , result = allocate(this, length);
    while(length > index)result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString(){
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /*, end */){
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /*, thisArg */){
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /*, thisArg */){
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /*, thisArg */){
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /*, thisArg */){
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /*, thisArg */){
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /*, fromIndex */){
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /*, fromIndex */){
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator){ // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /*, thisArg */){
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse(){
      var that   = this
        , length = validate(that).length
        , middle = Math.floor(length / 2)
        , index  = 0
        , value;
      while(index < middle){
        value         = that[index];
        that[index++] = that[--length];
        that[length]  = value;
      } return that;
    },
    some: function some(callbackfn /*, thisArg */){
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn){
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end){
      var O      = validate(this)
        , length = O.length
        , $begin = toIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end){
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /*, offset */){
    validate(this);
    var offset = toOffset(arguments[1], 1)
      , length = this.length
      , src    = toObject(arrayLike)
      , len    = toLength(src.length)
      , index  = 0;
    if(len + offset > length)throw RangeError(WRONG_LENGTH);
    while(index < len)this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries(){
      return arrayEntries.call(validate(this));
    },
    keys: function keys(){
      return arrayKeys.call(validate(this));
    },
    values: function values(){
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function(target, key){
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key){
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc){
    if(isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ){
      target[key] = desc.value;
      return target;
    } else return dP(target, key, desc);
  };

  if(!ALL_CONSTRUCTORS){
    $GOPD.f = $getDesc;
    $DP.f   = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty:           $setDesc
  });

  if(fails(function(){ arrayToString.call({}); })){
    arrayToString = arrayToLocaleString = function toString(){
      return arrayJoin.call(this);
    }
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice:          $slice,
    set:            $set,
    constructor:    function(){ /* noop */ },
    toString:       arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function(){ return this[TYPED_ARRAY]; }
  });

  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
    CLAMPED = !!CLAMPED;
    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
      , ISNT_UINT8 = NAME != 'Uint8Array'
      , GETTER     = 'get' + KEY
      , SETTER     = 'set' + KEY
      , TypedArray = global[NAME]
      , Base       = TypedArray || {}
      , TAC        = TypedArray && getPrototypeOf(TypedArray)
      , FORCED     = !TypedArray || !$typed.ABV
      , O          = {}
      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function(that, index){
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function(that, index, value){
      var data = that._d;
      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function(that, index){
      dP(that, index, {
        get: function(){
          return getter(this, index);
        },
        set: function(value){
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if(FORCED){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME, '_d');
        var index  = 0
          , offset = 0
          , buffer, byteLength, length, klass;
        if(!isObject(data)){
          length     = strictToLength(data, true)
          byteLength = length * BYTES;
          buffer     = new $ArrayBuffer(byteLength);
        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if($length === undefined){
            if($len % BYTES)throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if(TYPED_ARRAY in data){
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while(index < length)addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if(!$iterDetect(function(iter){
      // V8 works with iterators, but fails in many other cases
      // https://code.google.com/p/v8/issues/detail?id=4552
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
      , $iterator         = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
      dP(TypedArrayPrototype, TAG, {
        get: function(){ return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES,
      from: $from,
      of: $of
    });

    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});

    $export($export.P + $export.F * fails(function(){
      new TypedArray(1).slice();
    }), NAME, {slice: $slice});

    $export($export.P + $export.F * (fails(function(){
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
    }) || !fails(function(){
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {toLocaleString: $toLocaleString});

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function(){ /* empty */ };
},{"./_an-instance":1018,"./_array-copy-within":1020,"./_array-fill":1021,"./_array-includes":1023,"./_array-methods":1024,"./_classof":1029,"./_ctx":1037,"./_descriptors":1040,"./_export":1044,"./_fails":1046,"./_global":1050,"./_has":1051,"./_hide":1052,"./_is-array-iter":1058,"./_is-object":1061,"./_iter-detect":1066,"./_iterators":1068,"./_library":1070,"./_object-create":1078,"./_object-dp":1079,"./_object-gopd":1082,"./_object-gopn":1084,"./_object-gpo":1086,"./_property-desc":1097,"./_redefine-all":1098,"./_same-value":1101,"./_set-species":1103,"./_species-constructor":1107,"./_to-index":1117,"./_to-integer":1118,"./_to-length":1120,"./_to-object":1121,"./_to-primitive":1122,"./_typed":1125,"./_typed-buffer":1124,"./_uid":1126,"./_wks":1129,"./core.get-iterator-method":1130,"./es6.array.iterator":1142}],1124:[function(require,module,exports){
'use strict';
var global         = require('./_global')
  , DESCRIPTORS    = require('./_descriptors')
  , LIBRARY        = require('./_library')
  , $typed         = require('./_typed')
  , hide           = require('./_hide')
  , redefineAll    = require('./_redefine-all')
  , fails          = require('./_fails')
  , anInstance     = require('./_an-instance')
  , toInteger      = require('./_to-integer')
  , toLength       = require('./_to-length')
  , gOPN           = require('./_object-gopn').f
  , dP             = require('./_object-dp').f
  , arrayFill      = require('./_array-fill')
  , setToStringTag = require('./_set-to-string-tag')
  , ARRAY_BUFFER   = 'ArrayBuffer'
  , DATA_VIEW      = 'DataView'
  , PROTOTYPE      = 'prototype'
  , WRONG_LENGTH   = 'Wrong length!'
  , WRONG_INDEX    = 'Wrong index!'
  , $ArrayBuffer   = global[ARRAY_BUFFER]
  , $DataView      = global[DATA_VIEW]
  , Math           = global.Math
  , RangeError     = global.RangeError
  , Infinity       = global.Infinity
  , BaseBuffer     = $ArrayBuffer
  , abs            = Math.abs
  , pow            = Math.pow
  , floor          = Math.floor
  , log            = Math.log
  , LN2            = Math.LN2
  , BUFFER         = 'buffer'
  , BYTE_LENGTH    = 'byteLength'
  , BYTE_OFFSET    = 'byteOffset'
  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function(value, mLen, nBytes){
  var buffer = Array(nBytes)
    , eLen   = nBytes * 8 - mLen - 1
    , eMax   = (1 << eLen) - 1
    , eBias  = eMax >> 1
    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
    , i      = 0
    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
    , e, m, c;
  value = abs(value)
  if(value != value || value === Infinity){
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if(value * (c = pow(2, -e)) < 1){
      e--;
      c *= 2;
    }
    if(e + eBias >= 1){
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if(value * c >= 2){
      e++;
      c /= 2;
    }
    if(e + eBias >= eMax){
      m = 0;
      e = eMax;
    } else if(e + eBias >= 1){
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
};
var unpackIEEE754 = function(buffer, mLen, nBytes){
  var eLen  = nBytes * 8 - mLen - 1
    , eMax  = (1 << eLen) - 1
    , eBias = eMax >> 1
    , nBits = eLen - 7
    , i     = nBytes - 1
    , s     = buffer[i--]
    , e     = s & 127
    , m;
  s >>= 7;
  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if(e === 0){
    e = 1 - eBias;
  } else if(e === eMax){
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
};

var unpackI32 = function(bytes){
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
};
var packI8 = function(it){
  return [it & 0xff];
};
var packI16 = function(it){
  return [it & 0xff, it >> 8 & 0xff];
};
var packI32 = function(it){
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
};
var packF64 = function(it){
  return packIEEE754(it, 52, 8);
};
var packF32 = function(it){
  return packIEEE754(it, 23, 4);
};

var addGetter = function(C, key, internal){
  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
};

var get = function(view, bytes, index, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
};
var set = function(view, bytes, index, conversion, value, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = conversion(+value);
  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
};

var validateArrayBufferArguments = function(that, length){
  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
  var numberLength = +length
    , byteLength   = toLength(numberLength);
  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
  return byteLength;
};

if(!$typed.ABV){
  $ArrayBuffer = function ArrayBuffer(length){
    var byteLength = validateArrayBufferArguments(this, length);
    this._b       = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength){
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH]
      , offset       = toInteger(byteOffset);
    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if(DESCRIPTORS){
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset){
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset){
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if(!fails(function(){
    new $ArrayBuffer;     // eslint-disable-line no-new
  }) || !fails(function(){
    new $ArrayBuffer(.5); // eslint-disable-line no-new
  })){
    $ArrayBuffer = function ArrayBuffer(length){
      return new BaseBuffer(validateArrayBufferArguments(this, length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
    };
    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2))
    , $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;
},{"./_an-instance":1018,"./_array-fill":1021,"./_descriptors":1040,"./_fails":1046,"./_global":1050,"./_hide":1052,"./_library":1070,"./_object-dp":1079,"./_object-gopn":1084,"./_redefine-all":1098,"./_set-to-string-tag":1104,"./_to-integer":1118,"./_to-length":1120,"./_typed":1125}],1125:[function(require,module,exports){
var global = require('./_global')
  , hide   = require('./_hide')
  , uid    = require('./_uid')
  , TYPED  = uid('typed_array')
  , VIEW   = uid('view')
  , ABV    = !!(global.ArrayBuffer && global.DataView)
  , CONSTR = ABV
  , i = 0, l = 9, Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while(i < l){
  if(Typed = global[TypedArrayConstructors[i++]]){
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV:    ABV,
  CONSTR: CONSTR,
  TYPED:  TYPED,
  VIEW:   VIEW
};
},{"./_global":1050,"./_hide":1052,"./_uid":1126}],1126:[function(require,module,exports){
arguments[4][978][0].apply(exports,arguments)
},{"dup":978}],1127:[function(require,module,exports){
arguments[4][979][0].apply(exports,arguments)
},{"./_core":1035,"./_global":1050,"./_library":1070,"./_object-dp":1079,"./_wks-ext":1128,"dup":979}],1128:[function(require,module,exports){
arguments[4][980][0].apply(exports,arguments)
},{"./_wks":1129,"dup":980}],1129:[function(require,module,exports){
arguments[4][981][0].apply(exports,arguments)
},{"./_global":1050,"./_shared":1106,"./_uid":1126,"dup":981}],1130:[function(require,module,exports){
arguments[4][982][0].apply(exports,arguments)
},{"./_classof":1029,"./_core":1035,"./_iterators":1068,"./_wks":1129,"dup":982}],1131:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export')
  , $re     = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});

},{"./_export":1044,"./_replacer":1100}],1132:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', {copyWithin: require('./_array-copy-within')});

require('./_add-to-unscopables')('copyWithin');
},{"./_add-to-unscopables":1017,"./_array-copy-within":1020,"./_export":1044}],1133:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $every  = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */){
    return $every(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":1024,"./_export":1044,"./_strict-method":1108}],1134:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', {fill: require('./_array-fill')});

require('./_add-to-unscopables')('fill');
},{"./_add-to-unscopables":1017,"./_array-fill":1021,"./_export":1044}],1135:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */){
    return $filter(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":1024,"./_export":1044,"./_strict-method":1108}],1136:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(6)
  , KEY     = 'findIndex'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":1017,"./_array-methods":1024,"./_export":1044}],1137:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":1017,"./_array-methods":1024,"./_export":1044}],1138:[function(require,module,exports){
'use strict';
var $export  = require('./_export')
  , $forEach = require('./_array-methods')(0)
  , STRICT   = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":1024,"./_export":1044,"./_strict-method":1108}],1139:[function(require,module,exports){
arguments[4][985][0].apply(exports,arguments)
},{"./_create-property":1036,"./_ctx":1037,"./_export":1044,"./_is-array-iter":1058,"./_iter-call":1063,"./_iter-detect":1066,"./_to-length":1120,"./_to-object":1121,"./core.get-iterator-method":1130,"dup":985}],1140:[function(require,module,exports){
'use strict';
var $export       = require('./_export')
  , $indexOf      = require('./_array-includes')(false)
  , $native       = [].indexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});
},{"./_array-includes":1023,"./_export":1044,"./_strict-method":1108}],1141:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', {isArray: require('./_is-array')});
},{"./_export":1044,"./_is-array":1059}],1142:[function(require,module,exports){
arguments[4][986][0].apply(exports,arguments)
},{"./_add-to-unscopables":1017,"./_iter-define":1065,"./_iter-step":1067,"./_iterators":1068,"./_to-iobject":1119,"dup":986}],1143:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export   = require('./_export')
  , toIObject = require('./_to-iobject')
  , arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator){
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});
},{"./_export":1044,"./_iobject":1057,"./_strict-method":1108,"./_to-iobject":1119}],1144:[function(require,module,exports){
'use strict';
var $export       = require('./_export')
  , toIObject     = require('./_to-iobject')
  , toInteger     = require('./_to-integer')
  , toLength      = require('./_to-length')
  , $native       = [].lastIndexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
    // convert -0 to +0
    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
    var O      = toIObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
    if(index < 0)index = length + index;
    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
    return -1;
  }
});
},{"./_export":1044,"./_strict-method":1108,"./_to-integer":1118,"./_to-iobject":1119,"./_to-length":1120}],1145:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $map    = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */){
    return $map(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":1024,"./_export":1044,"./_strict-method":1108}],1146:[function(require,module,exports){
'use strict';
var $export        = require('./_export')
  , createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function(){
  function F(){}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , aLen   = arguments.length
      , result = new (typeof this == 'function' ? this : Array)(aLen);
    while(aLen > index)createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});
},{"./_create-property":1036,"./_export":1044,"./_fails":1046}],1147:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});
},{"./_array-reduce":1025,"./_export":1044,"./_strict-method":1108}],1148:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
},{"./_array-reduce":1025,"./_export":1044,"./_strict-method":1108}],1149:[function(require,module,exports){
'use strict';
var $export    = require('./_export')
  , html       = require('./_html')
  , cof        = require('./_cof')
  , toIndex    = require('./_to-index')
  , toLength   = require('./_to-length')
  , arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function(){
  if(html)arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return arraySlice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});
},{"./_cof":1030,"./_export":1044,"./_fails":1046,"./_html":1053,"./_to-index":1117,"./_to-length":1120}],1150:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $some   = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */){
    return $some(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":1024,"./_export":1044,"./_strict-method":1108}],1151:[function(require,module,exports){
'use strict';
var $export   = require('./_export')
  , aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , fails     = require('./_fails')
  , $sort     = [].sort
  , test      = [1, 2, 3];

$export($export.P + $export.F * (fails(function(){
  // IE8-
  test.sort(undefined);
}) || !fails(function(){
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn){
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});
},{"./_a-function":1015,"./_export":1044,"./_fails":1046,"./_strict-method":1108,"./_to-object":1121}],1152:[function(require,module,exports){
require('./_set-species')('Array');
},{"./_set-species":1103}],1153:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});
},{"./_export":1044}],1154:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export')
  , fails   = require('./_fails')
  , getTime = Date.prototype.getTime;

var lz = function(num){
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (fails(function(){
  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
}) || !fails(function(){
  new Date(NaN).toISOString();
})), 'Date', {
  toISOString: function toISOString(){
    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
    var d = this
      , y = d.getUTCFullYear()
      , m = d.getUTCMilliseconds()
      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
  }
});
},{"./_export":1044,"./_fails":1046}],1155:[function(require,module,exports){
'use strict';
var $export     = require('./_export')
  , toObject    = require('./_to-object')
  , toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function(){
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
}), 'Date', {
  toJSON: function toJSON(key){
    var O  = toObject(this)
      , pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});
},{"./_export":1044,"./_fails":1046,"./_to-object":1121,"./_to-primitive":1122}],1156:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive')
  , proto        = Date.prototype;

if(!(TO_PRIMITIVE in proto))require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));
},{"./_date-to-primitive":1038,"./_hide":1052,"./_wks":1129}],1157:[function(require,module,exports){
var DateProto    = Date.prototype
  , INVALID_DATE = 'Invalid Date'
  , TO_STRING    = 'toString'
  , $toString    = DateProto[TO_STRING]
  , getTime      = DateProto.getTime;
if(new Date(NaN) + '' != INVALID_DATE){
  require('./_redefine')(DateProto, TO_STRING, function toString(){
    var value = getTime.call(this);
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}
},{"./_redefine":1099}],1158:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', {bind: require('./_bind')});
},{"./_bind":1028,"./_export":1044}],1159:[function(require,module,exports){
'use strict';
var isObject       = require('./_is-object')
  , getPrototypeOf = require('./_object-gpo')
  , HAS_INSTANCE   = require('./_wks')('hasInstance')
  , FunctionProto  = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))require('./_object-dp').f(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(typeof this != 'function' || !isObject(O))return false;
  if(!isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
  return false;
}});
},{"./_is-object":1061,"./_object-dp":1079,"./_object-gpo":1086,"./_wks":1129}],1160:[function(require,module,exports){
var dP         = require('./_object-dp').f
  , createDesc = require('./_property-desc')
  , has        = require('./_has')
  , FProto     = Function.prototype
  , nameRE     = /^\s*function ([^ (]*)/
  , NAME       = 'name';

var isExtensible = Object.isExtensible || function(){
  return true;
};

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function(){
    try {
      var that = this
        , name = ('' + that).match(nameRE)[1];
      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
      return name;
    } catch(e){
      return '';
    }
  }
});
},{"./_descriptors":1040,"./_has":1051,"./_object-dp":1079,"./_property-desc":1097}],1161:[function(require,module,exports){
arguments[4][987][0].apply(exports,arguments)
},{"./_collection":1034,"./_collection-strong":1031,"dup":987}],1162:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export')
  , log1p   = require('./_math-log1p')
  , sqrt    = Math.sqrt
  , $acosh  = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});
},{"./_export":1044,"./_math-log1p":1072}],1163:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export')
  , $asinh  = Math.asinh;

function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});
},{"./_export":1044}],1164:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export')
  , $atanh  = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});
},{"./_export":1044}],1165:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export')
  , sign    = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x){
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});
},{"./_export":1044,"./_math-sign":1073}],1166:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});
},{"./_export":1044}],1167:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export')
  , exp     = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  }
});
},{"./_export":1044}],1168:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export')
  , $expm1  = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});
},{"./_export":1044,"./_math-expm1":1071}],1169:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export   = require('./_export')
  , sign      = require('./_math-sign')
  , pow       = Math.pow
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);

var roundTiesToEven = function(n){
  return n + 1 / EPSILON - 1 / EPSILON;
};


$export($export.S, 'Math', {
  fround: function fround(x){
    var $abs  = Math.abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  }
});
},{"./_export":1044,"./_math-sign":1073}],1170:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = require('./_export')
  , abs     = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , aLen = arguments.length
      , larg = 0
      , arg, div;
    while(i < aLen){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});
},{"./_export":1044}],1171:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export')
  , $imul   = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function(){
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y){
    var UINT16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UINT16 & xn
      , yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});
},{"./_export":1044,"./_fails":1046}],1172:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});
},{"./_export":1044}],1173:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', {log1p: require('./_math-log1p')});
},{"./_export":1044,"./_math-log1p":1072}],1174:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});
},{"./_export":1044}],1175:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', {sign: require('./_math-sign')});
},{"./_export":1044,"./_math-sign":1073}],1176:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export')
  , expm1   = require('./_math-expm1')
  , exp     = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function(){
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x){
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});
},{"./_export":1044,"./_fails":1046,"./_math-expm1":1071}],1177:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export')
  , expm1   = require('./_math-expm1')
  , exp     = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});
},{"./_export":1044,"./_math-expm1":1071}],1178:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it){
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});
},{"./_export":1044}],1179:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , has               = require('./_has')
  , cof               = require('./_cof')
  , inheritIfRequired = require('./_inherit-if-required')
  , toPrimitive       = require('./_to-primitive')
  , fails             = require('./_fails')
  , gOPN              = require('./_object-gopn').f
  , gOPD              = require('./_object-gopd').f
  , dP                = require('./_object-dp').f
  , $trim             = require('./_string-trim').trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}
},{"./_cof":1030,"./_descriptors":1040,"./_fails":1046,"./_global":1050,"./_has":1051,"./_inherit-if-required":1055,"./_object-create":1078,"./_object-dp":1079,"./_object-gopd":1082,"./_object-gopn":1084,"./_redefine":1099,"./_string-trim":1114,"./_to-primitive":1122}],1180:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});
},{"./_export":1044}],1181:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export   = require('./_export')
  , _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  }
});
},{"./_export":1044,"./_global":1050}],1182:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', {isInteger: require('./_is-integer')});
},{"./_export":1044,"./_is-integer":1060}],1183:[function(require,module,exports){
arguments[4][988][0].apply(exports,arguments)
},{"./_export":1044,"dup":988}],1184:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export   = require('./_export')
  , isInteger = require('./_is-integer')
  , abs       = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});
},{"./_export":1044,"./_is-integer":1060}],1185:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
},{"./_export":1044}],1186:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
},{"./_export":1044}],1187:[function(require,module,exports){
var $export     = require('./_export')
  , $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});
},{"./_export":1044,"./_parse-float":1093}],1188:[function(require,module,exports){
var $export   = require('./_export')
  , $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});
},{"./_export":1044,"./_parse-int":1094}],1189:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , toInteger    = require('./_to-integer')
  , aNumberValue = require('./_a-number-value')
  , repeat       = require('./_string-repeat')
  , $toFixed     = 1..toFixed
  , floor        = Math.floor
  , data         = [0, 0, 0, 0, 0, 0]
  , ERROR        = 'Number.toFixed: incorrect invocation!'
  , ZERO         = '0';

var multiply = function(n, c){
  var i  = -1
    , c2 = c;
  while(++i < 6){
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function(n){
  var i = 6
    , c = 0;
  while(--i >= 0){
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function(){
  var i = 6
    , s = '';
  while(--i >= 0){
    if(s !== '' || i === 0 || data[i] !== 0){
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function(x, n, acc){
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x){
  var n  = 0
    , x2 = x;
  while(x2 >= 4096){
    n += 12;
    x2 /= 4096;
  }
  while(x2 >= 2){
    n  += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128..toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function(){
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits){
    var x = aNumberValue(this, ERROR)
      , f = toInteger(fractionDigits)
      , s = ''
      , m = ZERO
      , e, z, j, k;
    if(f < 0 || f > 20)throw RangeError(ERROR);
    if(x != x)return 'NaN';
    if(x <= -1e21 || x >= 1e21)return String(x);
    if(x < 0){
      s = '-';
      x = -x;
    }
    if(x > 1e-21){
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if(e > 0){
        multiply(0, z);
        j = f;
        while(j >= 7){
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while(j >= 23){
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if(f > 0){
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});
},{"./_a-number-value":1016,"./_export":1044,"./_fails":1046,"./_string-repeat":1113,"./_to-integer":1118}],1190:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , $fails       = require('./_fails')
  , aNumberValue = require('./_a-number-value')
  , $toPrecision = 1..toPrecision;

$export($export.P + $export.F * ($fails(function(){
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function(){
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision){
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});
},{"./_a-number-value":1016,"./_export":1044,"./_fails":1046}],1191:[function(require,module,exports){
arguments[4][989][0].apply(exports,arguments)
},{"./_export":1044,"./_object-assign":1077,"dup":989}],1192:[function(require,module,exports){
arguments[4][990][0].apply(exports,arguments)
},{"./_export":1044,"./_object-create":1078,"dup":990}],1193:[function(require,module,exports){
arguments[4][991][0].apply(exports,arguments)
},{"./_descriptors":1040,"./_export":1044,"./_object-dps":1080,"dup":991}],1194:[function(require,module,exports){
arguments[4][992][0].apply(exports,arguments)
},{"./_descriptors":1040,"./_export":1044,"./_object-dp":1079,"dup":992}],1195:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});
},{"./_is-object":1061,"./_meta":1074,"./_object-sap":1090}],1196:[function(require,module,exports){
arguments[4][993][0].apply(exports,arguments)
},{"./_object-gopd":1082,"./_object-sap":1090,"./_to-iobject":1119,"dup":993}],1197:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function(){
  return require('./_object-gopn-ext').f;
});
},{"./_object-gopn-ext":1083,"./_object-sap":1090}],1198:[function(require,module,exports){
arguments[4][994][0].apply(exports,arguments)
},{"./_object-gpo":1086,"./_object-sap":1090,"./_to-object":1121,"dup":994}],1199:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function($isExtensible){
  return function isExtensible(it){
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});
},{"./_is-object":1061,"./_object-sap":1090}],1200:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function($isFrozen){
  return function isFrozen(it){
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});
},{"./_is-object":1061,"./_object-sap":1090}],1201:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function($isSealed){
  return function isSealed(it){
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});
},{"./_is-object":1061,"./_object-sap":1090}],1202:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', {is: require('./_same-value')});
},{"./_export":1044,"./_same-value":1101}],1203:[function(require,module,exports){
arguments[4][995][0].apply(exports,arguments)
},{"./_object-keys":1088,"./_object-sap":1090,"./_to-object":1121,"dup":995}],1204:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function($preventExtensions){
  return function preventExtensions(it){
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});
},{"./_is-object":1061,"./_meta":1074,"./_object-sap":1090}],1205:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('seal', function($seal){
  return function seal(it){
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});
},{"./_is-object":1061,"./_meta":1074,"./_object-sap":1090}],1206:[function(require,module,exports){
arguments[4][996][0].apply(exports,arguments)
},{"./_export":1044,"./_set-proto":1102,"dup":996}],1207:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof')
  , test    = {};
test[require('./_wks')('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  require('./_redefine')(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}
},{"./_classof":1029,"./_redefine":1099,"./_wks":1129}],1208:[function(require,module,exports){
var $export     = require('./_export')
  , $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});
},{"./_export":1044,"./_parse-float":1093}],1209:[function(require,module,exports){
var $export   = require('./_export')
  , $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});
},{"./_export":1044,"./_parse-int":1094}],1210:[function(require,module,exports){
arguments[4][998][0].apply(exports,arguments)
},{"./_a-function":1015,"./_an-instance":1018,"./_classof":1029,"./_core":1035,"./_ctx":1037,"./_export":1044,"./_for-of":1049,"./_global":1050,"./_is-object":1061,"./_iter-detect":1066,"./_library":1070,"./_microtask":1076,"./_redefine-all":1098,"./_set-species":1103,"./_set-to-string-tag":1104,"./_species-constructor":1107,"./_task":1116,"./_wks":1129,"dup":998}],1211:[function(require,module,exports){
arguments[4][999][0].apply(exports,arguments)
},{"./_a-function":1015,"./_an-object":1019,"./_export":1044,"./_fails":1046,"./_global":1050,"dup":999}],1212:[function(require,module,exports){
arguments[4][1000][0].apply(exports,arguments)
},{"./_a-function":1015,"./_an-object":1019,"./_bind":1028,"./_export":1044,"./_fails":1046,"./_global":1050,"./_is-object":1061,"./_object-create":1078,"dup":1000}],1213:[function(require,module,exports){
arguments[4][1001][0].apply(exports,arguments)
},{"./_an-object":1019,"./_export":1044,"./_fails":1046,"./_object-dp":1079,"./_to-primitive":1122,"dup":1001}],1214:[function(require,module,exports){
arguments[4][1002][0].apply(exports,arguments)
},{"./_an-object":1019,"./_export":1044,"./_object-gopd":1082,"dup":1002}],1215:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export  = require('./_export')
  , anObject = require('./_an-object');
var Enumerate = function(iterated){
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = []       // keys
    , key;
  for(key in iterated)keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function(){
  var that = this
    , keys = that._k
    , key;
  do {
    if(that._i >= keys.length)return {value: undefined, done: true};
  } while(!((key = keys[that._i++]) in that._t));
  return {value: key, done: false};
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target){
    return new Enumerate(target);
  }
});
},{"./_an-object":1019,"./_export":1044,"./_iter-create":1064}],1216:[function(require,module,exports){
arguments[4][1003][0].apply(exports,arguments)
},{"./_an-object":1019,"./_export":1044,"./_object-gopd":1082,"dup":1003}],1217:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export  = require('./_export')
  , getProto = require('./_object-gpo')
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(anObject(target));
  }
});
},{"./_an-object":1019,"./_export":1044,"./_object-gpo":1086}],1218:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD           = require('./_object-gopd')
  , getPrototypeOf = require('./_object-gpo')
  , has            = require('./_has')
  , $export        = require('./_export')
  , isObject       = require('./_is-object')
  , anObject       = require('./_an-object');

function get(target, propertyKey/*, receiver*/){
  var receiver = arguments.length < 3 ? target : arguments[2]
    , desc, proto;
  if(anObject(target) === receiver)return target[propertyKey];
  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {get: get});
},{"./_an-object":1019,"./_export":1044,"./_has":1051,"./_is-object":1061,"./_object-gopd":1082,"./_object-gpo":1086}],1219:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey){
    return propertyKey in target;
  }
});
},{"./_export":1044}],1220:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export       = require('./_export')
  , anObject      = require('./_an-object')
  , $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target){
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});
},{"./_an-object":1019,"./_export":1044}],1221:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', {ownKeys: require('./_own-keys')});
},{"./_export":1044,"./_own-keys":1092}],1222:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export            = require('./_export')
  , anObject           = require('./_an-object')
  , $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target){
    anObject(target);
    try {
      if($preventExtensions)$preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_an-object":1019,"./_export":1044}],1223:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export  = require('./_export')
  , setProto = require('./_set-proto');

if(setProto)$export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto){
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_export":1044,"./_set-proto":1102}],1224:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP             = require('./_object-dp')
  , gOPD           = require('./_object-gopd')
  , getPrototypeOf = require('./_object-gpo')
  , has            = require('./_has')
  , $export        = require('./_export')
  , createDesc     = require('./_property-desc')
  , anObject       = require('./_an-object')
  , isObject       = require('./_is-object');

function set(target, propertyKey, V/*, receiver*/){
  var receiver = arguments.length < 4 ? target : arguments[3]
    , ownDesc  = gOPD.f(anObject(target), propertyKey)
    , existingDescriptor, proto;
  if(!ownDesc){
    if(isObject(proto = getPrototypeOf(target))){
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if(has(ownDesc, 'value')){
    if(ownDesc.writable === false || !isObject(receiver))return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {set: set});
},{"./_an-object":1019,"./_export":1044,"./_has":1051,"./_is-object":1061,"./_object-dp":1079,"./_object-gopd":1082,"./_object-gpo":1086,"./_property-desc":1097}],1225:[function(require,module,exports){
var global            = require('./_global')
  , inheritIfRequired = require('./_inherit-if-required')
  , dP                = require('./_object-dp').f
  , gOPN              = require('./_object-gopn').f
  , isRegExp          = require('./_is-regexp')
  , $flags            = require('./_flags')
  , $RegExp           = global.RegExp
  , Base              = $RegExp
  , proto             = $RegExp.prototype
  , re1               = /a/g
  , re2               = /a/g
  // "new" creates a new object, old webkit buggy here
  , CORRECT_NEW       = new $RegExp(re1) !== re1;

if(require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function(){
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))){
  $RegExp = function RegExp(p, f){
    var tiRE = this instanceof $RegExp
      , piRE = isRegExp(p)
      , fiU  = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function(key){
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function(){ return Base[key]; },
      set: function(it){ Base[key] = it; }
    });
  };
  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');
},{"./_descriptors":1040,"./_fails":1046,"./_flags":1048,"./_global":1050,"./_inherit-if-required":1055,"./_is-regexp":1062,"./_object-dp":1079,"./_object-gopn":1084,"./_redefine":1099,"./_set-species":1103,"./_wks":1129}],1226:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if(require('./_descriptors') && /./g.flags != 'g')require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});
},{"./_descriptors":1040,"./_flags":1048,"./_object-dp":1079}],1227:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function(defined, MATCH, $match){
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});
},{"./_fix-re-wks":1047}],1228:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function(defined, REPLACE, $replace){
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue){
    'use strict';
    var O  = defined(this)
      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});
},{"./_fix-re-wks":1047}],1229:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function(defined, SEARCH, $search){
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});
},{"./_fix-re-wks":1047}],1230:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function(defined, SPLIT, $split){
  'use strict';
  var isRegExp   = require('./_is-regexp')
    , _split     = $split
    , $push      = [].push
    , $SPLIT     = 'split'
    , LENGTH     = 'length'
    , LAST_INDEX = 'lastIndex';
  if(
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ){
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function(separator, limit){
      var string = String(this);
      if(separator === undefined && limit === 0)return [];
      // If `separator` is not a regex, use native split
      if(!isRegExp(separator))return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while(match = separatorCopy.exec(string)){
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if(lastIndex > lastLastIndex){
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
          });
          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if(output[LENGTH] >= splitLimit)break;
        }
        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if(lastLastIndex === string[LENGTH]){
        if(lastLength || !separatorCopy.test(''))output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
    $split = function(separator, limit){
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit){
    var O  = defined(this)
      , fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});
},{"./_fix-re-wks":1047,"./_is-regexp":1062}],1231:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject    = require('./_an-object')
  , $flags      = require('./_flags')
  , DESCRIPTORS = require('./_descriptors')
  , TO_STRING   = 'toString'
  , $toString   = /./[TO_STRING];

var define = function(fn){
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if(require('./_fails')(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
  define(function toString(){
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if($toString.name != TO_STRING){
  define(function toString(){
    return $toString.call(this);
  });
}
},{"./_an-object":1019,"./_descriptors":1040,"./_fails":1046,"./_flags":1048,"./_redefine":1099,"./es6.regexp.flags":1226}],1232:[function(require,module,exports){
arguments[4][1004][0].apply(exports,arguments)
},{"./_collection":1034,"./_collection-strong":1031,"dup":1004}],1233:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function(createHTML){
  return function anchor(name){
    return createHTML(this, 'a', 'name', name);
  }
});
},{"./_string-html":1111}],1234:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function(createHTML){
  return function big(){
    return createHTML(this, 'big', '', '');
  }
});
},{"./_string-html":1111}],1235:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function(createHTML){
  return function blink(){
    return createHTML(this, 'blink', '', '');
  }
});
},{"./_string-html":1111}],1236:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function(createHTML){
  return function bold(){
    return createHTML(this, 'b', '', '');
  }
});
},{"./_string-html":1111}],1237:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $at     = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
},{"./_export":1044,"./_string-at":1109}],1238:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export   = require('./_export')
  , toLength  = require('./_to-length')
  , context   = require('./_string-context')
  , ENDS_WITH = 'endsWith'
  , $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    var that = context(this, searchString, ENDS_WITH)
      , endPosition = arguments.length > 1 ? arguments[1] : undefined
      , len    = toLength(that.length)
      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
      , search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});
},{"./_export":1044,"./_fails-is-regexp":1045,"./_string-context":1110,"./_to-length":1120}],1239:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function(createHTML){
  return function fixed(){
    return createHTML(this, 'tt', '', '');
  }
});
},{"./_string-html":1111}],1240:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function(createHTML){
  return function fontcolor(color){
    return createHTML(this, 'font', 'color', color);
  }
});
},{"./_string-html":1111}],1241:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function(createHTML){
  return function fontsize(size){
    return createHTML(this, 'font', 'size', size);
  }
});
},{"./_string-html":1111}],1242:[function(require,module,exports){
var $export        = require('./_export')
  , toIndex        = require('./_to-index')
  , fromCharCode   = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res  = []
      , aLen = arguments.length
      , i    = 0
      , code;
    while(aLen > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
},{"./_export":1044,"./_to-index":1117}],1243:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export  = require('./_export')
  , context  = require('./_string-context')
  , INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /*, position = 0 */){
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});
},{"./_export":1044,"./_fails-is-regexp":1045,"./_string-context":1110}],1244:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function(createHTML){
  return function italics(){
    return createHTML(this, 'i', '', '');
  }
});
},{"./_string-html":1111}],1245:[function(require,module,exports){
arguments[4][1005][0].apply(exports,arguments)
},{"./_iter-define":1065,"./_string-at":1109,"dup":1005}],1246:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function(createHTML){
  return function link(url){
    return createHTML(this, 'a', 'href', url);
  }
});
},{"./_string-html":1111}],1247:[function(require,module,exports){
var $export   = require('./_export')
  , toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl  = toIObject(callSite.raw)
      , len  = toLength(tpl.length)
      , aLen = arguments.length
      , res  = []
      , i    = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < aLen)res.push(String(arguments[i]));
    } return res.join('');
  }
});
},{"./_export":1044,"./_to-iobject":1119,"./_to-length":1120}],1248:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});
},{"./_export":1044,"./_string-repeat":1113}],1249:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function(createHTML){
  return function small(){
    return createHTML(this, 'small', '', '');
  }
});
},{"./_string-html":1111}],1250:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export     = require('./_export')
  , toLength    = require('./_to-length')
  , context     = require('./_string-context')
  , STARTS_WITH = 'startsWith'
  , $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /*, position = 0 */){
    var that   = context(this, searchString, STARTS_WITH)
      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
      , search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});
},{"./_export":1044,"./_fails-is-regexp":1045,"./_string-context":1110,"./_to-length":1120}],1251:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function(createHTML){
  return function strike(){
    return createHTML(this, 'strike', '', '');
  }
});
},{"./_string-html":1111}],1252:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function(createHTML){
  return function sub(){
    return createHTML(this, 'sub', '', '');
  }
});
},{"./_string-html":1111}],1253:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function(createHTML){
  return function sup(){
    return createHTML(this, 'sup', '', '');
  }
});
},{"./_string-html":1111}],1254:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function($trim){
  return function trim(){
    return $trim(this, 3);
  };
});
},{"./_string-trim":1114}],1255:[function(require,module,exports){
arguments[4][1006][0].apply(exports,arguments)
},{"./_an-object":1019,"./_descriptors":1040,"./_enum-keys":1043,"./_export":1044,"./_fails":1046,"./_global":1050,"./_has":1051,"./_hide":1052,"./_is-array":1059,"./_keyof":1069,"./_library":1070,"./_meta":1074,"./_object-create":1078,"./_object-dp":1079,"./_object-gopd":1082,"./_object-gopn":1084,"./_object-gopn-ext":1083,"./_object-gops":1085,"./_object-keys":1088,"./_object-pie":1089,"./_property-desc":1097,"./_redefine":1099,"./_set-to-string-tag":1104,"./_shared":1106,"./_to-iobject":1119,"./_to-primitive":1122,"./_uid":1126,"./_wks":1129,"./_wks-define":1127,"./_wks-ext":1128,"dup":1006}],1256:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , $typed       = require('./_typed')
  , buffer       = require('./_typed-buffer')
  , anObject     = require('./_an-object')
  , toIndex      = require('./_to-index')
  , toLength     = require('./_to-length')
  , isObject     = require('./_is-object')
  , ArrayBuffer  = require('./_global').ArrayBuffer
  , speciesConstructor = require('./_species-constructor')
  , $ArrayBuffer = buffer.ArrayBuffer
  , $DataView    = buffer.DataView
  , $isView      = $typed.ABV && ArrayBuffer.isView
  , $slice       = $ArrayBuffer.prototype.slice
  , VIEW         = $typed.VIEW
  , ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it){
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function(){
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end){
    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
    var len    = anObject(this).byteLength
      , first  = toIndex(start, len)
      , final  = toIndex(end === undefined ? len : end, len)
      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
      , viewS  = new $DataView(this)
      , viewT  = new $DataView(result)
      , index  = 0;
    while(first < final){
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);
},{"./_an-object":1019,"./_export":1044,"./_fails":1046,"./_global":1050,"./_is-object":1061,"./_set-species":1103,"./_species-constructor":1107,"./_to-index":1117,"./_to-length":1120,"./_typed":1125,"./_typed-buffer":1124}],1257:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});
},{"./_export":1044,"./_typed":1125,"./_typed-buffer":1124}],1258:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function(init){
  return function Float32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":1123}],1259:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function(init){
  return function Float64Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":1123}],1260:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function(init){
  return function Int16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":1123}],1261:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function(init){
  return function Int32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":1123}],1262:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function(init){
  return function Int8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":1123}],1263:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function(init){
  return function Uint16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":1123}],1264:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function(init){
  return function Uint32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":1123}],1265:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function(init){
  return function Uint8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":1123}],1266:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function(init){
  return function Uint8ClampedArray(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
}, true);
},{"./_typed-array":1123}],1267:[function(require,module,exports){
arguments[4][1007][0].apply(exports,arguments)
},{"./_array-methods":1024,"./_collection":1034,"./_collection-weak":1033,"./_is-object":1061,"./_meta":1074,"./_object-assign":1077,"./_redefine":1099,"dup":1007}],1268:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');

// 23.4 WeakSet Objects
require('./_collection')('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
},{"./_collection":1034,"./_collection-weak":1033}],1269:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export   = require('./_export')
  , $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');
},{"./_add-to-unscopables":1017,"./_array-includes":1023,"./_export":1044}],1270:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export   = require('./_export')
  , microtask = require('./_microtask')()
  , process   = require('./_global').process
  , isNode    = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn){
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});
},{"./_cof":1030,"./_export":1044,"./_global":1050,"./_microtask":1076}],1271:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export')
  , cof     = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it){
    return cof(it) === 'Error';
  }
});
},{"./_cof":1030,"./_export":1044}],1272:[function(require,module,exports){
arguments[4][1008][0].apply(exports,arguments)
},{"./_collection-to-json":1032,"./_export":1044,"dup":1008}],1273:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});
},{"./_export":1044}],1274:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >> 16
      , v1 = $v >> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});
},{"./_export":1044}],1275:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});
},{"./_export":1044}],1276:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >>> 16
      , v1 = $v >>> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});
},{"./_export":1044}],1277:[function(require,module,exports){
'use strict';
var $export         = require('./_export')
  , toObject        = require('./_to-object')
  , aFunction       = require('./_a-function')
  , $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter){
    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
  }
});
},{"./_a-function":1015,"./_descriptors":1040,"./_export":1044,"./_object-dp":1079,"./_object-forced-pam":1081,"./_to-object":1121}],1278:[function(require,module,exports){
'use strict';
var $export         = require('./_export')
  , toObject        = require('./_to-object')
  , aFunction       = require('./_a-function')
  , $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter){
    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
  }
});
},{"./_a-function":1015,"./_descriptors":1040,"./_export":1044,"./_object-dp":1079,"./_object-forced-pam":1081,"./_to-object":1121}],1279:[function(require,module,exports){
arguments[4][1009][0].apply(exports,arguments)
},{"./_export":1044,"./_object-to-array":1091,"dup":1009}],1280:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export        = require('./_export')
  , ownKeys        = require('./_own-keys')
  , toIObject      = require('./_to-iobject')
  , gOPD           = require('./_object-gopd')
  , createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O       = toIObject(object)
      , getDesc = gOPD.f
      , keys    = ownKeys(O)
      , result  = {}
      , i       = 0
      , key;
    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
    return result;
  }
});
},{"./_create-property":1036,"./_export":1044,"./_object-gopd":1082,"./_own-keys":1092,"./_to-iobject":1119}],1281:[function(require,module,exports){
'use strict';
var $export                  = require('./_export')
  , toObject                 = require('./_to-object')
  , toPrimitive              = require('./_to-primitive')
  , getPrototypeOf           = require('./_object-gpo')
  , getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.get;
    } while(O = getPrototypeOf(O));
  }
});
},{"./_descriptors":1040,"./_export":1044,"./_object-forced-pam":1081,"./_object-gopd":1082,"./_object-gpo":1086,"./_to-object":1121,"./_to-primitive":1122}],1282:[function(require,module,exports){
'use strict';
var $export                  = require('./_export')
  , toObject                 = require('./_to-object')
  , toPrimitive              = require('./_to-primitive')
  , getPrototypeOf           = require('./_object-gpo')
  , getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.set;
    } while(O = getPrototypeOf(O));
  }
});
},{"./_descriptors":1040,"./_export":1044,"./_object-forced-pam":1081,"./_object-gopd":1082,"./_object-gpo":1086,"./_to-object":1121,"./_to-primitive":1122}],1283:[function(require,module,exports){
arguments[4][1010][0].apply(exports,arguments)
},{"./_export":1044,"./_object-to-array":1091,"dup":1010}],1284:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export     = require('./_export')
  , global      = require('./_global')
  , core        = require('./_core')
  , microtask   = require('./_microtask')()
  , OBSERVABLE  = require('./_wks')('observable')
  , aFunction   = require('./_a-function')
  , anObject    = require('./_an-object')
  , anInstance  = require('./_an-instance')
  , redefineAll = require('./_redefine-all')
  , hide        = require('./_hide')
  , forOf       = require('./_for-of')
  , RETURN      = forOf.RETURN;

var getMethod = function(fn){
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function(subscription){
  var cleanup = subscription._c;
  if(cleanup){
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function(subscription){
  return subscription._o === undefined;
};

var closeSubscription = function(subscription){
  if(!subscriptionClosed(subscription)){
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function(observer, subscriber){
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup      = subscriber(observer)
      , subscription = cleanup;
    if(cleanup != null){
      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch(e){
    observer.error(e);
    return;
  } if(subscriptionClosed(this))cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe(){ closeSubscription(this); }
});

var SubscriptionObserver = function(subscription){
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if(m)return m.call(observer, value);
      } catch(e){
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value){
    var subscription = this._s;
    if(subscriptionClosed(subscription))throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if(!m)throw value;
      value = m.call(observer, value);
    } catch(e){
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch(e){
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber){
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer){
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn){
    var that = this;
    return new (core.Promise || global.Promise)(function(resolve, reject){
      aFunction(fn);
      var subscription = that.subscribe({
        next : function(value){
          try {
            return fn(value);
          } catch(e){
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x){
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if(method){
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function(observer){
        return observable.subscribe(observer);
      });
    }
    return new C(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          try {
            if(forOf(x, false, function(it){
              observer.next(it);
              if(done)return RETURN;
            }) === RETURN)return;
          } catch(e){
            if(done)throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  },
  of: function of(){
    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          for(var i = 0; i < items.length; ++i){
            observer.next(items[i]);
            if(done)return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function(){ return this; });

$export($export.G, {Observable: $Observable});

require('./_set-species')('Observable');
},{"./_a-function":1015,"./_an-instance":1018,"./_an-object":1019,"./_core":1035,"./_export":1044,"./_for-of":1049,"./_global":1050,"./_hide":1052,"./_microtask":1076,"./_redefine-all":1098,"./_set-species":1103,"./_wks":1129}],1285:[function(require,module,exports){
var metadata                  = require('./_metadata')
  , anObject                  = require('./_an-object')
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
}});
},{"./_an-object":1019,"./_metadata":1075}],1286:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , toMetaKey              = metadata.key
  , getOrCreateMetadataMap = metadata.map
  , store                  = metadata.store;

metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
  if(metadataMap.size)return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
}});
},{"./_an-object":1019,"./_metadata":1075}],1287:[function(require,module,exports){
var Set                     = require('./es6.set')
  , from                    = require('./_array-from-iterable')
  , metadata                = require('./_metadata')
  , anObject                = require('./_an-object')
  , getPrototypeOf          = require('./_object-gpo')
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

var ordinaryMetadataKeys = function(O, P){
  var oKeys  = ordinaryOwnMetadataKeys(O, P)
    , parent = getPrototypeOf(O);
  if(parent === null)return oKeys;
  var pKeys  = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});
},{"./_an-object":1019,"./_array-from-iterable":1022,"./_metadata":1075,"./_object-gpo":1086,"./es6.set":1232}],1288:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , getPrototypeOf         = require('./_object-gpo')
  , ordinaryHasOwnMetadata = metadata.has
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

var ordinaryGetMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":1019,"./_metadata":1075,"./_object-gpo":1086}],1289:[function(require,module,exports){
var metadata                = require('./_metadata')
  , anObject                = require('./_an-object')
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});
},{"./_an-object":1019,"./_metadata":1075}],1290:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":1019,"./_metadata":1075}],1291:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , getPrototypeOf         = require('./_object-gpo')
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

var ordinaryHasMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":1019,"./_metadata":1075,"./_object-gpo":1086}],1292:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":1019,"./_metadata":1075}],1293:[function(require,module,exports){
var metadata                  = require('./_metadata')
  , anObject                  = require('./_an-object')
  , aFunction                 = require('./_a-function')
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({metadata: function metadata(metadataKey, metadataValue){
  return function decorator(target, targetKey){
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
}});
},{"./_a-function":1015,"./_an-object":1019,"./_metadata":1075}],1294:[function(require,module,exports){
arguments[4][1011][0].apply(exports,arguments)
},{"./_collection-to-json":1032,"./_export":1044,"dup":1011}],1295:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export')
  , $at     = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
},{"./_export":1044,"./_string-at":1109}],1296:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export     = require('./_export')
  , defined     = require('./_defined')
  , toLength    = require('./_to-length')
  , isRegExp    = require('./_is-regexp')
  , getFlags    = require('./_flags')
  , RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function(regexp, string){
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next(){
  var match = this._r.exec(this._s);
  return {value: match, done: match === null};
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp){
    defined(this);
    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
    var S     = String(this)
      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});
},{"./_defined":1039,"./_export":1044,"./_flags":1048,"./_is-regexp":1062,"./_iter-create":1064,"./_to-length":1120}],1297:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export')
  , $pad    = require('./_string-pad');

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});
},{"./_export":1044,"./_string-pad":1112}],1298:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export')
  , $pad    = require('./_string-pad');

$export($export.P, 'String', {
  padStart: function padStart(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});
},{"./_export":1044,"./_string-pad":1112}],1299:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function($trim){
  return function trimLeft(){
    return $trim(this, 1);
  };
}, 'trimStart');
},{"./_string-trim":1114}],1300:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function($trim){
  return function trimRight(){
    return $trim(this, 2);
  };
}, 'trimEnd');
},{"./_string-trim":1114}],1301:[function(require,module,exports){
arguments[4][1012][0].apply(exports,arguments)
},{"./_wks-define":1127,"dup":1012}],1302:[function(require,module,exports){
arguments[4][1013][0].apply(exports,arguments)
},{"./_wks-define":1127,"dup":1013}],1303:[function(require,module,exports){
// https://github.com/ljharb/proposal-global
var $export = require('./_export');

$export($export.S, 'System', {global: require('./_global')});
},{"./_export":1044,"./_global":1050}],1304:[function(require,module,exports){
var $iterators    = require('./es6.array.iterator')
  , redefine      = require('./_redefine')
  , global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , wks           = require('./_wks')
  , ITERATOR      = wks('iterator')
  , TO_STRING_TAG = wks('toStringTag')
  , ArrayValues   = Iterators.Array;

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype
    , key;
  if(proto){
    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
  }
}
},{"./_global":1050,"./_hide":1052,"./_iterators":1068,"./_redefine":1099,"./_wks":1129,"./es6.array.iterator":1142}],1305:[function(require,module,exports){
var $export = require('./_export')
  , $task   = require('./_task');
$export($export.G + $export.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
},{"./_export":1044,"./_task":1116}],1306:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global     = require('./_global')
  , $export    = require('./_export')
  , invoke     = require('./_invoke')
  , partial    = require('./_partial')
  , navigator  = global.navigator
  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      typeof fn == 'function' ? fn : Function(fn)
    ), time);
  } : set;
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout:  wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});
},{"./_export":1044,"./_global":1050,"./_invoke":1056,"./_partial":1095}],1307:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.umulh');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');
},{"./modules/_core":1035,"./modules/es6.array.copy-within":1132,"./modules/es6.array.every":1133,"./modules/es6.array.fill":1134,"./modules/es6.array.filter":1135,"./modules/es6.array.find":1137,"./modules/es6.array.find-index":1136,"./modules/es6.array.for-each":1138,"./modules/es6.array.from":1139,"./modules/es6.array.index-of":1140,"./modules/es6.array.is-array":1141,"./modules/es6.array.iterator":1142,"./modules/es6.array.join":1143,"./modules/es6.array.last-index-of":1144,"./modules/es6.array.map":1145,"./modules/es6.array.of":1146,"./modules/es6.array.reduce":1148,"./modules/es6.array.reduce-right":1147,"./modules/es6.array.slice":1149,"./modules/es6.array.some":1150,"./modules/es6.array.sort":1151,"./modules/es6.array.species":1152,"./modules/es6.date.now":1153,"./modules/es6.date.to-iso-string":1154,"./modules/es6.date.to-json":1155,"./modules/es6.date.to-primitive":1156,"./modules/es6.date.to-string":1157,"./modules/es6.function.bind":1158,"./modules/es6.function.has-instance":1159,"./modules/es6.function.name":1160,"./modules/es6.map":1161,"./modules/es6.math.acosh":1162,"./modules/es6.math.asinh":1163,"./modules/es6.math.atanh":1164,"./modules/es6.math.cbrt":1165,"./modules/es6.math.clz32":1166,"./modules/es6.math.cosh":1167,"./modules/es6.math.expm1":1168,"./modules/es6.math.fround":1169,"./modules/es6.math.hypot":1170,"./modules/es6.math.imul":1171,"./modules/es6.math.log10":1172,"./modules/es6.math.log1p":1173,"./modules/es6.math.log2":1174,"./modules/es6.math.sign":1175,"./modules/es6.math.sinh":1176,"./modules/es6.math.tanh":1177,"./modules/es6.math.trunc":1178,"./modules/es6.number.constructor":1179,"./modules/es6.number.epsilon":1180,"./modules/es6.number.is-finite":1181,"./modules/es6.number.is-integer":1182,"./modules/es6.number.is-nan":1183,"./modules/es6.number.is-safe-integer":1184,"./modules/es6.number.max-safe-integer":1185,"./modules/es6.number.min-safe-integer":1186,"./modules/es6.number.parse-float":1187,"./modules/es6.number.parse-int":1188,"./modules/es6.number.to-fixed":1189,"./modules/es6.number.to-precision":1190,"./modules/es6.object.assign":1191,"./modules/es6.object.create":1192,"./modules/es6.object.define-properties":1193,"./modules/es6.object.define-property":1194,"./modules/es6.object.freeze":1195,"./modules/es6.object.get-own-property-descriptor":1196,"./modules/es6.object.get-own-property-names":1197,"./modules/es6.object.get-prototype-of":1198,"./modules/es6.object.is":1202,"./modules/es6.object.is-extensible":1199,"./modules/es6.object.is-frozen":1200,"./modules/es6.object.is-sealed":1201,"./modules/es6.object.keys":1203,"./modules/es6.object.prevent-extensions":1204,"./modules/es6.object.seal":1205,"./modules/es6.object.set-prototype-of":1206,"./modules/es6.object.to-string":1207,"./modules/es6.parse-float":1208,"./modules/es6.parse-int":1209,"./modules/es6.promise":1210,"./modules/es6.reflect.apply":1211,"./modules/es6.reflect.construct":1212,"./modules/es6.reflect.define-property":1213,"./modules/es6.reflect.delete-property":1214,"./modules/es6.reflect.enumerate":1215,"./modules/es6.reflect.get":1218,"./modules/es6.reflect.get-own-property-descriptor":1216,"./modules/es6.reflect.get-prototype-of":1217,"./modules/es6.reflect.has":1219,"./modules/es6.reflect.is-extensible":1220,"./modules/es6.reflect.own-keys":1221,"./modules/es6.reflect.prevent-extensions":1222,"./modules/es6.reflect.set":1224,"./modules/es6.reflect.set-prototype-of":1223,"./modules/es6.regexp.constructor":1225,"./modules/es6.regexp.flags":1226,"./modules/es6.regexp.match":1227,"./modules/es6.regexp.replace":1228,"./modules/es6.regexp.search":1229,"./modules/es6.regexp.split":1230,"./modules/es6.regexp.to-string":1231,"./modules/es6.set":1232,"./modules/es6.string.anchor":1233,"./modules/es6.string.big":1234,"./modules/es6.string.blink":1235,"./modules/es6.string.bold":1236,"./modules/es6.string.code-point-at":1237,"./modules/es6.string.ends-with":1238,"./modules/es6.string.fixed":1239,"./modules/es6.string.fontcolor":1240,"./modules/es6.string.fontsize":1241,"./modules/es6.string.from-code-point":1242,"./modules/es6.string.includes":1243,"./modules/es6.string.italics":1244,"./modules/es6.string.iterator":1245,"./modules/es6.string.link":1246,"./modules/es6.string.raw":1247,"./modules/es6.string.repeat":1248,"./modules/es6.string.small":1249,"./modules/es6.string.starts-with":1250,"./modules/es6.string.strike":1251,"./modules/es6.string.sub":1252,"./modules/es6.string.sup":1253,"./modules/es6.string.trim":1254,"./modules/es6.symbol":1255,"./modules/es6.typed.array-buffer":1256,"./modules/es6.typed.data-view":1257,"./modules/es6.typed.float32-array":1258,"./modules/es6.typed.float64-array":1259,"./modules/es6.typed.int16-array":1260,"./modules/es6.typed.int32-array":1261,"./modules/es6.typed.int8-array":1262,"./modules/es6.typed.uint16-array":1263,"./modules/es6.typed.uint32-array":1264,"./modules/es6.typed.uint8-array":1265,"./modules/es6.typed.uint8-clamped-array":1266,"./modules/es6.weak-map":1267,"./modules/es6.weak-set":1268,"./modules/es7.array.includes":1269,"./modules/es7.asap":1270,"./modules/es7.error.is-error":1271,"./modules/es7.map.to-json":1272,"./modules/es7.math.iaddh":1273,"./modules/es7.math.imulh":1274,"./modules/es7.math.isubh":1275,"./modules/es7.math.umulh":1276,"./modules/es7.object.define-getter":1277,"./modules/es7.object.define-setter":1278,"./modules/es7.object.entries":1279,"./modules/es7.object.get-own-property-descriptors":1280,"./modules/es7.object.lookup-getter":1281,"./modules/es7.object.lookup-setter":1282,"./modules/es7.object.values":1283,"./modules/es7.observable":1284,"./modules/es7.reflect.define-metadata":1285,"./modules/es7.reflect.delete-metadata":1286,"./modules/es7.reflect.get-metadata":1288,"./modules/es7.reflect.get-metadata-keys":1287,"./modules/es7.reflect.get-own-metadata":1290,"./modules/es7.reflect.get-own-metadata-keys":1289,"./modules/es7.reflect.has-metadata":1291,"./modules/es7.reflect.has-own-metadata":1292,"./modules/es7.reflect.metadata":1293,"./modules/es7.set.to-json":1294,"./modules/es7.string.at":1295,"./modules/es7.string.match-all":1296,"./modules/es7.string.pad-end":1297,"./modules/es7.string.pad-start":1298,"./modules/es7.string.trim-left":1299,"./modules/es7.string.trim-right":1300,"./modules/es7.symbol.async-iterator":1301,"./modules/es7.symbol.observable":1302,"./modules/es7.system.global":1303,"./modules/web.dom.iterable":1304,"./modules/web.immediate":1305,"./modules/web.timers":1306}],1308:[function(require,module,exports){
(function (process,global){
'use strict';

// Last Updated On: 2017-05-24 4:28:17 PM UTC

// ________________
// DetectRTC v1.3.4

// Open-Sourced: https://github.com/muaz-khan/DetectRTC

// --------------------------------------------------
// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// --------------------------------------------------

(function() {

    var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';

    var isNodejs = typeof process === 'object' && typeof process.versions === 'object' && process.versions.node && /*node-process*/ !process.browser;
    if (isNodejs) {
        var version = process.versions.node.toString().replace('v', '');
        browserFakeUserAgent = 'Nodejs/' + version + ' (NodeOS) AppleWebKit/' + version + ' (KHTML, like Gecko) Nodejs/' + version + ' Nodejs/' + version
    }

    (function(that) {
        if (typeof window !== 'undefined') {
            return;
        }

        if (typeof window === 'undefined' && typeof global !== 'undefined') {
            global.navigator = {
                userAgent: browserFakeUserAgent,
                getUserMedia: function() {}
            };

            /*global window:true */
            that.window = global;
        } else if (typeof window === 'undefined') {
            // window = this;
        }

        if (typeof location === 'undefined') {
            /*global location:true */
            that.location = {
                protocol: 'file:',
                href: '',
                hash: ''
            };
        }

        if (typeof screen === 'undefined') {
            /*global screen:true */
            that.screen = {
                width: 0,
                height: 0
            };
        }
    })(typeof global !== 'undefined' ? global : window);

    /*global navigator:true */
    var navigator = window.navigator;

    if (typeof navigator !== 'undefined') {
        if (typeof navigator.webkitGetUserMedia !== 'undefined') {
            navigator.getUserMedia = navigator.webkitGetUserMedia;
        }

        if (typeof navigator.mozGetUserMedia !== 'undefined') {
            navigator.getUserMedia = navigator.mozGetUserMedia;
        }
    } else {
        navigator = {
            getUserMedia: function() {},
            userAgent: browserFakeUserAgent
        };
    }

    var isMobileDevice = !!(/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || ''));

    var isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob);

    var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
    var isFirefox = typeof window.InstallTrigger !== 'undefined';
    var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
    var isChrome = !!window.chrome && !isOpera;
    var isIE = typeof document !== 'undefined' && !!document.documentMode && !isEdge;

    // this one can also be used:
    // https://www.websocket.org/js/stuff.js (DetectBrowser.js)

    function getBrowserInfo() {
        var nVer = navigator.appVersion;
        var nAgt = navigator.userAgent;
        var browserName = navigator.appName;
        var fullVersion = '' + parseFloat(navigator.appVersion);
        var majorVersion = parseInt(navigator.appVersion, 10);
        var nameOffset, verOffset, ix;

        // In Opera, the true version is after 'Opera' or after 'Version'
        if (isOpera) {
            browserName = 'Opera';
            try {
                fullVersion = navigator.userAgent.split('OPR/')[1].split(' ')[0];
                majorVersion = fullVersion.split('.')[0];
            } catch (e) {
                fullVersion = '0.0.0.0';
                majorVersion = 0;
            }
        }
        // In MSIE, the true version is after 'MSIE' in userAgent
        else if (isIE) {
            verOffset = nAgt.indexOf('MSIE');
            browserName = 'IE';
            fullVersion = nAgt.substring(verOffset + 5);
        }
        // In Chrome, the true version is after 'Chrome'
        else if (isChrome) {
            verOffset = nAgt.indexOf('Chrome');
            browserName = 'Chrome';
            fullVersion = nAgt.substring(verOffset + 7);
        }
        // In Safari, the true version is after 'Safari' or after 'Version'
        else if (isSafari) {
            verOffset = nAgt.indexOf('Safari');
            browserName = 'Safari';
            fullVersion = nAgt.substring(verOffset + 7);

            if ((verOffset = nAgt.indexOf('Version')) !== -1) {
                fullVersion = nAgt.substring(verOffset + 8);
            }
        }
        // In Firefox, the true version is after 'Firefox'
        else if (isFirefox) {
            verOffset = nAgt.indexOf('Firefox');
            browserName = 'Firefox';
            fullVersion = nAgt.substring(verOffset + 8);
        }

        // In most other browsers, 'name/version' is at the end of userAgent
        else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
            browserName = nAgt.substring(nameOffset, verOffset);
            fullVersion = nAgt.substring(verOffset + 1);

            if (browserName.toLowerCase() === browserName.toUpperCase()) {
                browserName = navigator.appName;
            }
        }

        if (isEdge) {
            browserName = 'Edge';
            // fullVersion = navigator.userAgent.split('Edge/')[1];
            fullVersion = parseInt(navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)[2], 10).toString();
        }

        // trim the fullVersion string at semicolon/space if present
        if ((ix = fullVersion.indexOf(';')) !== -1) {
            fullVersion = fullVersion.substring(0, ix);
        }

        if ((ix = fullVersion.indexOf(' ')) !== -1) {
            fullVersion = fullVersion.substring(0, ix);
        }

        majorVersion = parseInt('' + fullVersion, 10);

        if (isNaN(majorVersion)) {
            fullVersion = '' + parseFloat(navigator.appVersion);
            majorVersion = parseInt(navigator.appVersion, 10);
        }

        return {
            fullVersion: fullVersion,
            version: majorVersion,
            name: browserName,
            isPrivateBrowsing: false
        };
    }

    // via: https://gist.github.com/cou929/7973956

    function retry(isDone, next) {
        var currentTrial = 0,
            maxRetry = 50,
            interval = 10,
            isTimeout = false;
        var id = window.setInterval(
            function() {
                if (isDone()) {
                    window.clearInterval(id);
                    next(isTimeout);
                }
                if (currentTrial++ > maxRetry) {
                    window.clearInterval(id);
                    isTimeout = true;
                    next(isTimeout);
                }
            },
            10
        );
    }

    function isIE10OrLater(userAgent) {
        var ua = userAgent.toLowerCase();
        if (ua.indexOf('msie') === 0 && ua.indexOf('trident') === 0) {
            return false;
        }
        var match = /(?:msie|rv:)\s?([\d\.]+)/.exec(ua);
        if (match && parseInt(match[1], 10) >= 10) {
            return true;
        }
        return false;
    }

    function detectPrivateMode(callback) {
        var isPrivate;

        try {

            if (window.webkitRequestFileSystem) {
                window.webkitRequestFileSystem(
                    window.TEMPORARY, 1,
                    function() {
                        isPrivate = false;
                    },
                    function(e) {
                        isPrivate = true;
                    }
                );
            } else if (window.indexedDB && /Firefox/.test(window.navigator.userAgent)) {
                var db;
                try {
                    db = window.indexedDB.open('test');
                    db.onerror = function() {
                        return true;
                    };
                } catch (e) {
                    isPrivate = true;
                }

                if (typeof isPrivate === 'undefined') {
                    retry(
                        function isDone() {
                            return db.readyState === 'done' ? true : false;
                        },
                        function next(isTimeout) {
                            if (!isTimeout) {
                                isPrivate = db.result ? false : true;
                            }
                        }
                    );
                }
            } else if (isIE10OrLater(window.navigator.userAgent)) {
                isPrivate = false;
                try {
                    if (!window.indexedDB) {
                        isPrivate = true;
                    }
                } catch (e) {
                    isPrivate = true;
                }
            } else if (window.localStorage && /Safari/.test(window.navigator.userAgent)) {
                try {
                    window.localStorage.setItem('test', 1);
                } catch (e) {
                    isPrivate = true;
                }

                if (typeof isPrivate === 'undefined') {
                    isPrivate = false;
                    window.localStorage.removeItem('test');
                }
            }

        } catch (e) {
            isPrivate = false;
        }

        retry(
            function isDone() {
                return typeof isPrivate !== 'undefined' ? true : false;
            },
            function next(isTimeout) {
                callback(isPrivate);
            }
        );
    }

    var isMobile = {
        Android: function() {
            return navigator.userAgent.match(/Android/i);
        },
        BlackBerry: function() {
            return navigator.userAgent.match(/BlackBerry|BB10/i);
        },
        iOS: function() {
            return navigator.userAgent.match(/iPhone|iPad|iPod/i);
        },
        Opera: function() {
            return navigator.userAgent.match(/Opera Mini/i);
        },
        Windows: function() {
            return navigator.userAgent.match(/IEMobile/i);
        },
        any: function() {
            return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
        },
        getOsName: function() {
            var osName = 'Unknown OS';
            if (isMobile.Android()) {
                osName = 'Android';
            }

            if (isMobile.BlackBerry()) {
                osName = 'BlackBerry';
            }

            if (isMobile.iOS()) {
                osName = 'iOS';
            }

            if (isMobile.Opera()) {
                osName = 'Opera Mini';
            }

            if (isMobile.Windows()) {
                osName = 'Windows';
            }

            return osName;
        }
    };

    // via: http://jsfiddle.net/ChristianL/AVyND/
    function detectDesktopOS() {
        var unknown = '-';

        var nVer = navigator.appVersion;
        var nAgt = navigator.userAgent;

        var os = unknown;
        var clientStrings = [{
            s: 'Windows 10',
            r: /(Windows 10.0|Windows NT 10.0)/
        }, {
            s: 'Windows 8.1',
            r: /(Windows 8.1|Windows NT 6.3)/
        }, {
            s: 'Windows 8',
            r: /(Windows 8|Windows NT 6.2)/
        }, {
            s: 'Windows 7',
            r: /(Windows 7|Windows NT 6.1)/
        }, {
            s: 'Windows Vista',
            r: /Windows NT 6.0/
        }, {
            s: 'Windows Server 2003',
            r: /Windows NT 5.2/
        }, {
            s: 'Windows XP',
            r: /(Windows NT 5.1|Windows XP)/
        }, {
            s: 'Windows 2000',
            r: /(Windows NT 5.0|Windows 2000)/
        }, {
            s: 'Windows ME',
            r: /(Win 9x 4.90|Windows ME)/
        }, {
            s: 'Windows 98',
            r: /(Windows 98|Win98)/
        }, {
            s: 'Windows 95',
            r: /(Windows 95|Win95|Windows_95)/
        }, {
            s: 'Windows NT 4.0',
            r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
        }, {
            s: 'Windows CE',
            r: /Windows CE/
        }, {
            s: 'Windows 3.11',
            r: /Win16/
        }, {
            s: 'Android',
            r: /Android/
        }, {
            s: 'Open BSD',
            r: /OpenBSD/
        }, {
            s: 'Sun OS',
            r: /SunOS/
        }, {
            s: 'Linux',
            r: /(Linux|X11)/
        }, {
            s: 'iOS',
            r: /(iPhone|iPad|iPod)/
        }, {
            s: 'Mac OS X',
            r: /Mac OS X/
        }, {
            s: 'Mac OS',
            r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
        }, {
            s: 'QNX',
            r: /QNX/
        }, {
            s: 'UNIX',
            r: /UNIX/
        }, {
            s: 'BeOS',
            r: /BeOS/
        }, {
            s: 'OS/2',
            r: /OS\/2/
        }, {
            s: 'Search Bot',
            r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
        }];
        for (var i = 0, cs; cs = clientStrings[i]; i++) {
            if (cs.r.test(nAgt)) {
                os = cs.s;
                break;
            }
        }

        var osVersion = unknown;

        if (/Windows/.test(os)) {
            if (/Windows (.*)/.test(os)) {
                osVersion = /Windows (.*)/.exec(os)[1];
            }
            os = 'Windows';
        }

        switch (os) {
            case 'Mac OS X':
                if (/Mac OS X (10[\.\_\d]+)/.test(nAgt)) {
                    osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1];
                }
                break;
            case 'Android':
                if (/Android ([\.\_\d]+)/.test(nAgt)) {
                    osVersion = /Android ([\.\_\d]+)/.exec(nAgt)[1];
                }
                break;
            case 'iOS':
                if (/OS (\d+)_(\d+)_?(\d+)?/.test(nAgt)) {
                    osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
                    osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);
                }
                break;
        }

        return {
            osName: os,
            osVersion: osVersion
        };
    }

    var osName = 'Unknown OS';
    var osVersion = 'Unknown OS Version';

    function getAndroidVersion(ua) {
        ua = (ua || navigator.userAgent).toLowerCase();
        var match = ua.match(/android\s([0-9\.]*)/);
        return match ? match[1] : false;
    }

    var osInfo = detectDesktopOS();

    if (osInfo && osInfo.osName && osInfo.osName != '-') {
        osName = osInfo.osName;
        osVersion = osInfo.osVersion;
    } else if (isMobile.any()) {
        osName = isMobile.getOsName();

        if (osName == 'Android') {
            osVersion = getAndroidVersion();
        }
    }

    var isNodejs = typeof process === 'object' && typeof process.versions === 'object' && process.versions.node;

    if (osName === 'Unknown OS' && isNodejs) {
        osName = 'Nodejs';
        osVersion = process.versions.node.toString().replace('v', '');
    }

    var isCanvasSupportsStreamCapturing = false;
    var isVideoSupportsStreamCapturing = false;
    ['captureStream', 'mozCaptureStream', 'webkitCaptureStream'].forEach(function(item) {
        if (typeof document === 'undefined' || typeof document.createElement !== 'function') {
            return;
        }

        if (!isCanvasSupportsStreamCapturing && item in document.createElement('canvas')) {
            isCanvasSupportsStreamCapturing = true;
        }

        if (!isVideoSupportsStreamCapturing && item in document.createElement('video')) {
            isVideoSupportsStreamCapturing = true;
        }
    });

    // via: https://github.com/diafygi/webrtc-ips
    function DetectLocalIPAddress(callback) {
        if (!DetectRTC.isWebRTCSupported) {
            return;
        }

        if (DetectRTC.isORTCSupported) {
            return;
        }

        getIPs(function(ip) {
            //local IPs
            if (ip.match(/^(192\.168\.|169\.254\.|10\.|172\.(1[6-9]|2\d|3[01]))/)) {
                callback('Local: ' + ip);
            }

            //assume the rest are public IPs
            else {
                callback('Public: ' + ip);
            }
        });
    }

    //get the IP addresses associated with an account
    function getIPs(callback) {
        if (typeof document === 'undefined' || typeof document.getElementById !== 'function') {
            return;
        }

        var ipDuplicates = {};

        //compatibility for firefox and chrome
        var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
        var useWebKit = !!window.webkitRTCPeerConnection;

        // bypass naive webrtc blocking using an iframe
        if (!RTCPeerConnection) {
            var iframe = document.getElementById('iframe');
            if (!iframe) {
                //<iframe id="iframe" sandbox="allow-same-origin" style="display: none"></iframe>
                throw 'NOTE: you need to have an iframe in the page right above the script tag.';
            }
            var win = iframe.contentWindow;
            RTCPeerConnection = win.RTCPeerConnection || win.mozRTCPeerConnection || win.webkitRTCPeerConnection;
            useWebKit = !!win.webkitRTCPeerConnection;
        }

        // if still no RTCPeerConnection then it is not supported by the browser so just return
        if (!RTCPeerConnection) {
            return;
        }

        //minimal requirements for data connection
        var mediaConstraints = {
            optional: [{
                RtpDataChannels: true
            }]
        };

        //firefox already has a default stun server in about:config
        //    media.peerconnection.default_iceservers =
        //    [{"url": "stun:stun.services.mozilla.com"}]
        var servers;

        //add same stun server for chrome
        if (useWebKit) {
            servers = {
                iceServers: [{
                    urls: 'stun:stun.services.mozilla.com'
                }]
            };

            if (typeof DetectRTC !== 'undefined' && DetectRTC.browser.isFirefox && DetectRTC.browser.version <= 38) {
                servers[0] = {
                    url: servers[0].urls
                };
            }
        }

        //construct a new RTCPeerConnection
        var pc = new RTCPeerConnection(servers, mediaConstraints);

        function handleCandidate(candidate) {
            //match just the IP address
            var ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
            var match = ipRegex.exec(candidate);
            if (!match) {
                console.warn('Could not match IP address in', candidate);
                return;
            }
            var ipAddress = match[1];

            //remove duplicates
            if (ipDuplicates[ipAddress] === undefined) {
                callback(ipAddress);
            }

            ipDuplicates[ipAddress] = true;
        }

        //listen for candidate events
        pc.onicecandidate = function(ice) {
            //skip non-candidate events
            if (ice.candidate) {
                handleCandidate(ice.candidate.candidate);
            }
        };

        //create a bogus data channel
        pc.createDataChannel('');

        //create an offer sdp
        pc.createOffer(function(result) {

            //trigger the stun server request
            pc.setLocalDescription(result, function() {}, function() {});

        }, function() {});

        //wait for a while to let everything done
        setTimeout(function() {
            //read candidate info from local description
            var lines = pc.localDescription.sdp.split('\n');

            lines.forEach(function(line) {
                if (line.indexOf('a=candidate:') === 0) {
                    handleCandidate(line);
                }
            });
        }, 1000);
    }

    var MediaDevices = [];

    var audioInputDevices = [];
    var audioOutputDevices = [];
    var videoInputDevices = [];

    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
        // Firefox 38+ seems having support of enumerateDevices
        // Thanks @xdumaine/enumerateDevices
        navigator.enumerateDevices = function(callback) {
            navigator.mediaDevices.enumerateDevices().then(callback).catch(function() {
                callback([]);
            });
        };
    }

    // Media Devices detection
    var canEnumerate = false;

    /*global MediaStreamTrack:true */
    if (typeof MediaStreamTrack !== 'undefined' && 'getSources' in MediaStreamTrack) {
        canEnumerate = true;
    } else if (navigator.mediaDevices && !!navigator.mediaDevices.enumerateDevices) {
        canEnumerate = true;
    }

    var hasMicrophone = false;
    var hasSpeakers = false;
    var hasWebcam = false;

    var isWebsiteHasMicrophonePermissions = false;
    var isWebsiteHasWebcamPermissions = false;

    // http://dev.w3.org/2011/webrtc/editor/getusermedia.html#mediadevices
    function checkDeviceSupport(callback) {
        if (!canEnumerate) {
            if (callback) {
                callback();
            }
            return;
        }

        if (!navigator.enumerateDevices && window.MediaStreamTrack && window.MediaStreamTrack.getSources) {
            navigator.enumerateDevices = window.MediaStreamTrack.getSources.bind(window.MediaStreamTrack);
        }

        if (!navigator.enumerateDevices && navigator.enumerateDevices) {
            navigator.enumerateDevices = navigator.enumerateDevices.bind(navigator);
        }

        if (!navigator.enumerateDevices) {
            if (callback) {
                callback();
            }
            return;
        }

        MediaDevices = [];

        audioInputDevices = [];
        audioOutputDevices = [];
        videoInputDevices = [];

        isWebsiteHasMicrophonePermissions = false;
        isWebsiteHasWebcamPermissions = false;

        // to prevent duplication
        var alreadyUsedDevices = {};

        navigator.enumerateDevices(function(devices) {
            devices.forEach(function(_device) {
                var device = {};
                for (var d in _device) {
                    try {
                        if (typeof _device[d] !== 'function') {
                            device[d] = _device[d];
                        }
                    } catch (e) {}
                }

                if (alreadyUsedDevices[device.deviceId + device.label]) {
                    return;
                }

                // if it is MediaStreamTrack.getSources
                if (device.kind === 'audio') {
                    device.kind = 'audioinput';
                }

                if (device.kind === 'video') {
                    device.kind = 'videoinput';
                }

                if (!device.deviceId) {
                    device.deviceId = device.id;
                }

                if (!device.id) {
                    device.id = device.deviceId;
                }

                if (!device.label) {
                    device.label = 'Please invoke getUserMedia once.';
                    if (typeof DetectRTC !== 'undefined' && DetectRTC.browser.isChrome && DetectRTC.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
                        if (typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
                            device.label = 'HTTPs is required to get label of this ' + device.kind + ' device.';
                        }
                    }
                } else {
                    if (device.kind === 'videoinput' && !isWebsiteHasWebcamPermissions) {
                        isWebsiteHasWebcamPermissions = true;
                    }

                    if (device.kind === 'audioinput' && !isWebsiteHasMicrophonePermissions) {
                        isWebsiteHasMicrophonePermissions = true;
                    }
                }

                if (device.kind === 'audioinput') {
                    hasMicrophone = true;

                    if (audioInputDevices.indexOf(device) === -1) {
                        audioInputDevices.push(device);
                    }
                }

                if (device.kind === 'audiooutput') {
                    hasSpeakers = true;

                    if (audioOutputDevices.indexOf(device) === -1) {
                        audioOutputDevices.push(device);
                    }
                }

                if (device.kind === 'videoinput') {
                    hasWebcam = true;

                    if (videoInputDevices.indexOf(device) === -1) {
                        videoInputDevices.push(device);
                    }
                }

                // there is no 'videoouput' in the spec.
                MediaDevices.push(device);

                alreadyUsedDevices[device.deviceId + device.label] = device;
            });

            if (typeof DetectRTC !== 'undefined') {
                // to sync latest outputs
                DetectRTC.MediaDevices = MediaDevices;
                DetectRTC.hasMicrophone = hasMicrophone;
                DetectRTC.hasSpeakers = hasSpeakers;
                DetectRTC.hasWebcam = hasWebcam;

                DetectRTC.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions;
                DetectRTC.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions;

                DetectRTC.audioInputDevices = audioInputDevices;
                DetectRTC.audioOutputDevices = audioOutputDevices;
                DetectRTC.videoInputDevices = videoInputDevices;
            }

            if (callback) {
                callback();
            }
        });
    }

    var DetectRTC = window.DetectRTC || {};

    // ----------
    // DetectRTC.browser.name || DetectRTC.browser.version || DetectRTC.browser.fullVersion
    DetectRTC.browser = getBrowserInfo();

    detectPrivateMode(function(isPrivateBrowsing) {
        DetectRTC.browser.isPrivateBrowsing = !!isPrivateBrowsing;
    });

    // DetectRTC.isChrome || DetectRTC.isFirefox || DetectRTC.isEdge
    DetectRTC.browser['is' + DetectRTC.browser.name] = true;

    // -----------
    DetectRTC.osName = osName;
    DetectRTC.osVersion = osVersion;

    var isNodeWebkit = typeof process === 'object' && typeof process.versions === 'object' && process.versions['node-webkit'];

    // --------- Detect if system supports WebRTC 1.0 or WebRTC 1.1.
    var isWebRTCSupported = false;
    ['RTCPeerConnection', 'webkitRTCPeerConnection', 'mozRTCPeerConnection', 'RTCIceGatherer'].forEach(function(item) {
        if (isWebRTCSupported) {
            return;
        }

        if (item in window) {
            isWebRTCSupported = true;
        }
    });
    DetectRTC.isWebRTCSupported = isWebRTCSupported;

    //-------
    DetectRTC.isORTCSupported = typeof RTCIceGatherer !== 'undefined';

    // --------- Detect if system supports screen capturing API
    var isScreenCapturingSupported = false;
    if (DetectRTC.browser.isChrome && DetectRTC.browser.version >= 35) {
        isScreenCapturingSupported = true;
    } else if (DetectRTC.browser.isFirefox && DetectRTC.browser.version >= 34) {
        isScreenCapturingSupported = true;
    }

    if (!/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
        if (typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
            // DetectRTC.browser.isChrome
            isScreenCapturingSupported = false;
        }

        if (DetectRTC.browser.isFirefox) {
            isScreenCapturingSupported = false;
        }
    }
    DetectRTC.isScreenCapturingSupported = isScreenCapturingSupported;

    // --------- Detect if WebAudio API are supported
    var webAudio = {
        isSupported: false,
        isCreateMediaStreamSourceSupported: false
    };

    ['AudioContext', 'webkitAudioContext', 'mozAudioContext', 'msAudioContext'].forEach(function(item) {
        if (webAudio.isSupported) {
            return;
        }

        if (item in window) {
            webAudio.isSupported = true;

            if (window[item] && 'createMediaStreamSource' in window[item].prototype) {
                webAudio.isCreateMediaStreamSourceSupported = true;
            }
        }
    });
    DetectRTC.isAudioContextSupported = webAudio.isSupported;
    DetectRTC.isCreateMediaStreamSourceSupported = webAudio.isCreateMediaStreamSourceSupported;

    // ---------- Detect if SCTP/RTP channels are supported.

    var isRtpDataChannelsSupported = false;
    if (DetectRTC.browser.isChrome && DetectRTC.browser.version > 31) {
        isRtpDataChannelsSupported = true;
    }
    DetectRTC.isRtpDataChannelsSupported = isRtpDataChannelsSupported;

    var isSCTPSupportd = false;
    if (DetectRTC.browser.isFirefox && DetectRTC.browser.version > 28) {
        isSCTPSupportd = true;
    } else if (DetectRTC.browser.isChrome && DetectRTC.browser.version > 25) {
        isSCTPSupportd = true;
    } else if (DetectRTC.browser.isOpera && DetectRTC.browser.version >= 11) {
        isSCTPSupportd = true;
    }
    DetectRTC.isSctpDataChannelsSupported = isSCTPSupportd;

    // ---------

    DetectRTC.isMobileDevice = isMobileDevice; // "isMobileDevice" boolean is defined in "getBrowserInfo.js"

    // ------
    var isGetUserMediaSupported = false;
    if (navigator.getUserMedia) {
        isGetUserMediaSupported = true;
    } else if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        isGetUserMediaSupported = true;
    }

    if (DetectRTC.browser.isChrome && DetectRTC.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
        if (typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
            isGetUserMediaSupported = 'Requires HTTPs';
        }
    }

    if (DetectRTC.osName === 'Nodejs') {
        isGetUserMediaSupported = false;
    }
    DetectRTC.isGetUserMediaSupported = isGetUserMediaSupported;

    var displayResolution = '';
    if (screen.width) {
        var width = (screen.width) ? screen.width : '';
        var height = (screen.height) ? screen.height : '';
        displayResolution += '' + width + ' x ' + height;
    }
    DetectRTC.displayResolution = displayResolution;

    // ----------
    DetectRTC.isCanvasSupportsStreamCapturing = isCanvasSupportsStreamCapturing;
    DetectRTC.isVideoSupportsStreamCapturing = isVideoSupportsStreamCapturing;

    if (DetectRTC.browser.name == 'Chrome' && DetectRTC.browser.version >= 53) {
        if (!DetectRTC.isCanvasSupportsStreamCapturing) {
            DetectRTC.isCanvasSupportsStreamCapturing = 'Requires chrome flag: enable-experimental-web-platform-features';
        }

        if (!DetectRTC.isVideoSupportsStreamCapturing) {
            DetectRTC.isVideoSupportsStreamCapturing = 'Requires chrome flag: enable-experimental-web-platform-features';
        }
    }

    // ------
    DetectRTC.DetectLocalIPAddress = DetectLocalIPAddress;

    DetectRTC.isWebSocketsSupported = 'WebSocket' in window && 2 === window.WebSocket.CLOSING;
    DetectRTC.isWebSocketsBlocked = !DetectRTC.isWebSocketsSupported;

    if (DetectRTC.osName === 'Nodejs') {
        DetectRTC.isWebSocketsSupported = true;
        DetectRTC.isWebSocketsBlocked = false;
    }

    DetectRTC.checkWebSocketsSupport = function(callback) {
        callback = callback || function() {};
        try {
            var websocket = new WebSocket('wss://echo.websocket.org:443/');
            websocket.onopen = function() {
                DetectRTC.isWebSocketsBlocked = false;
                callback();
                websocket.close();
                websocket = null;
            };
            websocket.onerror = function() {
                DetectRTC.isWebSocketsBlocked = true;
                callback();
            };
        } catch (e) {
            DetectRTC.isWebSocketsBlocked = true;
            callback();
        }
    };

    // -------
    DetectRTC.load = function(callback) {
        callback = callback || function() {};
        checkDeviceSupport(callback);
    };

    // check for microphone/camera support!
    if (typeof checkDeviceSupport === 'function') {
        // checkDeviceSupport();
    }

    if (typeof MediaDevices !== 'undefined') {
        DetectRTC.MediaDevices = MediaDevices;
    } else {
        DetectRTC.MediaDevices = [];
    }

    DetectRTC.hasMicrophone = hasMicrophone;
    DetectRTC.hasSpeakers = hasSpeakers;
    DetectRTC.hasWebcam = hasWebcam;

    DetectRTC.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions;
    DetectRTC.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions;

    DetectRTC.audioInputDevices = audioInputDevices;
    DetectRTC.audioOutputDevices = audioOutputDevices;
    DetectRTC.videoInputDevices = videoInputDevices;

    // ------
    var isSetSinkIdSupported = false;
    if (typeof document !== 'undefined' && typeof document.createElement === 'function' && 'setSinkId' in document.createElement('video')) {
        isSetSinkIdSupported = true;
    }
    DetectRTC.isSetSinkIdSupported = isSetSinkIdSupported;

    // -----
    var isRTPSenderReplaceTracksSupported = false;
    if (DetectRTC.browser.isFirefox && typeof mozRTCPeerConnection !== 'undefined' /*&& DetectRTC.browser.version > 39*/ ) {
        /*global mozRTCPeerConnection:true */
        if ('getSenders' in mozRTCPeerConnection.prototype) {
            isRTPSenderReplaceTracksSupported = true;
        }
    } else if (DetectRTC.browser.isChrome && typeof webkitRTCPeerConnection !== 'undefined') {
        /*global webkitRTCPeerConnection:true */
        if ('getSenders' in webkitRTCPeerConnection.prototype) {
            isRTPSenderReplaceTracksSupported = true;
        }
    }
    DetectRTC.isRTPSenderReplaceTracksSupported = isRTPSenderReplaceTracksSupported;

    //------
    var isRemoteStreamProcessingSupported = false;
    if (DetectRTC.browser.isFirefox && DetectRTC.browser.version > 38) {
        isRemoteStreamProcessingSupported = true;
    }
    DetectRTC.isRemoteStreamProcessingSupported = isRemoteStreamProcessingSupported;

    //-------
    var isApplyConstraintsSupported = false;

    /*global MediaStreamTrack:true */
    if (typeof MediaStreamTrack !== 'undefined' && 'applyConstraints' in MediaStreamTrack.prototype) {
        isApplyConstraintsSupported = true;
    }
    DetectRTC.isApplyConstraintsSupported = isApplyConstraintsSupported;

    //-------
    var isMultiMonitorScreenCapturingSupported = false;
    if (DetectRTC.browser.isFirefox && DetectRTC.browser.version >= 43) {
        // version 43 merely supports platforms for multi-monitors
        // version 44 will support exact multi-monitor selection i.e. you can select any monitor for screen capturing.
        isMultiMonitorScreenCapturingSupported = true;
    }
    DetectRTC.isMultiMonitorScreenCapturingSupported = isMultiMonitorScreenCapturingSupported;

    DetectRTC.isPromisesSupported = !!('Promise' in window);

    if (typeof DetectRTC === 'undefined') {
        window.DetectRTC = {};
    }

    var MediaStream = window.MediaStream;

    if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {
        MediaStream = webkitMediaStream;
    }

    if (typeof MediaStream !== 'undefined') {
        DetectRTC.MediaStream = Object.keys(MediaStream.prototype);
    } else DetectRTC.MediaStream = false;

    if (typeof MediaStreamTrack !== 'undefined') {
        DetectRTC.MediaStreamTrack = Object.keys(MediaStreamTrack.prototype);
    } else DetectRTC.MediaStreamTrack = false;

    var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;

    if (typeof RTCPeerConnection !== 'undefined') {
        DetectRTC.RTCPeerConnection = Object.keys(RTCPeerConnection.prototype);
    } else DetectRTC.RTCPeerConnection = false;

    window.DetectRTC = DetectRTC;

    if (typeof module !== 'undefined' /* && !!module.exports*/ ) {
        module.exports = DetectRTC;
    }

    if (typeof define === 'function' && define.amd) {
        define('DetectRTC', [], function() {
            return DetectRTC;
        });
    }
})();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":1743}],1309:[function(require,module,exports){
'use strict';
module.exports = function (buf) {
	if (!(buf && buf.length > 1)) {
		return null;
	}

	if (buf[0] === 0xFF && buf[1] === 0xD8 && buf[2] === 0xFF) {
		return {
			ext: 'jpg',
			mime: 'image/jpeg'
		};
	}

	if (buf[0] === 0x89 && buf[1] === 0x50 && buf[2] === 0x4E && buf[3] === 0x47) {
		return {
			ext: 'png',
			mime: 'image/png'
		};
	}

	if (buf[0] === 0x47 && buf[1] === 0x49 && buf[2] === 0x46) {
		return {
			ext: 'gif',
			mime: 'image/gif'
		};
	}

	if (buf[8] === 0x57 && buf[9] === 0x45 && buf[10] === 0x42 && buf[11] === 0x50) {
		return {
			ext: 'webp',
			mime: 'image/webp'
		};
	}

	if (buf[0] === 0x46 && buf[1] === 0x4C && buf[2] === 0x49 && buf[3] === 0x46) {
		return {
			ext: 'flif',
			mime: 'image/flif'
		};
	}

	// needs to be before `tif` check
	if (((buf[0] === 0x49 && buf[1] === 0x49 && buf[2] === 0x2A && buf[3] === 0x0) || (buf[0] === 0x4D && buf[1] === 0x4D && buf[2] === 0x0 && buf[3] === 0x2A)) && buf[8] === 0x43 && buf[9] === 0x52) {
		return {
			ext: 'cr2',
			mime: 'image/x-canon-cr2'
		};
	}

	if ((buf[0] === 0x49 && buf[1] === 0x49 && buf[2] === 0x2A && buf[3] === 0x0) || (buf[0] === 0x4D && buf[1] === 0x4D && buf[2] === 0x0 && buf[3] === 0x2A)) {
		return {
			ext: 'tif',
			mime: 'image/tiff'
		};
	}

	if (buf[0] === 0x42 && buf[1] === 0x4D) {
		return {
			ext: 'bmp',
			mime: 'image/bmp'
		};
	}

	if (buf[0] === 0x49 && buf[1] === 0x49 && buf[2] === 0xBC) {
		return {
			ext: 'jxr',
			mime: 'image/vnd.ms-photo'
		};
	}

	if (buf[0] === 0x38 && buf[1] === 0x42 && buf[2] === 0x50 && buf[3] === 0x53) {
		return {
			ext: 'psd',
			mime: 'image/vnd.adobe.photoshop'
		};
	}

	// needs to be before `zip` check
	if (buf[0] === 0x50 && buf[1] === 0x4B && buf[2] === 0x3 && buf[3] === 0x4 && buf[30] === 0x6D && buf[31] === 0x69 && buf[32] === 0x6D && buf[33] === 0x65 && buf[34] === 0x74 && buf[35] === 0x79 && buf[36] === 0x70 && buf[37] === 0x65 && buf[38] === 0x61 && buf[39] === 0x70 && buf[40] === 0x70 && buf[41] === 0x6C && buf[42] === 0x69 && buf[43] === 0x63 && buf[44] === 0x61 && buf[45] === 0x74 && buf[46] === 0x69 && buf[47] === 0x6F && buf[48] === 0x6E && buf[49] === 0x2F && buf[50] === 0x65 && buf[51] === 0x70 && buf[52] === 0x75 && buf[53] === 0x62 && buf[54] === 0x2B && buf[55] === 0x7A && buf[56] === 0x69 && buf[57] === 0x70) {
		return {
			ext: 'epub',
			mime: 'application/epub+zip'
		};
	}

	// needs to be before `zip` check
	// assumes signed .xpi from addons.mozilla.org
	if (buf[0] === 0x50 && buf[1] === 0x4B && buf[2] === 0x3 && buf[3] === 0x4 && buf[30] === 0x4D && buf[31] === 0x45 && buf[32] === 0x54 && buf[33] === 0x41 && buf[34] === 0x2D && buf[35] === 0x49 && buf[36] === 0x4E && buf[37] === 0x46 && buf[38] === 0x2F && buf[39] === 0x6D && buf[40] === 0x6F && buf[41] === 0x7A && buf[42] === 0x69 && buf[43] === 0x6C && buf[44] === 0x6C && buf[45] === 0x61 && buf[46] === 0x2E && buf[47] === 0x72 && buf[48] === 0x73 && buf[49] === 0x61) {
		return {
			ext: 'xpi',
			mime: 'application/x-xpinstall'
		};
	}

	if (buf[0] === 0x50 && buf[1] === 0x4B && (buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) && (buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)) {
		return {
			ext: 'zip',
			mime: 'application/zip'
		};
	}

	if (buf[257] === 0x75 && buf[258] === 0x73 && buf[259] === 0x74 && buf[260] === 0x61 && buf[261] === 0x72) {
		return {
			ext: 'tar',
			mime: 'application/x-tar'
		};
	}

	if (buf[0] === 0x52 && buf[1] === 0x61 && buf[2] === 0x72 && buf[3] === 0x21 && buf[4] === 0x1A && buf[5] === 0x7 && (buf[6] === 0x0 || buf[6] === 0x1)) {
		return {
			ext: 'rar',
			mime: 'application/x-rar-compressed'
		};
	}

	if (buf[0] === 0x1F && buf[1] === 0x8B && buf[2] === 0x8) {
		return {
			ext: 'gz',
			mime: 'application/gzip'
		};
	}

	if (buf[0] === 0x42 && buf[1] === 0x5A && buf[2] === 0x68) {
		return {
			ext: 'bz2',
			mime: 'application/x-bzip2'
		};
	}

	if (buf[0] === 0x37 && buf[1] === 0x7A && buf[2] === 0xBC && buf[3] === 0xAF && buf[4] === 0x27 && buf[5] === 0x1C) {
		return {
			ext: '7z',
			mime: 'application/x-7z-compressed'
		};
	}

	if (buf[0] === 0x78 && buf[1] === 0x01) {
		return {
			ext: 'dmg',
			mime: 'application/x-apple-diskimage'
		};
	}

	if (
		(buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && (buf[3] === 0x18 || buf[3] === 0x20) && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70) ||
		(buf[0] === 0x33 && buf[1] === 0x67 && buf[2] === 0x70 && buf[3] === 0x35) ||
		(buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1C && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x6D && buf[9] === 0x70 && buf[10] === 0x34 && buf[11] === 0x32 && buf[16] === 0x6D && buf[17] === 0x70 && buf[18] === 0x34 && buf[19] === 0x31 && buf[20] === 0x6D && buf[21] === 0x70 && buf[22] === 0x34 && buf[23] === 0x32 && buf[24] === 0x69 && buf[25] === 0x73 && buf[26] === 0x6F && buf[27] === 0x6D) ||
		(buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1C && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x69 && buf[9] === 0x73 && buf[10] === 0x6F && buf[11] === 0x6D) ||
		(buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1c && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x6D && buf[9] === 0x70 && buf[10] === 0x34 && buf[11] === 0x32 && buf[12] === 0x0 && buf[13] === 0x0 && buf[14] === 0x0 && buf[15] === 0x0)
	) {
		return {
			ext: 'mp4',
			mime: 'video/mp4'
		};
	}

	if ((buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1C && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x4D && buf[9] === 0x34 && buf[10] === 0x56)) {
		return {
			ext: 'm4v',
			mime: 'video/x-m4v'
		};
	}

	if (buf[0] === 0x4D && buf[1] === 0x54 && buf[2] === 0x68 && buf[3] === 0x64) {
		return {
			ext: 'mid',
			mime: 'audio/midi'
		};
	}

	// needs to be before the `webm` check
	if (buf[31] === 0x6D && buf[32] === 0x61 && buf[33] === 0x74 && buf[34] === 0x72 && buf[35] === 0x6f && buf[36] === 0x73 && buf[37] === 0x6B && buf[38] === 0x61) {
		return {
			ext: 'mkv',
			mime: 'video/x-matroska'
		};
	}

	if (buf[0] === 0x1A && buf[1] === 0x45 && buf[2] === 0xDF && buf[3] === 0xA3) {
		return {
			ext: 'webm',
			mime: 'video/webm'
		};
	}

	if (buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x14 && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70) {
		return {
			ext: 'mov',
			mime: 'video/quicktime'
		};
	}

	if (buf[0] === 0x52 && buf[1] === 0x49 && buf[2] === 0x46 && buf[3] === 0x46 && buf[8] === 0x41 && buf[9] === 0x56 && buf[10] === 0x49) {
		return {
			ext: 'avi',
			mime: 'video/x-msvideo'
		};
	}

	if (buf[0] === 0x30 && buf[1] === 0x26 && buf[2] === 0xB2 && buf[3] === 0x75 && buf[4] === 0x8E && buf[5] === 0x66 && buf[6] === 0xCF && buf[7] === 0x11 && buf[8] === 0xA6 && buf[9] === 0xD9) {
		return {
			ext: 'wmv',
			mime: 'video/x-ms-wmv'
		};
	}

	if (buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x1 && buf[3].toString(16)[0] === 'b') {
		return {
			ext: 'mpg',
			mime: 'video/mpeg'
		};
	}

	if ((buf[0] === 0x49 && buf[1] === 0x44 && buf[2] === 0x33) || (buf[0] === 0xFF && buf[1] === 0xfb)) {
		return {
			ext: 'mp3',
			mime: 'audio/mpeg'
		};
	}

	if ((buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x4D && buf[9] === 0x34 && buf[10] === 0x41) || (buf[0] === 0x4D && buf[1] === 0x34 && buf[2] === 0x41 && buf[3] === 0x20)) {
		return {
			ext: 'm4a',
			mime: 'audio/m4a'
		};
	}

	// needs to be before `ogg` check
	if (buf[28] === 0x4F && buf[29] === 0x70 && buf[30] === 0x75 && buf[31] === 0x73 && buf[32] === 0x48 && buf[33] === 0x65 && buf[34] === 0x61 && buf[35] === 0x64) {
		return {
			ext: 'opus',
			mime: 'audio/opus'
		};
	}

	if (buf[0] === 0x4F && buf[1] === 0x67 && buf[2] === 0x67 && buf[3] === 0x53) {
		return {
			ext: 'ogg',
			mime: 'audio/ogg'
		};
	}

	if (buf[0] === 0x66 && buf[1] === 0x4C && buf[2] === 0x61 && buf[3] === 0x43) {
		return {
			ext: 'flac',
			mime: 'audio/x-flac'
		};
	}

	if (buf[0] === 0x52 && buf[1] === 0x49 && buf[2] === 0x46 && buf[3] === 0x46 && buf[8] === 0x57 && buf[9] === 0x41 && buf[10] === 0x56 && buf[11] === 0x45) {
		return {
			ext: 'wav',
			mime: 'audio/x-wav'
		};
	}

	if (buf[0] === 0x23 && buf[1] === 0x21 && buf[2] === 0x41 && buf[3] === 0x4D && buf[4] === 0x52 && buf[5] === 0x0A) {
		return {
			ext: 'amr',
			mime: 'audio/amr'
		};
	}

	if (buf[0] === 0x25 && buf[1] === 0x50 && buf[2] === 0x44 && buf[3] === 0x46) {
		return {
			ext: 'pdf',
			mime: 'application/pdf'
		};
	}

	if (buf[0] === 0x4D && buf[1] === 0x5A) {
		return {
			ext: 'exe',
			mime: 'application/x-msdownload'
		};
	}

	if ((buf[0] === 0x43 || buf[0] === 0x46) && buf[1] === 0x57 && buf[2] === 0x53) {
		return {
			ext: 'swf',
			mime: 'application/x-shockwave-flash'
		};
	}

	if (buf[0] === 0x7B && buf[1] === 0x5C && buf[2] === 0x72 && buf[3] === 0x74 && buf[4] === 0x66) {
		return {
			ext: 'rtf',
			mime: 'application/rtf'
		};
	}

	if (
		(buf[0] === 0x77 && buf[1] === 0x4F && buf[2] === 0x46 && buf[3] === 0x46) &&
		(
			(buf[4] === 0x00 && buf[5] === 0x01 && buf[6] === 0x00 && buf[7] === 0x00) ||
			(buf[4] === 0x4F && buf[5] === 0x54 && buf[6] === 0x54 && buf[7] === 0x4F)
		)
	) {
		return {
			ext: 'woff',
			mime: 'application/font-woff'
		};
	}

	if (
		(buf[0] === 0x77 && buf[1] === 0x4F && buf[2] === 0x46 && buf[3] === 0x32) &&
		(
			(buf[4] === 0x00 && buf[5] === 0x01 && buf[6] === 0x00 && buf[7] === 0x00) ||
			(buf[4] === 0x4F && buf[5] === 0x54 && buf[6] === 0x54 && buf[7] === 0x4F)
		)
	) {
		return {
			ext: 'woff2',
			mime: 'application/font-woff'
		};
	}

	if (
		(buf[34] === 0x4C && buf[35] === 0x50) &&
		(
			(buf[8] === 0x00 && buf[9] === 0x00 && buf[10] === 0x01) ||
			(buf[8] === 0x01 && buf[9] === 0x00 && buf[10] === 0x02) ||
			(buf[8] === 0x02 && buf[9] === 0x00 && buf[10] === 0x02)
		)
	) {
		return {
			ext: 'eot',
			mime: 'application/octet-stream'
		};
	}

	if (buf[0] === 0x00 && buf[1] === 0x01 && buf[2] === 0x00 && buf[3] === 0x00 && buf[4] === 0x00) {
		return {
			ext: 'ttf',
			mime: 'application/font-sfnt'
		};
	}

	if (buf[0] === 0x4F && buf[1] === 0x54 && buf[2] === 0x54 && buf[3] === 0x4F && buf[4] === 0x00) {
		return {
			ext: 'otf',
			mime: 'application/font-sfnt'
		};
	}

	if (buf[0] === 0x00 && buf[1] === 0x00 && buf[2] === 0x01 && buf[3] === 0x00) {
		return {
			ext: 'ico',
			mime: 'image/x-icon'
		};
	}

	if (buf[0] === 0x46 && buf[1] === 0x4C && buf[2] === 0x56 && buf[3] === 0x01) {
		return {
			ext: 'flv',
			mime: 'video/x-flv'
		};
	}

	if (buf[0] === 0x25 && buf[1] === 0x21) {
		return {
			ext: 'ps',
			mime: 'application/postscript'
		};
	}

	if (buf[0] === 0xFD && buf[1] === 0x37 && buf[2] === 0x7A && buf[3] === 0x58 && buf[4] === 0x5A && buf[5] === 0x00) {
		return {
			ext: 'xz',
			mime: 'application/x-xz'
		};
	}

	if (buf[0] === 0x53 && buf[1] === 0x51 && buf[2] === 0x4C && buf[3] === 0x69) {
		return {
			ext: 'sqlite',
			mime: 'application/x-sqlite3'
		};
	}

	if (buf[0] === 0x4E && buf[1] === 0x45 && buf[2] === 0x53 && buf[3] === 0x1A) {
		return {
			ext: 'nes',
			mime: 'application/x-nintendo-nes-rom'
		};
	}

	if (buf[0] === 0x43 && buf[1] === 0x72 && buf[2] === 0x32 && buf[3] === 0x34) {
		return {
			ext: 'crx',
			mime: 'application/x-google-chrome-extension'
		};
	}

	if (
		(buf[0] === 0x4D && buf[1] === 0x53 && buf[2] === 0x43 && buf[3] === 0x46) ||
		(buf[0] === 0x49 && buf[1] === 0x53 && buf[2] === 0x63 && buf[3] === 0x28)
	) {
		return {
			ext: 'cab',
			mime: 'application/vnd.ms-cab-compressed'
		};
	}

	// needs to be before `ar` check
	if (buf[0] === 0x21 && buf[1] === 0x3C && buf[2] === 0x61 && buf[3] === 0x72 && buf[4] === 0x63 && buf[5] === 0x68 && buf[6] === 0x3E && buf[7] === 0x0A && buf[8] === 0x64 && buf[9] === 0x65 && buf[10] === 0x62 && buf[11] === 0x69 && buf[12] === 0x61 && buf[13] === 0x6E && buf[14] === 0x2D && buf[15] === 0x62 && buf[16] === 0x69 && buf[17] === 0x6E && buf[18] === 0x61 && buf[19] === 0x72 && buf[20] === 0x79) {
		return {
			ext: 'deb',
			mime: 'application/x-deb'
		};
	}

	if (buf[0] === 0x21 && buf[1] === 0x3C && buf[2] === 0x61 && buf[3] === 0x72 && buf[4] === 0x63 && buf[5] === 0x68 && buf[6] === 0x3E) {
		return {
			ext: 'ar',
			mime: 'application/x-unix-archive'
		};
	}

	if (buf[0] === 0xED && buf[1] === 0xAB && buf[2] === 0xEE && buf[3] === 0xDB) {
		return {
			ext: 'rpm',
			mime: 'application/x-rpm'
		};
	}

	if (
		(buf[0] === 0x1F && buf[1] === 0xA0) ||
		(buf[0] === 0x1F && buf[1] === 0x9D)
	) {
		return {
			ext: 'Z',
			mime: 'application/x-compress'
		};
	}

	if (buf[0] === 0x4C && buf[1] === 0x5A && buf[2] === 0x49 && buf[3] === 0x50) {
		return {
			ext: 'lz',
			mime: 'application/x-lzip'
		};
	}

	if (buf[0] === 0xD0 && buf[1] === 0xCF && buf[2] === 0x11 && buf[3] === 0xE0 && buf[4] === 0xA1 && buf[5] === 0xB1 && buf[6] === 0x1A && buf[7] === 0xE1) {
		return {
			ext: 'msi',
			mime: 'application/x-msi'
		};
	}

	return null;
};

},{}],1310:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }

    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":1312}],1311:[function(require,module,exports){
(function (global){
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1312:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],1313:[function(require,module,exports){
var slice = Array.prototype.slice;

// our constructor
function KeyTreeStore(options) {
    options = options || {};
    if (typeof options !== 'object') {
        throw new TypeError('Options must be an object');
    }
    var DEFAULT_SEPARATOR = '.';

    this.storage = {};
    this.separator = options.separator || DEFAULT_SEPARATOR;
}

// add an object to the store
KeyTreeStore.prototype.add = function (keypath, obj) {
    var arr = this.storage[keypath] || (this.storage[keypath] = []);
    arr.push(obj);
};

// remove an object
KeyTreeStore.prototype.remove = function (obj) {
    var path, arr;
    for (path in this.storage) {
        arr = this.storage[path];
        arr.some(function (item, index) {
            if (item === obj) {
                arr.splice(index, 1);
                return true;
            }
        });
    }
};

// get array of all all relevant functions, without keys
KeyTreeStore.prototype.get = function (keypath) {
    var res = [];
    var key;

    for (key in this.storage) {
        if (!keypath || keypath === key || key.indexOf(keypath + this.separator) === 0) {
            res = res.concat(this.storage[key]);
        }
    }

    return res;
};

// get all results that match keypath but still grouped by key
KeyTreeStore.prototype.getGrouped = function (keypath) {
    var res = {};
    var key;

    for (key in this.storage) {
        if (!keypath || keypath === key || key.indexOf(keypath + this.separator) === 0) {
            res[key] = slice.call(this.storage[key]);
        }
    }

    return res;
};

// get all results that match keypath but still grouped by key
KeyTreeStore.prototype.getAll = function (keypath) {
    var res = {};
    var key;

    for (key in this.storage) {
        if (keypath === key || key.indexOf(keypath + this.separator) === 0) {
            res[key] = slice.call(this.storage[key]);
        }
    }

    return res;
};

// run all matches with optional context
KeyTreeStore.prototype.run = function (keypath, context) {
    var args = slice.call(arguments, 2);
    this.get(keypath).forEach(function (fn) {
        fn.apply(context || this, args);
    });
};

module.exports = KeyTreeStore;

},{}],1314:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var after = require("lodash/after");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(after, new applicators_1.PostValueApplicator(), { setter: true }));
/**
 * The opposite of Before. This method creates a function that invokes once it's called n or more times.
 * @param {number} n The number of calls before the function is invoked.
 * @example
 *
 * class MyClass {
 *   @After(2)
 *   fn() {
 *     return 10;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.fn(); // => undefined
 * myClass.fn(); // => 10
 */
function After(n) {
    return decorator(n);
}
exports.After = After;
exports.after = After;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/after":1604}],1315:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var after = require("lodash/after");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(after, new applicators_1.PostValueApplicator(), { setter: true }));
/**
 * The opposite of Before. This method creates a function that invokes once it's called n or more times.
 * This spans across all instances of the class instead of the instance.
 * @param {number} n The number of calls before the function is invoked.
 * @example
 *
 * class MyClass {
 *   @AfterAll(2)
 *   fn() {
 *     return 10;
 *   }
 * }
 *
 * const myClass = new MyClass();
 * const myClass2 = new MyClass();
 *
 * myClass.fn(); // => undefined
 * myClass.fn(); // => 10
 *
 * myClass2.fn(); // => 10
 * myClass2.fn(); // => 10
 */
function AfterAll(n) {
    return decorator(n);
}
exports.AfterAll = AfterAll;
exports.afterAll = AfterAll;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/after":1604}],1316:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./applicators/Applicator"));
__export(require("./applicators/ComposeApplicator"));
__export(require("./applicators/PartialApplicator"));
__export(require("./applicators/PartialedApplicator"));
__export(require("./applicators/PartialValueApplicator"));
__export(require("./applicators/PostValueApplicator"));
__export(require("./applicators/PreValueApplicator"));
__export(require("./applicators/WrapApplicator"));
__export(require("./applicators/BindApplicator"));
__export(require("./applicators/InvokeApplicator"));
__export(require("./applicators/MemoizeApplicator"));

},{"./applicators/Applicator":1317,"./applicators/BindApplicator":1318,"./applicators/ComposeApplicator":1319,"./applicators/InvokeApplicator":1320,"./applicators/MemoizeApplicator":1321,"./applicators/PartialApplicator":1322,"./applicators/PartialValueApplicator":1323,"./applicators/PartialedApplicator":1324,"./applicators/PostValueApplicator":1325,"./applicators/PreValueApplicator":1326,"./applicators/WrapApplicator":1327}],1317:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Applicator = (function () {
    function Applicator() {
    }
    return Applicator;
}());
exports.Applicator = Applicator;

},{}],1318:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Applicator_1 = require("./Applicator");
var BindApplicator = (function (_super) {
    tslib_1.__extends(BindApplicator, _super);
    function BindApplicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BindApplicator.prototype.apply = function (_a) {
        var value = _a.value, execute = _a.config.execute, args = _a.args, instance = _a.instance, target = _a.target;
        if (!instance) {
            return value;
        }
        return execute.apply(void 0, [value, instance].concat(args));
    };
    return BindApplicator;
}(Applicator_1.Applicator));
exports.BindApplicator = BindApplicator;

},{"./Applicator":1317,"tslib":1729}],1319:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var identity = require("lodash/identity");
var Applicator_1 = require("./Applicator");
var utils_1 = require("../utils");
var ComposeApplicator = (function (_super) {
    tslib_1.__extends(ComposeApplicator, _super);
    function ComposeApplicator(_config) {
        if (_config === void 0) { _config = {}; }
        var _this = _super.call(this) || this;
        _this._config = _config;
        return _this;
    }
    Object.defineProperty(ComposeApplicator.prototype, "post", {
        get: function () {
            return this._config.post === true;
        },
        enumerable: true,
        configurable: true
    });
    ComposeApplicator.prototype.apply = function (_a) {
        var execute = _a.config.execute, _b = _a.value, value = _b === void 0 ? identity : _b, args = _a.args, target = _a.target;
        var applicator = this;
        return function () {
            var _this = this;
            var invokeArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                invokeArgs[_i] = arguments[_i];
            }
            var _args = args.map(function (method) { return utils_1.resolveFunction(method, _this, target); }).slice();
            if (applicator.post) {
                _args.push(value);
            }
            else {
                _args.unshift(value);
            }
            return execute.apply(void 0, _args).apply(this, invokeArgs);
        };
    };
    return ComposeApplicator;
}(Applicator_1.Applicator));
exports.ComposeApplicator = ComposeApplicator;

},{"../utils":1365,"./Applicator":1317,"lodash/identity":1641,"tslib":1729}],1320:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Applicator_1 = require("./Applicator");
var InvokeApplicator = (function (_super) {
    tslib_1.__extends(InvokeApplicator, _super);
    function InvokeApplicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InvokeApplicator.prototype.apply = function (_a) {
        var args = _a.args, target = _a.target, execute = _a.config.execute, value = _a.value;
        return function () {
            var invokeArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                invokeArgs[_i] = arguments[_i];
            }
            return execute.apply(void 0, [value.bind(this)].concat(invokeArgs, args));
        };
    };
    return InvokeApplicator;
}(Applicator_1.Applicator));
exports.InvokeApplicator = InvokeApplicator;

},{"./Applicator":1317,"tslib":1729}],1321:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var isFunction = require("lodash/isFunction");
var isObject = require("lodash/isObject");
var Applicator_1 = require("./Applicator");
var utils_1 = require("../utils");
var MemoizeApplicator = (function (_super) {
    tslib_1.__extends(MemoizeApplicator, _super);
    function MemoizeApplicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MemoizeApplicator.prototype.apply = function (_a) {
        var value = _a.value, instance = _a.instance, execute = _a.config.execute, args = _a.args, target = _a.target;
        var resolver = utils_1.resolveFunction(isFunction(args[0]) ? args[0] : isObject(args[0]) ? args[0].resolver : args[0], instance, target, false);
        if (resolver && instance) {
            resolver = resolver.bind(instance);
        }
        var memoized = resolver ? execute(value, resolver) : execute(value);
        if (isObject(args[0])) {
            var _b = args[0], cache = _b.cache, type = _b.type;
            if (cache) {
                memoized.cache = cache;
            }
            else if (isFunction(type)) {
                memoized.cache = new type();
            }
        }
        return memoized;
    };
    return MemoizeApplicator;
}(Applicator_1.Applicator));
exports.MemoizeApplicator = MemoizeApplicator;

},{"../utils":1365,"./Applicator":1317,"lodash/isFunction":1656,"lodash/isObject":1659,"tslib":1729}],1322:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Applicator_1 = require("./Applicator");
var utils_1 = require("../utils");
var PartialApplicator = (function (_super) {
    tslib_1.__extends(PartialApplicator, _super);
    function PartialApplicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PartialApplicator.prototype.apply = function (_a) {
        var args = _a.args, target = _a.target, execute = _a.config.execute;
        return function () {
            var invokeArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                invokeArgs[_i] = arguments[_i];
            }
            return execute.apply(void 0, [utils_1.resolveFunction(args[0], this, target)].concat(args.slice(1))).apply(this, invokeArgs);
        };
    };
    return PartialApplicator;
}(Applicator_1.Applicator));
exports.PartialApplicator = PartialApplicator;

},{"../utils":1365,"./Applicator":1317,"tslib":1729}],1323:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var isFunction = require("lodash/isFunction");
var Applicator_1 = require("./Applicator");
var utils_1 = require("../utils");
var PartialValueApplicator = (function (_super) {
    tslib_1.__extends(PartialValueApplicator, _super);
    function PartialValueApplicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PartialValueApplicator.prototype.apply = function (_a) {
        var args = _a.args, target = _a.target, value = _a.value, execute = _a.config.execute;
        return function () {
            var invokeArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                invokeArgs[_i] = arguments[_i];
            }
            var fn = value;
            var argIndex = 0;
            if (!isFunction(fn)) {
                fn = utils_1.resolveFunction(args[0], this, target);
                argIndex = 1;
            }
            return execute.apply(void 0, [fn].concat(args.slice(argIndex))).apply(this, invokeArgs);
        };
    };
    return PartialValueApplicator;
}(Applicator_1.Applicator));
exports.PartialValueApplicator = PartialValueApplicator;

},{"../utils":1365,"./Applicator":1317,"lodash/isFunction":1656,"tslib":1729}],1324:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var partial = require("lodash/partial");
var Applicator_1 = require("./Applicator");
var PartialedApplicator = (function (_super) {
    tslib_1.__extends(PartialedApplicator, _super);
    function PartialedApplicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PartialedApplicator.prototype.apply = function (_a) {
        var execute = _a.config.execute, value = _a.value, args = _a.args;
        return partial.apply(void 0, [execute, value].concat(args));
    };
    return PartialedApplicator;
}(Applicator_1.Applicator));
exports.PartialedApplicator = PartialedApplicator;

},{"./Applicator":1317,"lodash/partial":1682,"tslib":1729}],1325:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Applicator_1 = require("./Applicator");
var PostValueApplicator = (function (_super) {
    tslib_1.__extends(PostValueApplicator, _super);
    function PostValueApplicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PostValueApplicator.prototype.apply = function (_a) {
        var _b = _a.config, execute = _b.execute, bound = _b.bound, args = _a.args, value = _a.value;
        return execute.apply(void 0, args.concat([value]));
    };
    return PostValueApplicator;
}(Applicator_1.Applicator));
exports.PostValueApplicator = PostValueApplicator;

},{"./Applicator":1317,"tslib":1729}],1326:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Applicator_1 = require("./Applicator");
var PreValueApplicator = (function (_super) {
    tslib_1.__extends(PreValueApplicator, _super);
    function PreValueApplicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PreValueApplicator.prototype.apply = function (_a) {
        var value = _a.value, execute = _a.config.execute, args = _a.args;
        return execute.apply(void 0, [value].concat(args));
    };
    return PreValueApplicator;
}(Applicator_1.Applicator));
exports.PreValueApplicator = PreValueApplicator;

},{"./Applicator":1317,"tslib":1729}],1327:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Applicator_1 = require("./Applicator");
var utils_1 = require("../utils");
var WrapApplicator = (function (_super) {
    tslib_1.__extends(WrapApplicator, _super);
    function WrapApplicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WrapApplicator.prototype.apply = function (_a) {
        var args = _a.args, execute = _a.config.execute, target = _a.target, value = _a.value;
        return function () {
            var invokeArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                invokeArgs[_i] = arguments[_i];
            }
            return execute(utils_1.resolveFunction(args[0], this, target), value).apply(this, invokeArgs);
        };
    };
    return WrapApplicator;
}(Applicator_1.Applicator));
exports.WrapApplicator = WrapApplicator;

},{"../utils":1365,"./Applicator":1317,"tslib":1729}],1328:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ary = require("lodash/ary");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(ary, new applicators_1.PreValueApplicator()));
/**
 * Creates a function that invokes func, with up to n arguments, ignoring any additional arguments.
 * @param {number} n The arity cap.
 * @example
 *
 * class MyClass {
 *   @Ary(1)
 *   fn(...args) {
 *     return args;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.fn(1, 2, 3, 4); // => [ 1 ]
 */
function Ary(n) {
    return decorator(n);
}
exports.Ary = Ary;
exports.ary = Ary;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/ary":1605}],1329:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var attempt = require("lodash/attempt");
var partial = require("lodash/partial");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var attemptFn = function (fn) { return partial(attempt, fn); };
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(attemptFn, new applicators_1.PreValueApplicator()));
/**
 * Attempts to invoke func, returning either the result or the caught error object. Any additional arguments are provided to func when it's invoked.
 * @param {...*} [args] The arguments to invoke func with.
 * @example
 *
 * class MyClass {
 *   @Attempt()
 *   fn(value) {
 *     if (typeof value === 'number') {
 *       return value
 *     }
 *
 *     throw new Error();
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.fn(10); // => 10;
 * myClass.fn(null); // => Error
 */
function Attempt() {
    var partials = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        partials[_i] = arguments[_i];
    }
    return decorator.apply(void 0, partials);
}
exports.Attempt = Attempt;
exports.attempt = Attempt;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/attempt":1608,"lodash/partial":1682}],1330:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var before = require("lodash/before");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(before, new applicators_1.PostValueApplicator(), { setter: true }));
/**
 * Creates a function that invokes func, with the this binding and arguments of the created function, while it's called less than n times.
 * Subsequent calls to the created function return the result of the last func invocation.
 * @param {number} n The number of calls at whichc func is no longer invoked.
 * @example
 *
 * let calls = 0;
 *
 * class MyClass {
 *   @Before(3)
 *   fn() {
 *     calls++;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.fn();
 * myClass.fn();
 * myClass.fn();
 * myClass.fn();
 *
 * calls === 2; // => true
 */
function Before(n) {
    return decorator(n);
}
exports.Before = Before;
exports.before = Before;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/before":1609}],1331:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var before = require("lodash/before");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(before, new applicators_1.PostValueApplicator(), { setter: true }));
/**
 * Creates a function that invokes func, with the this binding and arguments of the created function, while it's called less than n times.
 * Subsequent calls to the created function return the result of the last func invocation.
 * @param {number} n The number of calls at whichc func is no longer invoked.
 * @example
 *
 * let calls = 0;
 *
 * class MyClass {
 *   @BeforeAll(3)
 *   fn() {
 *     calls++;
 *   }
 * }
 *
 * const myClass = new MyClass();
 * const myClass2 = new MyClass();
 *
 * myClass.fn();
 * myClass.fn();
 * myClass.fn();
 * myClass.fn();
 *
 * myClass2.fn();
 *
 * calls === 3; // => true
 */
function BeforeAll(n) {
    return decorator(n);
}
exports.BeforeAll = BeforeAll;
exports.beforeAll = BeforeAll;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/before":1609}],1332:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var bind = require("lodash/bind");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(bind, new applicators_1.BindApplicator()));
/**
 * Creates a function that invokes func with the this binding of thisArg and partials prepended to the arguments it receives.
 *
 * The _.bind.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for partially applied arguments.
 *
 * Note: Unlike native Function#bind, this method doesn't set the "length" property of bound functions.
 * @param {...*} [partials] The argument to be partially applied.
 * @example
 *
 * class MyClass {
 *   @Bind()
 *   bound() {
 *     return this;
 *   }
 *
 *   unbound() {
 *     return this;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.bound.call(null); // => myClass {}
 * myClass.unbound.call(null); // => null
 */
function Bind() {
    var partials = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        partials[_i] = arguments[_i];
    }
    return decorator.apply(void 0, partials);
}
exports.Bind = Bind;
exports.bind = Bind;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/bind":1610}],1333:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction = require("lodash/isFunction");
var utils_1 = require("./utils");
var factory_1 = require("./factory");
/**
 * Binds methods of an object to the object itself, overwriting the existing method.
 * @export
 * @param {string[]} [methods=[]]
 * @returns {ClassDecorator}
 * @example
 *
 * @BindAll()
 * class MyClass {
 *   bound() {
 *     return this;
 *   }
 *
 *   unbound() {
 *     return this;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.bound.call(null); // => MyClass {}
 * myClass.unbound.call(null); // => MyClass {}
 */
function BindAll(methods) {
    if (methods === void 0) { methods = []; }
    return function (target) {
        return utils_1.wrapConstructor(target, function (Ctor) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            bindAllMethods(target, this, methods);
            Ctor.apply(this, args);
        });
    };
}
exports.BindAll = BindAll;
exports.bindAll = BindAll;
function bindAllMethods(target, instance, methods) {
    if (methods === void 0) { methods = []; }
    var proto = target.prototype;
    while (proto && proto !== Object.prototype) {
        for (var _i = 0, _a = Object.getOwnPropertyNames(proto); _i < _a.length; _i++) {
            var key = _a[_i];
            var include = methods.length ? methods.indexOf(key) !== -1 : true;
            var descriptor = Object.getOwnPropertyDescriptor(proto, key);
            if (include && key !== 'constructor' && !instance.hasOwnProperty(key)) {
                // If this property is a getter and it's NOT an instance decorated
                // method, ignore it. Instance decorators are getters until first accessed.
                if (descriptor.get) {
                    var chainData = factory_1.InstanceChainMap.get([proto, key]);
                    if (!chainData || !chainData.isMethod) {
                        continue;
                    }
                }
                var value = instance[key];
                if (isFunction(value)) {
                    Object.defineProperty(instance, key, {
                        configurable: true,
                        enumerable: descriptor.enumerable,
                        value: utils_1.copyMetadata(value.bind(instance), value),
                        writable: descriptor.writable
                    });
                }
            }
        }
        proto = Object.getPrototypeOf(proto);
    }
}
exports.default = BindAll;

},{"./factory":1342,"./utils":1365,"lodash/isFunction":1656}],1334:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var curry = require("lodash/curry");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(curry, new applicators_1.PreValueApplicator(), { bound: true }));
/**
 * Creates a function that accepts arguments of func and either invokes func returning its result, if at least arity number of arguments have been provided, or returns a function that accepts the remaining func arguments, and so on.
 * The arity of func may be specified if func.length is not sufficient.
 * The original function is bound to the instance. If the method is needed to call in a different context use `CurryAll`.
 *
 * The _.curry.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for provided arguments.
 *
 * Note: This method doesn't set the "length" property of curried functions.
 * @param {number} [arity] The arity of func.
 * @example
 *
 * class MyClass {
 *   multiplier = 2;
 *
 *   @Curry()
 *   add(a, b) {
 *     return (a + b) * this.multiplier;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * const add5 = myClass.add(5);
 *
 * add5AndMultiply(10); // => 30
 */
function Curry(arity) {
    return decorator(arity);
}
exports.Curry = Curry;
exports.curry = Curry;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/curry":1615}],1335:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var curry = require("lodash/curry");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(curry, new applicators_1.PreValueApplicator()));
/**
 * Creates a function that accepts arguments of func and either invokes func returning its result, if at least arity number of arguments have been provided, or returns a function that accepts the remaining func arguments, and so on.
 * The arity of func may be specified if func.length is not sufficient.
 *
 * The _.curry.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for provided arguments.
 *
 * Note: This method doesn't set the "length" property of curried functions.
 * Note: The original function invoked will not be called in the context of the instance. Use `Curry` to for using it bound.
 * @param {number} [arity] The arity of func.
 * @example
 *
 * class MyClass {
 *   @CurryAll()
 *   add(a, b) {
 *     return (a + b);
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * const add5 = myClass.add(5);
 *
 * add5AndMultiply(10); // => 15
 */
function CurryAll(arity) {
    return decorator(arity);
}
exports.CurryAll = CurryAll;
exports.curryAll = CurryAll;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/curry":1615}],1336:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var curryRight = require("lodash/curryRight");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(curryRight, new applicators_1.PreValueApplicator(), { bound: true }));
/**
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight instead of _.partial.
 * The arity of func may be specified if func.length is not sufficient.
 * The original function is bound to the instance. If the method is needed to call in a different context use `CurryAll`.
 *
 * The _.curryRight.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for provided arguments.
 *
 * Note: This method doesn't set the "length" property of curried functions.
 * @param {number} [arity] The arity of func.
 * @example
 *
 * class MyClass {
 *   multiplier = 2;
 *
 *   @CurryRight()
 *   add(a, b) {
 *     return (a + b) * this.multiplier;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * const add5 = myClass.add(5);
 *
 * add5AndMultiply(10); // => 30
 */
function CurryRight(arity) {
    return decorator(arity);
}
exports.CurryRight = CurryRight;
exports.curryRight = CurryRight;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/curryRight":1616}],1337:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var curryRight = require("lodash/curryRight");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(curryRight, new applicators_1.PreValueApplicator()));
/**
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight instead of _.partial.
 * The arity of func may be specified if func.length is not sufficient.
 * The original function is bound to the instance. If the method is needed to call in a different context use `CurryAll`.
 *
 * The _.curryRight.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for provided arguments.
 *
 * Note: This method doesn't set the "length" property of curried functions.
 * @param {number} [arity] The arity of func.
 * @example
 *
 * class MyClass {
 *   @CurryRightAll()
 *   add(a, b) {
 *     return (a + b);
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * const add5 = myClass.add(5);
 *
 * add5AndMultiply(10); // => 15
 */
function CurryRightAll(arity) {
    return decorator(arity);
}
exports.CurryRightAll = CurryRightAll;
exports.curryRightAll = CurryRightAll;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/curryRight":1616}],1338:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debounce = require("lodash/debounce");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(debounce, new applicators_1.PreValueApplicator(), { setter: true }));
/**
 * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since the last time the debounced function was invoked.
 * The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them.
 * Provide options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function.
 * Subsequent calls to the debounced function return the result of the last func invocation.
 *
 * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if the debounced function is invoked more than once during the wait timeout.
 *
 * If wait is 0 and leading is false, func invocation is deferred until to the next tick, similar to setTimeout with a timeout of 0.
 *
 * @param {number} [wait=0] The number in milliseconds to delay.
 * @param {DebounceOptions} [options] The options object.
 * @example
 *
 * class MyClass {
 *   value = 100;
 *
 *   @Debounce(10)
 *   add(a) {
 *     this.value += a;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.add(10);
 * myClass.add(50);
 * myClass.add(20);
 *
 * myClass.value; // => 100;
 *
 * setTimeout(() => {
 *   myClass.value; // => 120;
 * }, 11);
 */
function Debounce(wait, options) {
    return decorator(wait, options);
}
exports.Debounce = Debounce;
exports.debounce = Debounce;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/debounce":1617}],1339:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debounce = require("lodash/debounce");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(debounce, new applicators_1.PreValueApplicator()));
/**
 * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since the last time the debounced function was invoked.
 * The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them.
 * Provide options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function.
 * Subsequent calls to the debounced function return the result of the last func invocation.
 *
 * The debounce state is shared across all instances of the class.
 *
 * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if the debounced function is invoked more than once during the wait timeout.
 *
 * If wait is 0 and leading is false, func invocation is deferred until to the next tick, similar to setTimeout with a timeout of 0.
 *
 * @param {number} [wait=0] The number in milliseconds to delay.
 * @param {DebounceOptions} [options] The options object.
 * @example
 *
 * class MyClass {
 *   value = 100;
 *
 *   @DebounceAll(10)
 *   add(a) {
 *     this.value += a;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.add(10);
 * myClass.add(50);
 * myClass.add(20);
 *
 * myClass.value; // => 100;
 *
 * setTimeout(() => {
 *   myClass.value; // => 120;
 * }, 11);
 */
function DebounceAll(wait, options) {
    return decorator(wait, options);
}
exports.DebounceAll = DebounceAll;
exports.debounceAll = DebounceAll;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/debounce":1617}],1340:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var defer = require("lodash/defer");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(defer, new applicators_1.InvokeApplicator(), { setter: true }));
/**
 * Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to func when it's invoked.
 *
 * @param {...*} [args] Additional arguments to invoke the function with
 * @example
 *
 * class MyClass {
 *   value = 100;
 *
 *   @Defer()
 *   add(a) {
 *     this.value += a;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.add(10);
 *
 * myClass.value; // => 100;
 *
 * setTimeout(() => {
 *   myClass.value; // => 110;
 * }, 0);
 */
function Defer() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return decorator.apply(void 0, args);
}
exports.Defer = Defer;
exports.defer = Defer;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/defer":1619}],1341:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var delay = require("lodash/delay");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(function (value, wait) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return function () {
        var invokeArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            invokeArgs[_i] = arguments[_i];
        }
        return delay.apply(void 0, [value.bind(this), wait].concat(invokeArgs, args));
    };
}, new applicators_1.PreValueApplicator(), { setter: true }));
/**
 * Invokes func after wait milliseconds. Any additional arguments are provided to func when it's invoked.
 *
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {...*} [args] Additional arguments to invoke the function with
 * @example
 *
 * class MyClass {
 *   value = 100;
 *
 *   @Delay(20)
 *   add(a) {
 *     this.value += a;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.add(10);
 *
 * myClass.value; // => 100;
 *
 * setTimeout(() => {
 *   myClass.value; // => 110;
 * }, 30);
 */
function Delay(wait) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return decorator.apply(void 0, [wait].concat(args));
}
exports.Delay = Delay;
exports.delay = Delay;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/delay":1620}],1342:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./factory/DecoratorConfig"));
__export(require("./factory/DecoratorFactory"));
__export(require("./factory/common"));

},{"./factory/DecoratorConfig":1343,"./factory/DecoratorFactory":1344,"./factory/common":1345}],1343:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DecoratorConfig = (function () {
    function DecoratorConfig(execute, applicator, options) {
        if (options === void 0) { options = {}; }
        this.execute = execute;
        this.applicator = applicator;
        this.options = options;
    }
    Object.defineProperty(DecoratorConfig.prototype, "bound", {
        get: function () {
            return this.options.bound != null ? this.options.bound : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DecoratorConfig.prototype, "setter", {
        get: function () {
            return this.options.setter != null ? this.options.setter : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DecoratorConfig.prototype, "getter", {
        get: function () {
            return this.options.getter != null ? this.options.getter : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DecoratorConfig.prototype, "property", {
        get: function () {
            return this.options.property != null ? this.options.property : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DecoratorConfig.prototype, "method", {
        get: function () {
            return this.options.method != null ? this.options.method : true;
        },
        enumerable: true,
        configurable: true
    });
    return DecoratorConfig;
}());
exports.DecoratorConfig = DecoratorConfig;

},{}],1344:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction = require("lodash/isFunction");
var common_1 = require("./common");
var utils_1 = require("../utils");
var InternalDecoratorFactory = (function () {
    function InternalDecoratorFactory() {
    }
    InternalDecoratorFactory.prototype.createDecorator = function (config) {
        var _this = this;
        var applicator = config.applicator;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return function (target, name, _descriptor) {
                var descriptor = _this._resolveDescriptor(target, name, _descriptor);
                var value = descriptor.value, get = descriptor.get, set = descriptor.set;
                // If this decorator is being applied after an instance decorator we simply ignore it
                // as we can't apply it correctly.
                if (!common_1.InstanceChainMap.has([target, name])) {
                    if (isFunction(value)) {
                        descriptor.value = utils_1.copyMetadata(applicator.apply({ config: config, target: target, value: value, args: args }), value);
                    }
                    else if (isFunction(get) && config.getter) {
                        descriptor.get = utils_1.copyMetadata(applicator.apply({ config: config, target: target, value: get, args: args }), get);
                    }
                    else if (isFunction(set) && config.setter) {
                        descriptor.set = utils_1.copyMetadata(applicator.apply({ config: config, target: target, value: set, args: args }), get);
                    }
                }
                return descriptor;
            };
        };
    };
    InternalDecoratorFactory.prototype.createInstanceDecorator = function (config) {
        var _this = this;
        var applicator = config.applicator, bound = config.bound;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return function (target, name, _descriptor) {
                var descriptor = _this._resolveDescriptor(target, name, _descriptor);
                var value = descriptor.value, writable = descriptor.writable, enumerable = descriptor.enumerable, configurable = descriptor.configurable, get = descriptor.get, set = descriptor.set;
                var isFirstInstance = !common_1.InstanceChainMap.has([target, name]);
                var chainData = common_1.InstanceChainMap.get([target, name]) || { fns: [], properties: [] };
                var isGetter = isFirstInstance && isFunction(get);
                var isSetter = isFirstInstance && isFunction(set);
                var isMethod = isFirstInstance && isFunction(value);
                var isProperty = isFirstInstance && !isGetter && !isSetter && !isMethod;
                chainData.properties.push(name);
                chainData.fns.push(function (fn, instance, context) {
                    if (!_this._isApplicable(context, config)) {
                        return fn;
                    }
                    if (bound) {
                        fn = utils_1.bind(fn, instance);
                    }
                    return utils_1.copyMetadata(applicator.apply({ args: args, target: target, instance: instance, value: fn, config: config }), fn);
                });
                common_1.InstanceChainMap.set([target, name], chainData);
                if (!isFirstInstance) {
                    return descriptor;
                }
                chainData.isSetter = isSetter;
                chainData.isGetter = isGetter;
                chainData.isMethod = isMethod;
                chainData.isProperty = isProperty;
                var applyChain = function (fn, context, instance) {
                    return chainData.fns.reduce(function (result, next) { return next(result, instance, context); }, fn);
                };
                var applyDecorator = function (instance) {
                    var getter = get || undefined;
                    var setter = set || undefined;
                    if (isGetter || isSetter) {
                        // If we have a getter apply the decorators to the getter and assign it to the instance.
                        if (isGetter) {
                            getter = applyChain(get, { value: get, getter: true }, instance);
                        }
                        if (isSetter) {
                            setter = applyChain(set, { value: set, setter: true }, instance);
                        }
                        Object.defineProperty(instance, name, {
                            enumerable: enumerable,
                            configurable: configurable,
                            get: getter,
                            set: setter
                        });
                    }
                    else if (isMethod || isProperty) {
                        var newFn = isMethod
                            ? applyChain(value, { value: value, method: true }, instance)
                            : applyChain(value, { value: value, property: true }, instance);
                        Object.defineProperty(instance, name, {
                            writable: writable,
                            enumerable: enumerable,
                            configurable: configurable,
                            value: newFn
                        });
                    }
                };
                if (isMethod || isProperty) {
                    delete descriptor.value;
                    delete descriptor.writable;
                }
                descriptor.get = function () {
                    applyDecorator(this);
                    var descriptor = Object.getOwnPropertyDescriptor(this, name);
                    if (descriptor.get) {
                        return descriptor.get.call(this);
                    }
                    return descriptor.value;
                };
                descriptor.set = function (value) {
                    applyDecorator(this);
                    var descriptor = Object.getOwnPropertyDescriptor(this, name);
                    if (descriptor.set) {
                        descriptor.set.call(this, value);
                    }
                    else if (isProperty || isMethod) {
                        this[name] = value;
                    }
                };
                return descriptor;
            };
        };
    };
    InternalDecoratorFactory.prototype._isApplicable = function (context, config) {
        return !Boolean(context.getter && !config.getter
            || context.setter && !config.setter
            || context.method && !config.method
            || context.property && !config.property);
    };
    InternalDecoratorFactory.prototype._resolveDescriptor = function (target, name, descriptor) {
        if (descriptor) {
            return descriptor;
        }
        return Object.getOwnPropertyDescriptor(target, name) || {};
    };
    return InternalDecoratorFactory;
}());
exports.InternalDecoratorFactory = InternalDecoratorFactory;
exports.DecoratorFactory = new InternalDecoratorFactory();

},{"../utils":1365,"./common":1345,"lodash/isFunction":1656}],1345:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
exports.InstanceChainMap = new utils_1.CompositeKeyWeakMap();

},{"../utils":1365}],1346:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var flip = require("lodash/flip");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(flip, new applicators_1.PartialValueApplicator(), { property: true }));
/**
 * Creates a function that invokes func with arguments reversed. Honestly, there is probably not much
 * use for this decorator but maybe you will find one?
 *
 * @example
 *
 * class MyClass {
 *   value = 100;
 *
 *   @Flip('fn')
 *   fn2: (b: number, a: string) => [ number, string ];
 *
 *   fn(a: string, b: number): [ string, number ] {
 *     return [ a, b ];
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.fn2(10, '20'); // => [ '20', 10 ]
 */
function Flip(fn) {
    return decorator(fn);
}
exports.Flip = Flip;
exports.flip = Flip;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/flip":1631}],1347:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var flow = require("lodash/flow");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(flow, new applicators_1.ComposeApplicator({ post: true }), { property: true }));
/**
 * Creates a function that returns the result of invoking the given functions with the this binding of the created function,
 * where each successive invocation is supplied the return value of the previous.
 *
 * @example
 *
 * class MyClass {
 *   name = 'Ted';
 *
 *   @Flow('getName', toUpperCase)
 *   getUpperCaseName: () => string;
 *
 *   getName() {
 *     return this.name;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.getUpperCaseName(); // => 'TED'
 */
function Flow() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return decorator.apply(void 0, fns);
}
exports.Flow = Flow;
exports.flow = Flow;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/flow":1632}],1348:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var flowRight = require("lodash/flowRight");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(flowRight, new applicators_1.ComposeApplicator({ post: false }), { property: true }));
/**
 * Creates a function that returns the result of invoking the given functions with the this binding of the created function,
 * where each successive invocation is supplied the return value of the previous.
 *
 * @example
 *
 * class MyClass {
 *   name = 'Ted';
 *
 *   @FlowRight(toUpperCase, 'getName')
 *   getUpperCaseName: () => string;
 *
 *   getName() {
 *     return this.name;
 *   }
 * }
 *
 * const myClass = new MyClass();
 *
 * myClass.getUpperCaseName(); // => 'TED'
 */
function FlowRight() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return decorator.apply(void 0, fns);
}
exports.FlowRight = FlowRight;
exports.flowRight = FlowRight;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/flowRight":1633}],1349:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./factory"));
__export(require("./after"));
__export(require("./afterAll"));
__export(require("./ary"));
__export(require("./attempt"));
__export(require("./before"));
__export(require("./beforeAll"));
__export(require("./bind"));
__export(require("./bindAll"));
__export(require("./curry"));
__export(require("./curryAll"));
__export(require("./curryRight"));
__export(require("./curryRightAll"));
__export(require("./debounce"));
__export(require("./debounceAll"));
__export(require("./defer"));
__export(require("./delay"));
__export(require("./flip"));
__export(require("./flow"));
__export(require("./flowRight"));
__export(require("./memoize"));
__export(require("./memoizeAll"));
__export(require("./mixin"));
__export(require("./negate"));
__export(require("./once"));
__export(require("./overArgs"));
__export(require("./partial"));
__export(require("./partialRight"));
__export(require("./rearg"));
__export(require("./rest"));
__export(require("./spread"));
__export(require("./tap"));
__export(require("./throttle"));
__export(require("./throttleAll"));
__export(require("./unary"));
__export(require("./wrap"));

},{"./after":1314,"./afterAll":1315,"./ary":1328,"./attempt":1329,"./before":1330,"./beforeAll":1331,"./bind":1332,"./bindAll":1333,"./curry":1334,"./curryAll":1335,"./curryRight":1336,"./curryRightAll":1337,"./debounce":1338,"./debounceAll":1339,"./defer":1340,"./delay":1341,"./factory":1342,"./flip":1346,"./flow":1347,"./flowRight":1348,"./memoize":1350,"./memoizeAll":1351,"./mixin":1352,"./negate":1353,"./once":1354,"./overArgs":1355,"./partial":1356,"./partialRight":1357,"./rearg":1358,"./rest":1359,"./spread":1360,"./tap":1361,"./throttle":1362,"./throttleAll":1363,"./unary":1364,"./wrap":1374}],1350:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var memoize = require("lodash/memoize");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(memoize, new applicators_1.MemoizeApplicator()));
/**
 * Creates a function that memoizes the result of func. If resolver is provided,
 * it determines the cache key for storing the result based on the arguments provided to the memoized function.
 * By default, the first argument provided to the memoized function is used as the map cache key.
 * The func is invoked with the this binding of the memoized function.
 *
 * You can use a Function or a string that references a method on the class as the resolver.
 * You can also use a configuration object that lets provide a prexisting cache or specify
 * the map type to use.
 *
 * @example
 *
 * class MyClass {
 *   @Memoize({ type: WeakMap })
 *   getName(item) {
 *     return item.name;
 *   }
 *
 *   @Memoize('getName')
 *   getLastName(item) {
 *     return item.lastName;
 *   }
 * }
 */
function Memoize(resolver) {
    return decorator(resolver);
}
exports.Memoize = Memoize;
exports.memoize = Memoize;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/memoize":1673}],1351:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var memoize = require("lodash/memoize");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(memoize, new applicators_1.MemoizeApplicator()));
/**
 * Memoizes a function on the prototype instead of the instance. All instances of the class use the same memoize cache.
 * @param {Function} [resolver] Optional resolver
 */
function MemoizeAll(resolver) {
    return decorator(resolver);
}
exports.MemoizeAll = MemoizeAll;
exports.memoizeAll = MemoizeAll;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/memoize":1673}],1352:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assign = require("lodash/assign");
/**
 * Mixins an object into the classes prototype.
 * @export
 * @param {...Object[]} srcs
 * @returns {ClassDecorator}
 * @example
 *
 * const myMixin = {
 *   blorg: () => 'blorg!'
 * }
 *
 * @Mixin(myMixin)
 * class MyClass {}
 *
 * const myClass = new MyClass();
 *
 * myClass.blorg(); // => 'blorg!'
 */
function Mixin() {
    var srcs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        srcs[_i] = arguments[_i];
    }
    return function (target) {
        assign.apply(void 0, [target.prototype].concat(srcs));
        return target;
    };
}
exports.Mixin = Mixin;
exports.mixin = Mixin;
exports.default = Mixin;

},{"lodash/assign":1606}],1353:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var negate = require("lodash/negate");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(negate, new applicators_1.PartialValueApplicator(), { property: true }));
function Negate(fn) {
    return decorator(fn);
}
exports.Negate = Negate;
exports.negate = Negate;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/negate":1676}],1354:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var once = require("lodash/once");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(once, new applicators_1.PreValueApplicator(), { setter: true }));
function Once() {
    return decorator();
}
exports.Once = Once;
exports.once = Once;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/once":1680}],1355:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var overArgs = require("lodash/overArgs");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(overArgs, new applicators_1.PreValueApplicator(), { setter: true }));
function OverArgs() {
    var transforms = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        transforms[_i] = arguments[_i];
    }
    return decorator.apply(void 0, transforms);
}
exports.OverArgs = OverArgs;
exports.overArgs = OverArgs;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/overArgs":1681}],1356:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var partial = require("lodash/partial");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(partial, new applicators_1.PartialApplicator(), { property: true, method: false }));
function Partial() {
    var partials = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        partials[_i] = arguments[_i];
    }
    return decorator.apply(void 0, partials);
}
exports.Partial = Partial;
exports.partial = Partial;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/partial":1682}],1357:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var partialRight = require("lodash/partialRight");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(partialRight, new applicators_1.PartialApplicator(), { property: true, method: false }));
function PartialRight() {
    var partials = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        partials[_i] = arguments[_i];
    }
    return decorator.apply(void 0, partials);
}
exports.PartialRight = PartialRight;
exports.partialRight = PartialRight;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/partialRight":1683}],1358:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rearg = require("lodash/rearg");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(rearg, new applicators_1.PartialValueApplicator(), { property: true }));
function Rearg(indexes) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return decorator.apply(void 0, [indexes].concat(args));
}
exports.Rearg = Rearg;
exports.rearg = Rearg;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/rearg":1687}],1359:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rest = require("lodash/rest");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(rest, new applicators_1.PreValueApplicator()));
function Rest(start) {
    return decorator(start);
}
exports.Rest = Rest;
exports.rest = Rest;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/rest":1691}],1360:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var spread = require("lodash/spread");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(spread, new applicators_1.PreValueApplicator()));
function Spread(start) {
    return decorator(start);
}
exports.Spread = Spread;
exports.spread = Spread;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/spread":1698}],1361:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var utils_1 = require("./utils");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(function (fn) { return utils_1.returnAtIndex(fn, 0); }, new applicators_1.PreValueApplicator()));
/**
 * Returns the first argument from the function regardless of
 * the decorated functions return value.
 */
function Tap() {
    return decorator();
}
exports.Tap = Tap;
exports.tap = Tap;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"./utils":1365}],1362:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var throttle = require("lodash/throttle");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(throttle, new applicators_1.PreValueApplicator(), { setter: true, getter: true }));
var decoratorGetter = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(throttle, new applicators_1.PreValueApplicator(), { getter: true }));
var decoratorSetter = factory_1.DecoratorFactory.createInstanceDecorator(new factory_1.DecoratorConfig(throttle, new applicators_1.PreValueApplicator(), { setter: true }));
function Throttle(wait, options) {
    return decorator(wait, options);
}
exports.Throttle = Throttle;
exports.throttle = Throttle;
function ThrottleGetter(wait, options) {
    return decoratorGetter(wait, options);
}
exports.ThrottleGetter = ThrottleGetter;
exports.throttleGetter = ThrottleGetter;
function ThrottleSetter(wait, options) {
    return decoratorSetter(wait, options);
}
exports.ThrottleSetter = ThrottleSetter;
exports.throttleSetter = ThrottleSetter;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/throttle":1703}],1363:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var throttle = require("lodash/throttle");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(throttle, new applicators_1.PreValueApplicator(), { setter: true }));
function ThrottleAll(wait, options) {
    return decorator(wait, options);
}
exports.ThrottleAll = ThrottleAll;
exports.throttleAll = ThrottleAll;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/throttle":1703}],1364:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var unary = require("lodash/unary");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(unary, new applicators_1.PreValueApplicator()));
function Unary() {
    return decorator();
}
exports.Unary = Unary;
exports.unary = Unary;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/unary":1709}],1365:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./utils/log"));
__export(require("./utils/resolveFunction"));
__export(require("./utils/CompositeKeyWeakMap"));
__export(require("./utils/returnAtIndex"));
__export(require("./utils/copyMetaData"));
__export(require("./utils/bind"));
__export(require("./utils/wrapConstructor"));
__export(require("./utils/assignAll"));

},{"./utils/CompositeKeyWeakMap":1366,"./utils/assignAll":1367,"./utils/bind":1368,"./utils/copyMetaData":1369,"./utils/log":1370,"./utils/resolveFunction":1371,"./utils/returnAtIndex":1372,"./utils/wrapConstructor":1373}],1366:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isUndefined = require("lodash/isUndefined");
/**
 * A map for weakly holding nested references.
 * @private
 * @export
 * @class CompositeKeyWeakMap
 * @template T
 */
var CompositeKeyWeakMap = (function () {
    function CompositeKeyWeakMap() {
        this._weakMap = new WeakMap();
    }
    CompositeKeyWeakMap.prototype.set = function (keys, value) {
        var map = this._weakMap;
        for (var i = 0, len = keys.length - 1; i < len; i++) {
            var key = keys[i];
            var next = map.get(key);
            if (!next) {
                next = new Map();
                map.set(key, next);
            }
            map = next;
        }
        map.set(keys[keys.length - 1], value);
    };
    CompositeKeyWeakMap.prototype.get = function (keys) {
        var next = this._weakMap;
        for (var i = 0, len = keys.length; i < len; i++) {
            next = next.get(keys[i]);
            if (isUndefined(next)) {
                break;
            }
        }
        return next;
    };
    CompositeKeyWeakMap.prototype.has = function (keys) {
        return !isUndefined(this.get(keys));
    };
    return CompositeKeyWeakMap;
}());
exports.CompositeKeyWeakMap = CompositeKeyWeakMap;

},{"lodash/isUndefined":1665}],1367:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var without = require("lodash/without");
var attempt = require("lodash/attempt");
var isObject = require("lodash/isObject");
/**
 * Assigns all properties from an object to another object including non enumerable
 * properties.
 * @export
 * @template T
 * @template U
 * @param {T} to
 * @param {U} from
 * @param {string[]} [excludes=[]]
 * @returns {T}
 */
function assignAll(to, from, excludes) {
    if (excludes === void 0) { excludes = []; }
    var properties = without.apply(void 0, [Object.getOwnPropertyNames(from)].concat(excludes));
    for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
        var prop = properties_1[_i];
        attempt(assignProperty, to, from, prop);
    }
    return to;
}
exports.assignAll = assignAll;
/**
 * Assigns a property from one object to another while retaining descriptor properties.
 * @export
 * @template T
 * @template U
 * @param {T} to
 * @param {U} from
 * @param {string} prop
 */
function assignProperty(to, from, prop) {
    var descriptor = Object.getOwnPropertyDescriptor(to, prop);
    if (!descriptor || descriptor.configurable) {
        var srcDescriptor = Object.getOwnPropertyDescriptor(from, prop);
        if (isObject(srcDescriptor)) {
            Object.defineProperty(to, prop, srcDescriptor);
        }
        else {
            to[prop] = from[prop];
        }
    }
}
exports.assignProperty = assignProperty;

},{"lodash/attempt":1608,"lodash/isObject":1659,"lodash/without":1714}],1368:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var copyMetaData_1 = require("./copyMetaData");
/**
 * Binds a function and copies metadata.
 * @private
 * @export
 * @param {Function} fn
 * @param {*} context
 * @returns {Function}
 */
function bind(fn, context) {
    return copyMetaData_1.copyMetadata(fn.bind(context), fn);
}
exports.bind = bind;

},{"./copyMetaData":1369}],1369:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var forOwn = require("lodash/forOwn");
/**
 * Used to copy over meta data from function to function.
 * If meta data is attached to a function. This can get lost
 * when wrapping functions. This tries to persist that.
 * @private
 */
function copyMetadata(to, from) {
    forOwn(from, function (value, key) { return to[key] = value; });
    return to;
}
exports.copyMetadata = copyMetadata;

},{"lodash/forOwn":1635}],1370:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Creates a log message.
 * @private
 * @export
 * @param {string} [message='']
 * @returns {string}
 */
function log(message) {
    if (message === void 0) { message = ''; }
    return "lodash-decorators -> " + message;
}
exports.log = log;

},{}],1371:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction = require("lodash/isFunction");
var isString = require("lodash/isString");
var log_1 = require("./log");
/**
  * Resolves a function on the current target object. It first will
  * try and resolve on the context object, then the target object,
  * then an error will be thrown if the method can not be resolved.
  * @private
  * @param {Function|string} method The method or method name.
  * @param {Object} [context] The context object to resolve from.
  * @param {Object} [target] The target object to resolve from.
  * @returns {Function} The resolved function.
  */
function resolveFunction(method, context, target, throwNotFound) {
    if (throwNotFound === void 0) { throwNotFound = true; }
    if (isFunction(method)) {
        return method;
    }
    else if (isString(method)) {
        if (context && isFunction(context[method])) {
            return context[method];
        }
        else if (target && isFunction(target[method])) {
            return target[method];
        }
    }
    if (throwNotFound) {
        throw new ReferenceError(log_1.log("Can not resolve method " + method + " on any target Objects"));
    }
}
exports.resolveFunction = resolveFunction;

},{"./log":1370,"lodash/isFunction":1656,"lodash/isString":1662}],1372:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Creates a function the returns the specific index.
 * @private
 * @export
 * @param {Function} fn
 * @param {number} index
 * @returns {Function}
 */
function returnAtIndex(fn, index) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        fn.call.apply(fn, [this].concat(args));
        return args[index];
    };
}
exports.returnAtIndex = returnAtIndex;

},{}],1373:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assignAll_1 = require("./assignAll");
var PROPERTY_EXCLUDES = [
    'length',
    'name',
    'arguments',
    'called',
    'prototype'
];
/**
 * Wraps a constructor in a wrapper function and copies all static properties
 * and methods to the new constructor.
 * @export
 * @param {Function} Ctor
 * @param {(Ctor: Function, ...args: any[]) => any} wrapper
 * @returns {Function}
 */
function wrapConstructor(Ctor, wrapper) {
    function ConstructorWrapper() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return wrapper.call.apply(wrapper, [this, Ctor].concat(args));
    }
    ConstructorWrapper.prototype = Ctor.prototype;
    Object.defineProperty(ConstructorWrapper, 'name', {
        // These values should coincide with the default descriptor values for `name`.
        configurable: true,
        enumerable: false,
        value: Ctor.name,
        writable: false
    });
    return assignAll_1.assignAll(ConstructorWrapper, Ctor, PROPERTY_EXCLUDES);
}
exports.wrapConstructor = wrapConstructor;

},{"./assignAll":1367}],1374:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var wrap = require("lodash/wrap");
var factory_1 = require("./factory");
var applicators_1 = require("./applicators");
var decorator = factory_1.DecoratorFactory.createDecorator(new factory_1.DecoratorConfig(wrap, new applicators_1.WrapApplicator()));
function Wrap(fnToWrap) {
    return decorator(fnToWrap);
}
exports.Wrap = Wrap;
exports.wrap = Wrap;
exports.default = decorator;

},{"./applicators":1316,"./factory":1342,"lodash/wrap":1715}],1375:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":1530,"./_root":1583}],1376:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":1539,"./_hashDelete":1540,"./_hashGet":1541,"./_hashHas":1542,"./_hashSet":1543}],1377:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    baseLodash = require('./_baseLodash');

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}

// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = baseCreate(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;

module.exports = LazyWrapper;

},{"./_baseCreate":1414,"./_baseLodash":1447}],1378:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":1557,"./_listCacheDelete":1558,"./_listCacheGet":1559,"./_listCacheHas":1560,"./_listCacheSet":1561}],1379:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    baseLodash = require('./_baseLodash');

/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = undefined;
}

LodashWrapper.prototype = baseCreate(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;

module.exports = LodashWrapper;

},{"./_baseCreate":1414,"./_baseLodash":1447}],1380:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":1530,"./_root":1583}],1381:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":1562,"./_mapCacheDelete":1563,"./_mapCacheGet":1564,"./_mapCacheHas":1565,"./_mapCacheSet":1566}],1382:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":1530,"./_root":1583}],1383:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":1530,"./_root":1583}],1384:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":1381,"./_setCacheAdd":1584,"./_setCacheHas":1585}],1385:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":1378,"./_stackClear":1592,"./_stackDelete":1593,"./_stackGet":1594,"./_stackHas":1595,"./_stackSet":1596}],1386:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":1583}],1387:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":1583}],1388:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":1530,"./_root":1583}],1389:[function(require,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],1390:[function(require,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],1391:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],1392:[function(require,module,exports){
/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

module.exports = arrayAggregator;

},{}],1393:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],1394:[function(require,module,exports){
/**
 * A specialized version of `_.every` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 */
function arrayEvery(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}

module.exports = arrayEvery;

},{}],1395:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],1396:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

},{"./_baseIndexOf":1434}],1397:[function(require,module,exports){
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

},{}],1398:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":1471,"./_isIndex":1549,"./isArguments":1647,"./isArray":1648,"./isBuffer":1651,"./isTypedArray":1664}],1399:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],1400:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],1401:[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],1402:[function(require,module,exports){
/**
 * A specialized version of `_.reduceRight` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the last element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduceRight(array, iteratee, accumulator, initAccum) {
  var length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[--length];
  }
  while (length--) {
    accumulator = iteratee(accumulator, array[length], length, array);
  }
  return accumulator;
}

module.exports = arrayReduceRight;

},{}],1403:[function(require,module,exports){
var baseRandom = require('./_baseRandom');

/**
 * A specialized version of `_.sample` for arrays.
 *
 * @private
 * @param {Array} array The array to sample.
 * @returns {*} Returns the random element.
 */
function arraySample(array) {
  var length = array.length;
  return length ? array[baseRandom(0, length - 1)] : undefined;
}

module.exports = arraySample;

},{"./_baseRandom":1460}],1404:[function(require,module,exports){
var copyArray = require('./_copyArray'),
    shuffleSelf = require('./_shuffleSelf');

/**
 * A specialized version of `_.shuffle` for arrays.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function arrayShuffle(array) {
  return shuffleSelf(copyArray(array));
}

module.exports = arrayShuffle;

},{"./_copyArray":1494,"./_shuffleSelf":1591}],1405:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],1406:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

},{"./_baseAssignValue":1412,"./eq":1623}],1407:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":1412,"./eq":1623}],1408:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":1623}],1409:[function(require,module,exports){
var baseEach = require('./_baseEach');

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

module.exports = baseAggregator;

},{"./_baseEach":1417}],1410:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":1495,"./keys":1667}],1411:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":1495,"./keysIn":1668}],1412:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":1516}],1413:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isObject = require('./isObject'),
    keys = require('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":1385,"./_arrayEach":1393,"./_assignValue":1407,"./_baseAssign":1410,"./_baseAssignIn":1411,"./_cloneBuffer":1483,"./_copyArray":1494,"./_copySymbols":1496,"./_copySymbolsIn":1497,"./_getAllKeys":1523,"./_getAllKeysIn":1524,"./_getTag":1535,"./_initCloneArray":1544,"./_initCloneByTag":1545,"./_initCloneObject":1546,"./isArray":1648,"./isBuffer":1651,"./isObject":1659,"./keys":1667}],1414:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":1659}],1415:[function(require,module,exports){
/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * The base implementation of `_.delay` and `_.defer` which accepts `args`
 * to provide to `func`.
 *
 * @private
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {Array} args The arguments to provide to `func`.
 * @returns {number|Object} Returns the timer id or timeout object.
 */
function baseDelay(func, wait, args) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return setTimeout(function() { func.apply(undefined, args); }, wait);
}

module.exports = baseDelay;

},{}],1416:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;

},{"./_SetCache":1384,"./_arrayIncludes":1396,"./_arrayIncludesWith":1397,"./_arrayMap":1399,"./_baseUnary":1473,"./_cacheHas":1477}],1417:[function(require,module,exports){
var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":1425,"./_createBaseEach":1502}],1418:[function(require,module,exports){
var baseForOwnRight = require('./_baseForOwnRight'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEachRight` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEachRight = createBaseEach(baseForOwnRight, true);

module.exports = baseEachRight;

},{"./_baseForOwnRight":1426,"./_createBaseEach":1502}],1419:[function(require,module,exports){
var baseEach = require('./_baseEach');

/**
 * The base implementation of `_.every` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`
 */
function baseEvery(collection, predicate) {
  var result = true;
  baseEach(collection, function(value, index, collection) {
    result = !!predicate(value, index, collection);
    return result;
  });
  return result;
}

module.exports = baseEvery;

},{"./_baseEach":1417}],1420:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

module.exports = baseExtremum;

},{"./isSymbol":1663}],1421:[function(require,module,exports){
var baseEach = require('./_baseEach');

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;

},{"./_baseEach":1417}],1422:[function(require,module,exports){
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

},{}],1423:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":1400,"./_isFlattenable":1548}],1424:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":1503}],1425:[function(require,module,exports){
var baseFor = require('./_baseFor'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":1424,"./keys":1667}],1426:[function(require,module,exports){
var baseForRight = require('./_baseForRight'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwnRight(object, iteratee) {
  return object && baseForRight(object, iteratee, keys);
}

module.exports = baseForOwnRight;

},{"./_baseForRight":1427,"./keys":1667}],1427:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * This function is like `baseFor` except that it iterates over properties
 * in the opposite order.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseForRight = createBaseFor(true);

module.exports = baseForRight;

},{"./_createBaseFor":1503}],1428:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":1479,"./_toKey":1600}],1429:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":1400,"./isArray":1648}],1430:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":1386,"./_getRawTag":1532,"./_objectToString":1576}],1431:[function(require,module,exports){
/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

module.exports = baseGt;

},{}],1432:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;

},{}],1433:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],1434:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":1422,"./_baseIsNaN":1441,"./_strictIndexOf":1597}],1435:[function(require,module,exports){
var apply = require('./_apply'),
    castPath = require('./_castPath'),
    last = require('./last'),
    parent = require('./_parent'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.invoke` without support for individual
 * method arguments.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {Array} args The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 */
function baseInvoke(object, path, args) {
  path = castPath(path, object);
  object = parent(object, path);
  var func = object == null ? object : object[toKey(last(path))];
  return func == null ? undefined : apply(func, object, args);
}

module.exports = baseInvoke;

},{"./_apply":1391,"./_castPath":1479,"./_parent":1579,"./_toKey":1600,"./last":1669}],1436:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":1430,"./isObjectLike":1660}],1437:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var dateTag = '[object Date]';

/**
 * The base implementation of `_.isDate` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
 */
function baseIsDate(value) {
  return isObjectLike(value) && baseGetTag(value) == dateTag;
}

module.exports = baseIsDate;

},{"./_baseGetTag":1430,"./isObjectLike":1660}],1438:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":1439,"./isObjectLike":1660}],1439:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":1385,"./_equalArrays":1517,"./_equalByTag":1518,"./_equalObjects":1519,"./_getTag":1535,"./isArray":1648,"./isBuffer":1651,"./isTypedArray":1664}],1440:[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":1385,"./_baseIsEqual":1438}],1441:[function(require,module,exports){
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],1442:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":1554,"./_toSource":1601,"./isFunction":1656,"./isObject":1659}],1443:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":1430,"./isLength":1657,"./isObjectLike":1660}],1444:[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":1450,"./_baseMatchesProperty":1451,"./identity":1641,"./isArray":1648,"./property":1686}],1445:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":1555,"./_nativeKeys":1573}],1446:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":1555,"./_nativeKeysIn":1574,"./isObject":1659}],1447:[function(require,module,exports){
/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */
function baseLodash() {
  // No operation performed.
}

module.exports = baseLodash;

},{}],1448:[function(require,module,exports){
/**
 * The base implementation of `_.lt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */
function baseLt(value, other) {
  return value < other;
}

module.exports = baseLt;

},{}],1449:[function(require,module,exports){
var baseEach = require('./_baseEach'),
    isArrayLike = require('./isArrayLike');

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

},{"./_baseEach":1417,"./isArrayLike":1649}],1450:[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":1440,"./_getMatchData":1529,"./_matchesStrictComparable":1568}],1451:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":1438,"./_isKey":1551,"./_isStrictComparable":1556,"./_matchesStrictComparable":1568,"./_toKey":1600,"./get":1636,"./hasIn":1639}],1452:[function(require,module,exports){
var Stack = require('./_Stack'),
    assignMergeValue = require('./_assignMergeValue'),
    baseFor = require('./_baseFor'),
    baseMergeDeep = require('./_baseMergeDeep'),
    isObject = require('./isObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

},{"./_Stack":1385,"./_assignMergeValue":1406,"./_baseFor":1424,"./_baseMergeDeep":1453,"./isObject":1659,"./keysIn":1668}],1453:[function(require,module,exports){
var assignMergeValue = require('./_assignMergeValue'),
    cloneBuffer = require('./_cloneBuffer'),
    cloneTypedArray = require('./_cloneTypedArray'),
    copyArray = require('./_copyArray'),
    initCloneObject = require('./_initCloneObject'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLikeObject = require('./isArrayLikeObject'),
    isBuffer = require('./isBuffer'),
    isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isPlainObject = require('./isPlainObject'),
    isTypedArray = require('./isTypedArray'),
    toPlainObject = require('./toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

},{"./_assignMergeValue":1406,"./_cloneBuffer":1483,"./_cloneTypedArray":1489,"./_copyArray":1494,"./_initCloneObject":1546,"./isArguments":1647,"./isArray":1648,"./isArrayLikeObject":1650,"./isBuffer":1651,"./isFunction":1656,"./isObject":1659,"./isPlainObject":1661,"./isTypedArray":1664,"./toPlainObject":1707}],1454:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseIteratee = require('./_baseIteratee'),
    baseMap = require('./_baseMap'),
    baseSortBy = require('./_baseSortBy'),
    baseUnary = require('./_baseUnary'),
    compareMultiple = require('./_compareMultiple'),
    identity = require('./identity');

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;

},{"./_arrayMap":1399,"./_baseIteratee":1444,"./_baseMap":1449,"./_baseSortBy":1470,"./_baseUnary":1473,"./_compareMultiple":1491,"./identity":1641}],1455:[function(require,module,exports){
var basePickBy = require('./_basePickBy'),
    hasIn = require('./hasIn');

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;

},{"./_basePickBy":1456,"./hasIn":1639}],1456:[function(require,module,exports){
var baseGet = require('./_baseGet'),
    baseSet = require('./_baseSet'),
    castPath = require('./_castPath');

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;

},{"./_baseGet":1428,"./_baseSet":1464,"./_castPath":1479}],1457:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],1458:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":1428}],1459:[function(require,module,exports){
/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;

},{}],1460:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

module.exports = baseRandom;

},{}],1461:[function(require,module,exports){
/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;

},{}],1462:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":1578,"./_setToString":1588,"./identity":1641}],1463:[function(require,module,exports){
var arraySample = require('./_arraySample'),
    values = require('./values');

/**
 * The base implementation of `_.sample`.
 *
 * @private
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 */
function baseSample(collection) {
  return arraySample(values(collection));
}

module.exports = baseSample;

},{"./_arraySample":1403,"./values":1713}],1464:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    castPath = require('./_castPath'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;

},{"./_assignValue":1407,"./_castPath":1479,"./_isIndex":1549,"./_toKey":1600,"./isObject":1659}],1465:[function(require,module,exports){
var identity = require('./identity'),
    metaMap = require('./_metaMap');

/**
 * The base implementation of `setData` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

module.exports = baseSetData;

},{"./_metaMap":1571,"./identity":1641}],1466:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":1516,"./constant":1613,"./identity":1641}],1467:[function(require,module,exports){
var shuffleSelf = require('./_shuffleSelf'),
    values = require('./values');

/**
 * The base implementation of `_.shuffle`.
 *
 * @private
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function baseShuffle(collection) {
  return shuffleSelf(values(collection));
}

module.exports = baseShuffle;

},{"./_shuffleSelf":1591,"./values":1713}],1468:[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],1469:[function(require,module,exports){
var baseEach = require('./_baseEach');

/**
 * The base implementation of `_.some` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function baseSome(collection, predicate) {
  var result;

  baseEach(collection, function(value, index, collection) {
    result = predicate(value, index, collection);
    return !result;
  });
  return !!result;
}

module.exports = baseSome;

},{"./_baseEach":1417}],1470:[function(require,module,exports){
/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;

},{}],1471:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],1472:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":1386,"./_arrayMap":1399,"./isArray":1648,"./isSymbol":1663}],1473:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],1474:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    cacheHas = require('./_cacheHas'),
    createSet = require('./_createSet'),
    setToArray = require('./_setToArray');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;

},{"./_SetCache":1384,"./_arrayIncludes":1396,"./_arrayIncludesWith":1397,"./_cacheHas":1477,"./_createSet":1512,"./_setToArray":1587}],1475:[function(require,module,exports){
var castPath = require('./_castPath'),
    last = require('./last'),
    parent = require('./_parent'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;

},{"./_castPath":1479,"./_parent":1579,"./_toKey":1600,"./last":1669}],1476:[function(require,module,exports){
var arrayMap = require('./_arrayMap');

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;

},{"./_arrayMap":1399}],1477:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],1478:[function(require,module,exports){
var identity = require('./identity');

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

},{"./identity":1641}],1479:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":1551,"./_stringToPath":1599,"./isArray":1648,"./toString":1708}],1480:[function(require,module,exports){
var baseRest = require('./_baseRest');

/**
 * A `baseRest` alias which can be replaced with `identity` by module
 * replacement plugins.
 *
 * @private
 * @type {Function}
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
var castRest = baseRest;

module.exports = castRest;

},{"./_baseRest":1462}],1481:[function(require,module,exports){
var baseSlice = require('./_baseSlice');

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;

},{"./_baseSlice":1468}],1482:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":1387}],1483:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":1583}],1484:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":1482}],1485:[function(require,module,exports){
var addMapEntry = require('./_addMapEntry'),
    arrayReduce = require('./_arrayReduce'),
    mapToArray = require('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":1389,"./_arrayReduce":1401,"./_mapToArray":1567}],1486:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],1487:[function(require,module,exports){
var addSetEntry = require('./_addSetEntry'),
    arrayReduce = require('./_arrayReduce'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":1390,"./_arrayReduce":1401,"./_setToArray":1587}],1488:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":1386}],1489:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":1482}],1490:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;

},{"./isSymbol":1663}],1491:[function(require,module,exports){
var compareAscending = require('./_compareAscending');

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;

},{"./_compareAscending":1490}],1492:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersLength = holders.length,
      leftIndex = -1,
      leftLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(leftLength + rangeLength),
      isUncurried = !isCurried;

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

module.exports = composeArgs;

},{}],1493:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersIndex = -1,
      holdersLength = holders.length,
      rightIndex = -1,
      rightLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(rangeLength + rightLength),
      isUncurried = !isCurried;

  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}

module.exports = composeArgsRight;

},{}],1494:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],1495:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":1407,"./_baseAssignValue":1412}],1496:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":1495,"./_getSymbols":1533}],1497:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":1495,"./_getSymbolsIn":1534}],1498:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":1583}],1499:[function(require,module,exports){
/**
 * Gets the number of `placeholder` occurrences in `array`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} placeholder The placeholder to search for.
 * @returns {number} Returns the placeholder count.
 */
function countHolders(array, placeholder) {
  var length = array.length,
      result = 0;

  while (length--) {
    if (array[length] === placeholder) {
      ++result;
    }
  }
  return result;
}

module.exports = countHolders;

},{}],1500:[function(require,module,exports){
var arrayAggregator = require('./_arrayAggregator'),
    baseAggregator = require('./_baseAggregator'),
    baseIteratee = require('./_baseIteratee'),
    isArray = require('./isArray');

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
  };
}

module.exports = createAggregator;

},{"./_arrayAggregator":1392,"./_baseAggregator":1409,"./_baseIteratee":1444,"./isArray":1648}],1501:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":1462,"./_isIterateeCall":1550}],1502:[function(require,module,exports){
var isArrayLike = require('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":1649}],1503:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],1504:[function(require,module,exports){
var createCtor = require('./_createCtor'),
    root = require('./_root');

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG,
      Ctor = createCtor(func);

  function wrapper() {
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}

module.exports = createBind;

},{"./_createCtor":1505,"./_root":1583}],1505:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    isObject = require('./isObject');

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtor(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

module.exports = createCtor;

},{"./_baseCreate":1414,"./isObject":1659}],1506:[function(require,module,exports){
var apply = require('./_apply'),
    createCtor = require('./_createCtor'),
    createHybrid = require('./_createHybrid'),
    createRecurry = require('./_createRecurry'),
    getHolder = require('./_getHolder'),
    replaceHolders = require('./_replaceHolders'),
    root = require('./_root');

/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length,
        placeholder = getHolder(wrapper);

    while (index--) {
      args[index] = arguments[index];
    }
    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
      ? []
      : replaceHolders(args, placeholder);

    length -= holders.length;
    if (length < arity) {
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, undefined,
        args, holders, undefined, undefined, arity - length);
    }
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return apply(fn, this, args);
  }
  return wrapper;
}

module.exports = createCurry;

},{"./_apply":1391,"./_createCtor":1505,"./_createHybrid":1509,"./_createRecurry":1511,"./_getHolder":1527,"./_replaceHolders":1582,"./_root":1583}],1507:[function(require,module,exports){
var baseIteratee = require('./_baseIteratee'),
    isArrayLike = require('./isArrayLike'),
    keys = require('./keys');

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;

},{"./_baseIteratee":1444,"./isArrayLike":1649,"./keys":1667}],1508:[function(require,module,exports){
var LodashWrapper = require('./_LodashWrapper'),
    flatRest = require('./_flatRest'),
    getData = require('./_getData'),
    getFuncName = require('./_getFuncName'),
    isArray = require('./isArray'),
    isLaziable = require('./_isLaziable');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_FLAG = 8,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256;

/**
 * Creates a `_.flow` or `_.flowRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new flow function.
 */
function createFlow(fromRight) {
  return flatRest(function(funcs) {
    var length = funcs.length,
        index = length,
        prereq = LodashWrapper.prototype.thru;

    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func = funcs[index];
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
        var wrapper = new LodashWrapper([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func = funcs[index];

      var funcName = getFuncName(func),
          data = funcName == 'wrapper' ? getData(func) : undefined;

      if (data && isLaziable(data[0]) &&
            data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
            !data[4].length && data[9] == 1
          ) {
        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = (func.length == 1 && isLaziable(func))
          ? wrapper[funcName]()
          : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments,
          value = args[0];

      if (wrapper && args.length == 1 && isArray(value)) {
        return wrapper.plant(value).value();
      }
      var index = 0,
          result = length ? funcs[index].apply(this, args) : value;

      while (++index < length) {
        result = funcs[index].call(this, result);
      }
      return result;
    };
  });
}

module.exports = createFlow;

},{"./_LodashWrapper":1379,"./_flatRest":1521,"./_getData":1525,"./_getFuncName":1526,"./_isLaziable":1553,"./isArray":1648}],1509:[function(require,module,exports){
var composeArgs = require('./_composeArgs'),
    composeArgsRight = require('./_composeArgsRight'),
    countHolders = require('./_countHolders'),
    createCtor = require('./_createCtor'),
    createRecurry = require('./_createRecurry'),
    getHolder = require('./_getHolder'),
    reorder = require('./_reorder'),
    replaceHolders = require('./_replaceHolders'),
    root = require('./_root');

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_ARY_FLAG = 128,
    WRAP_FLIP_FLAG = 512;

/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided
 *  to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG,
      isBind = bitmask & WRAP_BIND_FLAG,
      isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
      isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
      isFlip = bitmask & WRAP_FLIP_FLAG,
      Ctor = isBindKey ? undefined : createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length;

    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder(wrapper),
          holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders(args, placeholder);
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
        args, newHolders, argPos, ary, arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary < length) {
      args.length = ary;
    }
    if (this && this !== root && this instanceof wrapper) {
      fn = Ctor || createCtor(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

module.exports = createHybrid;

},{"./_composeArgs":1492,"./_composeArgsRight":1493,"./_countHolders":1499,"./_createCtor":1505,"./_createRecurry":1511,"./_getHolder":1527,"./_reorder":1581,"./_replaceHolders":1582,"./_root":1583}],1510:[function(require,module,exports){
var apply = require('./_apply'),
    createCtor = require('./_createCtor'),
    root = require('./_root');

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG,
      Ctor = createCtor(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

module.exports = createPartial;

},{"./_apply":1391,"./_createCtor":1505,"./_root":1583}],1511:[function(require,module,exports){
var isLaziable = require('./_isLaziable'),
    setData = require('./_setData'),
    setWrapToString = require('./_setWrapToString');

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_BOUND_FLAG = 4,
    WRAP_CURRY_FLAG = 8,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64;

/**
 * Creates a function that wraps `func` to continue currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {Function} wrapFunc The function to create the `func` wrapper.
 * @param {*} placeholder The placeholder value.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG,
      newHolders = isCurry ? holders : undefined,
      newHoldersRight = isCurry ? undefined : holders,
      newPartials = isCurry ? partials : undefined,
      newPartialsRight = isCurry ? undefined : partials;

  bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
  }
  var newData = [
    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
    newHoldersRight, argPos, ary, arity
  ];

  var result = wrapFunc.apply(undefined, newData);
  if (isLaziable(func)) {
    setData(result, newData);
  }
  result.placeholder = placeholder;
  return setWrapToString(result, func, bitmask);
}

module.exports = createRecurry;

},{"./_isLaziable":1553,"./_setData":1586,"./_setWrapToString":1589}],1512:[function(require,module,exports){
var Set = require('./_Set'),
    noop = require('./noop'),
    setToArray = require('./_setToArray');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;

},{"./_Set":1383,"./_setToArray":1587,"./noop":1677}],1513:[function(require,module,exports){
var baseSetData = require('./_baseSetData'),
    createBind = require('./_createBind'),
    createCurry = require('./_createCurry'),
    createHybrid = require('./_createHybrid'),
    createPartial = require('./_createPartial'),
    getData = require('./_getData'),
    mergeData = require('./_mergeData'),
    setData = require('./_setData'),
    setWrapToString = require('./_setWrapToString'),
    toInteger = require('./toInteger');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags.
 *    1 - `_.bind`
 *    2 - `_.bindKey`
 *    4 - `_.curry` or `_.curryRight` of a bound function
 *    8 - `_.curry`
 *   16 - `_.curryRight`
 *   32 - `_.partial`
 *   64 - `_.partialRight`
 *  128 - `_.rearg`
 *  256 - `_.ary`
 *  512 - `_.flip`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }
  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
  arity = arity === undefined ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }
  var data = isBindKey ? undefined : getData(func);

  var newData = [
    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
    argPos, ary, arity
  ];

  if (data) {
    mergeData(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === undefined
    ? (isBindKey ? 0 : func.length)
    : nativeMax(newData[9] - length, 0);

  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
    var result = createBind(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
    result = createCurry(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
    result = createPartial(func, bitmask, thisArg, partials);
  } else {
    result = createHybrid.apply(undefined, newData);
  }
  var setter = data ? baseSetData : setData;
  return setWrapToString(setter(result, newData), func, bitmask);
}

module.exports = createWrap;

},{"./_baseSetData":1465,"./_createBind":1504,"./_createCurry":1506,"./_createHybrid":1509,"./_createPartial":1510,"./_getData":1525,"./_mergeData":1570,"./_setData":1586,"./_setWrapToString":1589,"./toInteger":1705}],1514:[function(require,module,exports){
var eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

module.exports = customDefaultsAssignIn;

},{"./eq":1623}],1515:[function(require,module,exports){
var isPlainObject = require('./isPlainObject');

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

module.exports = customOmitClone;

},{"./isPlainObject":1661}],1516:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":1530}],1517:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":1384,"./_arraySome":1405,"./_cacheHas":1477}],1518:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":1386,"./_Uint8Array":1387,"./_equalArrays":1517,"./_mapToArray":1567,"./_setToArray":1587,"./eq":1623}],1519:[function(require,module,exports){
var getAllKeys = require('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":1523}],1520:[function(require,module,exports){
var basePropertyOf = require('./_basePropertyOf');

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

module.exports = escapeHtmlChar;

},{"./_basePropertyOf":1459}],1521:[function(require,module,exports){
var flatten = require('./flatten'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;

},{"./_overRest":1578,"./_setToString":1588,"./flatten":1630}],1522:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1523:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":1429,"./_getSymbols":1533,"./keys":1667}],1524:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":1429,"./_getSymbolsIn":1534,"./keysIn":1668}],1525:[function(require,module,exports){
var metaMap = require('./_metaMap'),
    noop = require('./noop');

/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !metaMap ? noop : function(func) {
  return metaMap.get(func);
};

module.exports = getData;

},{"./_metaMap":1571,"./noop":1677}],1526:[function(require,module,exports){
var realNames = require('./_realNames');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */
function getFuncName(func) {
  var result = (func.name + ''),
      array = realNames[result],
      length = hasOwnProperty.call(realNames, result) ? array.length : 0;

  while (length--) {
    var data = array[length],
        otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}

module.exports = getFuncName;

},{"./_realNames":1580}],1527:[function(require,module,exports){
/**
 * Gets the argument placeholder value for `func`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */
function getHolder(func) {
  var object = func;
  return object.placeholder;
}

module.exports = getHolder;

},{}],1528:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":1552}],1529:[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":1556,"./keys":1667}],1530:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":1442,"./_getValue":1536}],1531:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":1577}],1532:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":1386}],1533:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":1395,"./stubArray":1699}],1534:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":1400,"./_getPrototype":1531,"./_getSymbols":1533,"./stubArray":1699}],1535:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":1375,"./_Map":1380,"./_Promise":1382,"./_Set":1383,"./_WeakMap":1388,"./_baseGetTag":1430,"./_toSource":1601}],1536:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],1537:[function(require,module,exports){
/** Used to match wrap detail comments. */
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
    reSplitDetails = /,? & /;

/**
 * Extracts wrapper details from the `source` body comment.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {Array} Returns the wrapper details.
 */
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}

module.exports = getWrapDetails;

},{}],1538:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":1479,"./_isIndex":1549,"./_toKey":1600,"./isArguments":1647,"./isArray":1648,"./isLength":1657}],1539:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":1572}],1540:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],1541:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":1572}],1542:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":1572}],1543:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":1572}],1544:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],1545:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneMap = require('./_cloneMap'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSet = require('./_cloneSet'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":1482,"./_cloneDataView":1484,"./_cloneMap":1485,"./_cloneRegExp":1486,"./_cloneSet":1487,"./_cloneSymbol":1488,"./_cloneTypedArray":1489}],1546:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":1414,"./_getPrototype":1531,"./_isPrototype":1555}],1547:[function(require,module,exports){
/** Used to match wrap detail comments. */
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

/**
 * Inserts wrapper `details` in a comment at the top of the `source` body.
 *
 * @private
 * @param {string} source The source to modify.
 * @returns {Array} details The details to insert.
 * @returns {string} Returns the modified source.
 */
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
  details = details.join(length > 2 ? ', ' : ' ');
  return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
}

module.exports = insertWrapDetails;

},{}],1548:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

},{"./_Symbol":1386,"./isArguments":1647,"./isArray":1648}],1549:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],1550:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":1549,"./eq":1623,"./isArrayLike":1649,"./isObject":1659}],1551:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":1648,"./isSymbol":1663}],1552:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],1553:[function(require,module,exports){
var LazyWrapper = require('./_LazyWrapper'),
    getData = require('./_getData'),
    getFuncName = require('./_getFuncName'),
    lodash = require('./wrapperLodash');

/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */
function isLaziable(func) {
  var funcName = getFuncName(func),
      other = lodash[funcName];

  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData(other);
  return !!data && func === data[0];
}

module.exports = isLaziable;

},{"./_LazyWrapper":1377,"./_getData":1525,"./_getFuncName":1526,"./wrapperLodash":1716}],1554:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":1498}],1555:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],1556:[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":1659}],1557:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],1558:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":1408}],1559:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":1408}],1560:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":1408}],1561:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":1408}],1562:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":1376,"./_ListCache":1378,"./_Map":1380}],1563:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":1528}],1564:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":1528}],1565:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":1528}],1566:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":1528}],1567:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],1568:[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],1569:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":1673}],1570:[function(require,module,exports){
var composeArgs = require('./_composeArgs'),
    composeArgsRight = require('./_composeArgsRight'),
    replaceHolders = require('./_replaceHolders');

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_BOUND_FLAG = 4,
    WRAP_CURRY_FLAG = 8,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers used to invoke a function.
 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
 * may be applied regardless of execution order. Methods like `_.ary` and
 * `_.rearg` modify function arguments, making the order in which they are
 * executed important, preventing the merging of metadata. However, we make
 * an exception for a safe combined case where curried functions have `_.ary`
 * and or `_.rearg` applied.
 *
 * @private
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
  var bitmask = data[1],
      srcBitmask = source[1],
      newBitmask = bitmask | srcBitmask,
      isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

  var isCombo =
    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
    ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

  // Exit early if metadata can't be merged.
  if (!(isCommon || isCombo)) {
    return data;
  }
  // Use source `thisArg` if available.
  if (srcBitmask & WRAP_BIND_FLAG) {
    data[2] = source[2];
    // Set when currying a bound function.
    newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
  }
  // Compose partial arguments.
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
  }
  // Compose partial right arguments.
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
  }
  // Use source `argPos` if available.
  value = source[7];
  if (value) {
    data[7] = value;
  }
  // Use source `ary` if it's smaller.
  if (srcBitmask & WRAP_ARY_FLAG) {
    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  }
  // Use source `arity` if one is not provided.
  if (data[9] == null) {
    data[9] = source[9];
  }
  // Use source `func` and merge bitmasks.
  data[0] = source[0];
  data[1] = newBitmask;

  return data;
}

module.exports = mergeData;

},{"./_composeArgs":1492,"./_composeArgsRight":1493,"./_replaceHolders":1582}],1571:[function(require,module,exports){
var WeakMap = require('./_WeakMap');

/** Used to store function metadata. */
var metaMap = WeakMap && new WeakMap;

module.exports = metaMap;

},{"./_WeakMap":1388}],1572:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":1530}],1573:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":1577}],1574:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],1575:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":1522}],1576:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],1577:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],1578:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":1391}],1579:[function(require,module,exports){
var baseGet = require('./_baseGet'),
    baseSlice = require('./_baseSlice');

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;

},{"./_baseGet":1428,"./_baseSlice":1468}],1580:[function(require,module,exports){
/** Used to lookup unminified function names. */
var realNames = {};

module.exports = realNames;

},{}],1581:[function(require,module,exports){
var copyArray = require('./_copyArray'),
    isIndex = require('./_isIndex');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin(indexes.length, arrLength),
      oldArray = copyArray(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

module.exports = reorder;

},{"./_copyArray":1494,"./_isIndex":1549}],1582:[function(require,module,exports){
/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index] = PLACEHOLDER;
      result[resIndex++] = index;
    }
  }
  return result;
}

module.exports = replaceHolders;

},{}],1583:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":1522}],1584:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],1585:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],1586:[function(require,module,exports){
var baseSetData = require('./_baseSetData'),
    shortOut = require('./_shortOut');

/**
 * Sets metadata for `func`.
 *
 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
 * period of time, it will trip its breaker and transition to an identity
 * function to avoid garbage collection pauses in V8. See
 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
 * for more details.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var setData = shortOut(baseSetData);

module.exports = setData;

},{"./_baseSetData":1465,"./_shortOut":1590}],1587:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],1588:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":1466,"./_shortOut":1590}],1589:[function(require,module,exports){
var getWrapDetails = require('./_getWrapDetails'),
    insertWrapDetails = require('./_insertWrapDetails'),
    setToString = require('./_setToString'),
    updateWrapDetails = require('./_updateWrapDetails');

/**
 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
 * with wrapper details in a comment at the top of the source body.
 *
 * @private
 * @param {Function} wrapper The function to modify.
 * @param {Function} reference The reference function.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Function} Returns `wrapper`.
 */
function setWrapToString(wrapper, reference, bitmask) {
  var source = (reference + '');
  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
}

module.exports = setWrapToString;

},{"./_getWrapDetails":1537,"./_insertWrapDetails":1547,"./_setToString":1588,"./_updateWrapDetails":1602}],1590:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],1591:[function(require,module,exports){
var baseRandom = require('./_baseRandom');

/**
 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @param {number} [size=array.length] The size of `array`.
 * @returns {Array} Returns `array`.
 */
function shuffleSelf(array, size) {
  var index = -1,
      length = array.length,
      lastIndex = length - 1;

  size = size === undefined ? length : size;
  while (++index < size) {
    var rand = baseRandom(index, lastIndex),
        value = array[rand];

    array[rand] = array[index];
    array[index] = value;
  }
  array.length = size;
  return array;
}

module.exports = shuffleSelf;

},{"./_baseRandom":1460}],1592:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":1378}],1593:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],1594:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],1595:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],1596:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":1378,"./_Map":1380,"./_MapCache":1381}],1597:[function(require,module,exports){
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

},{}],1598:[function(require,module,exports){
/**
 * A specialized version of `_.lastIndexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictLastIndexOf(array, value, fromIndex) {
  var index = fromIndex + 1;
  while (index--) {
    if (array[index] === value) {
      return index;
    }
  }
  return index;
}

module.exports = strictLastIndexOf;

},{}],1599:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":1569}],1600:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":1663}],1601:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],1602:[function(require,module,exports){
var arrayEach = require('./_arrayEach'),
    arrayIncludes = require('./_arrayIncludes');

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256,
    WRAP_FLIP_FLAG = 512;

/** Used to associate wrap methods with their bit flags. */
var wrapFlags = [
  ['ary', WRAP_ARY_FLAG],
  ['bind', WRAP_BIND_FLAG],
  ['bindKey', WRAP_BIND_KEY_FLAG],
  ['curry', WRAP_CURRY_FLAG],
  ['curryRight', WRAP_CURRY_RIGHT_FLAG],
  ['flip', WRAP_FLIP_FLAG],
  ['partial', WRAP_PARTIAL_FLAG],
  ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
  ['rearg', WRAP_REARG_FLAG]
];

/**
 * Updates wrapper `details` based on `bitmask` flags.
 *
 * @private
 * @returns {Array} details The details to modify.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Array} Returns `details`.
 */
function updateWrapDetails(details, bitmask) {
  arrayEach(wrapFlags, function(pair) {
    var value = '_.' + pair[0];
    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}

module.exports = updateWrapDetails;

},{"./_arrayEach":1393,"./_arrayIncludes":1396}],1603:[function(require,module,exports){
var LazyWrapper = require('./_LazyWrapper'),
    LodashWrapper = require('./_LodashWrapper'),
    copyArray = require('./_copyArray');

/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper) {
    return wrapper.clone();
  }
  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray(wrapper.__actions__);
  result.__index__  = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}

module.exports = wrapperClone;

},{"./_LazyWrapper":1377,"./_LodashWrapper":1379,"./_copyArray":1494}],1604:[function(require,module,exports){
var toInteger = require('./toInteger');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * The opposite of `_.before`; this method creates a function that invokes
 * `func` once it's called `n` or more times.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {number} n The number of calls before `func` is invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var saves = ['profile', 'settings'];
 *
 * var done = _.after(saves.length, function() {
 *   console.log('done saving!');
 * });
 *
 * _.forEach(saves, function(type) {
 *   asyncSave({ 'type': type, 'complete': done });
 * });
 * // => Logs 'done saving!' after the two async saves have completed.
 */
function after(n, func) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n < 1) {
      return func.apply(this, arguments);
    }
  };
}

module.exports = after;

},{"./toInteger":1705}],1605:[function(require,module,exports){
var createWrap = require('./_createWrap');

/** Used to compose bitmasks for function metadata. */
var WRAP_ARY_FLAG = 128;

/**
 * Creates a function that invokes `func`, with up to `n` arguments,
 * ignoring any additional arguments.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} func The function to cap arguments for.
 * @param {number} [n=func.length] The arity cap.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new capped function.
 * @example
 *
 * _.map(['6', '8', '10'], _.ary(parseInt, 1));
 * // => [6, 8, 10]
 */
function ary(func, n, guard) {
  n = guard ? undefined : n;
  n = (func && n == null) ? func.length : n;
  return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
}

module.exports = ary;

},{"./_createWrap":1513}],1606:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    isArrayLike = require('./isArrayLike'),
    isPrototype = require('./_isPrototype'),
    keys = require('./keys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;

},{"./_assignValue":1407,"./_copyObject":1495,"./_createAssigner":1501,"./_isPrototype":1555,"./isArrayLike":1649,"./keys":1667}],1607:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    keysIn = require('./keysIn');

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

module.exports = assignInWith;

},{"./_copyObject":1495,"./_createAssigner":1501,"./keysIn":1668}],1608:[function(require,module,exports){
var apply = require('./_apply'),
    baseRest = require('./_baseRest'),
    isError = require('./isError');

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

module.exports = attempt;

},{"./_apply":1391,"./_baseRest":1462,"./isError":1655}],1609:[function(require,module,exports){
var toInteger = require('./toInteger');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

module.exports = before;

},{"./toInteger":1705}],1610:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    createWrap = require('./_createWrap'),
    getHolder = require('./_getHolder'),
    replaceHolders = require('./_replaceHolders');

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_PARTIAL_FLAG = 32;

/**
 * Creates a function that invokes `func` with the `this` binding of `thisArg`
 * and `partials` prepended to the arguments it receives.
 *
 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for partially applied arguments.
 *
 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
 * property of bound functions.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new bound function.
 * @example
 *
 * function greet(greeting, punctuation) {
 *   return greeting + ' ' + this.user + punctuation;
 * }
 *
 * var object = { 'user': 'fred' };
 *
 * var bound = _.bind(greet, object, 'hi');
 * bound('!');
 * // => 'hi fred!'
 *
 * // Bound with placeholders.
 * var bound = _.bind(greet, object, _, '!');
 * bound('hi');
 * // => 'hi fred!'
 */
var bind = baseRest(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bind));
    bitmask |= WRAP_PARTIAL_FLAG;
  }
  return createWrap(func, bitmask, thisArg, partials, holders);
});

// Assign default placeholders.
bind.placeholder = {};

module.exports = bind;

},{"./_baseRest":1462,"./_createWrap":1513,"./_getHolder":1527,"./_replaceHolders":1582}],1611:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":1413}],1612:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":1413}],1613:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],1614:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    createAggregator = require('./_createAggregator');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The corresponding value of
 * each key is the number of times the key was returned by `iteratee`. The
 * iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.countBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': 1, '6': 2 }
 *
 * // The `_.property` iteratee shorthand.
 * _.countBy(['one', 'two', 'three'], 'length');
 * // => { '3': 2, '5': 1 }
 */
var countBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    ++result[key];
  } else {
    baseAssignValue(result, key, 1);
  }
});

module.exports = countBy;

},{"./_baseAssignValue":1412,"./_createAggregator":1500}],1615:[function(require,module,exports){
var createWrap = require('./_createWrap');

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_FLAG = 8;

/**
 * Creates a function that accepts arguments of `func` and either invokes
 * `func` returning its result, if at least `arity` number of arguments have
 * been provided, or returns a function that accepts the remaining `func`
 * arguments, and so on. The arity of `func` may be specified if `func.length`
 * is not sufficient.
 *
 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for provided arguments.
 *
 * **Note:** This method doesn't set the "length" property of curried functions.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Function
 * @param {Function} func The function to curry.
 * @param {number} [arity=func.length] The arity of `func`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new curried function.
 * @example
 *
 * var abc = function(a, b, c) {
 *   return [a, b, c];
 * };
 *
 * var curried = _.curry(abc);
 *
 * curried(1)(2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2, 3);
 * // => [1, 2, 3]
 *
 * // Curried with placeholders.
 * curried(1)(_, 3)(2);
 * // => [1, 2, 3]
 */
function curry(func, arity, guard) {
  arity = guard ? undefined : arity;
  var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
  result.placeholder = curry.placeholder;
  return result;
}

// Assign default placeholders.
curry.placeholder = {};

module.exports = curry;

},{"./_createWrap":1513}],1616:[function(require,module,exports){
var createWrap = require('./_createWrap');

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_RIGHT_FLAG = 16;

/**
 * This method is like `_.curry` except that arguments are applied to `func`
 * in the manner of `_.partialRight` instead of `_.partial`.
 *
 * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for provided arguments.
 *
 * **Note:** This method doesn't set the "length" property of curried functions.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} func The function to curry.
 * @param {number} [arity=func.length] The arity of `func`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new curried function.
 * @example
 *
 * var abc = function(a, b, c) {
 *   return [a, b, c];
 * };
 *
 * var curried = _.curryRight(abc);
 *
 * curried(3)(2)(1);
 * // => [1, 2, 3]
 *
 * curried(2, 3)(1);
 * // => [1, 2, 3]
 *
 * curried(1, 2, 3);
 * // => [1, 2, 3]
 *
 * // Curried with placeholders.
 * curried(3)(1, _)(2);
 * // => [1, 2, 3]
 */
function curryRight(func, arity, guard) {
  arity = guard ? undefined : arity;
  var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
  result.placeholder = curryRight.placeholder;
  return result;
}

// Assign default placeholders.
curryRight.placeholder = {};

module.exports = curryRight;

},{"./_createWrap":1513}],1617:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":1659,"./now":1678,"./toNumber":1706}],1618:[function(require,module,exports){
var apply = require('./_apply'),
    assignInWith = require('./assignInWith'),
    baseRest = require('./_baseRest'),
    customDefaultsAssignIn = require('./_customDefaultsAssignIn');

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(args) {
  args.push(undefined, customDefaultsAssignIn);
  return apply(assignInWith, undefined, args);
});

module.exports = defaults;

},{"./_apply":1391,"./_baseRest":1462,"./_customDefaultsAssignIn":1514,"./assignInWith":1607}],1619:[function(require,module,exports){
var baseDelay = require('./_baseDelay'),
    baseRest = require('./_baseRest');

/**
 * Defers invoking the `func` until the current call stack has cleared. Any
 * additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to defer.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * _.defer(function(text) {
 *   console.log(text);
 * }, 'deferred');
 * // => Logs 'deferred' after one millisecond.
 */
var defer = baseRest(function(func, args) {
  return baseDelay(func, 1, args);
});

module.exports = defer;

},{"./_baseDelay":1415,"./_baseRest":1462}],1620:[function(require,module,exports){
var baseDelay = require('./_baseDelay'),
    baseRest = require('./_baseRest'),
    toNumber = require('./toNumber');

/**
 * Invokes `func` after `wait` milliseconds. Any additional arguments are
 * provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * _.delay(function(text) {
 *   console.log(text);
 * }, 1000, 'later');
 * // => Logs 'later' after one second.
 */
var delay = baseRest(function(func, wait, args) {
  return baseDelay(func, toNumber(wait) || 0, args);
});

module.exports = delay;

},{"./_baseDelay":1415,"./_baseRest":1462,"./toNumber":1706}],1621:[function(require,module,exports){
var baseDifference = require('./_baseDifference'),
    baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

module.exports = difference;

},{"./_baseDifference":1416,"./_baseFlatten":1423,"./_baseRest":1462,"./isArrayLikeObject":1650}],1622:[function(require,module,exports){
var baseSlice = require('./_baseSlice'),
    toInteger = require('./toInteger');

/**
 * Creates a slice of `array` with `n` elements dropped from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.drop([1, 2, 3]);
 * // => [2, 3]
 *
 * _.drop([1, 2, 3], 2);
 * // => [3]
 *
 * _.drop([1, 2, 3], 5);
 * // => []
 *
 * _.drop([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function drop(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : toInteger(n);
  return baseSlice(array, n < 0 ? 0 : n, length);
}

module.exports = drop;

},{"./_baseSlice":1468,"./toInteger":1705}],1623:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],1624:[function(require,module,exports){
var escapeHtmlChar = require('./_escapeHtmlChar'),
    toString = require('./toString');

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = escape;

},{"./_escapeHtmlChar":1520,"./toString":1708}],1625:[function(require,module,exports){
var arrayEvery = require('./_arrayEvery'),
    baseEvery = require('./_baseEvery'),
    baseIteratee = require('./_baseIteratee'),
    isArray = require('./isArray'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Checks if `predicate` returns truthy for **all** elements of `collection`.
 * Iteration is stopped once `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * **Note:** This method returns `true` for
 * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
 * elements of empty collections.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 * @example
 *
 * _.every([true, 1, null, 'yes'], Boolean);
 * // => false
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.every(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.every(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.every(users, 'active');
 * // => false
 */
function every(collection, predicate, guard) {
  var func = isArray(collection) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = every;

},{"./_arrayEvery":1394,"./_baseEvery":1419,"./_baseIteratee":1444,"./_isIterateeCall":1550,"./isArray":1648}],1626:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    baseFilter = require('./_baseFilter'),
    baseIteratee = require('./_baseIteratee'),
    isArray = require('./isArray');

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;

},{"./_arrayFilter":1395,"./_baseFilter":1421,"./_baseIteratee":1444,"./isArray":1648}],1627:[function(require,module,exports){
var createFind = require('./_createFind'),
    findIndex = require('./findIndex');

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;

},{"./_createFind":1507,"./findIndex":1628}],1628:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIteratee = require('./_baseIteratee'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;

},{"./_baseFindIndex":1422,"./_baseIteratee":1444,"./toInteger":1705}],1629:[function(require,module,exports){
module.exports = require('./head');

},{"./head":1640}],1630:[function(require,module,exports){
var baseFlatten = require('./_baseFlatten');

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

},{"./_baseFlatten":1423}],1631:[function(require,module,exports){
var createWrap = require('./_createWrap');

/** Used to compose bitmasks for function metadata. */
var WRAP_FLIP_FLAG = 512;

/**
 * Creates a function that invokes `func` with arguments reversed.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to flip arguments for.
 * @returns {Function} Returns the new flipped function.
 * @example
 *
 * var flipped = _.flip(function() {
 *   return _.toArray(arguments);
 * });
 *
 * flipped('a', 'b', 'c', 'd');
 * // => ['d', 'c', 'b', 'a']
 */
function flip(func) {
  return createWrap(func, WRAP_FLIP_FLAG);
}

module.exports = flip;

},{"./_createWrap":1513}],1632:[function(require,module,exports){
var createFlow = require('./_createFlow');

/**
 * Creates a function that returns the result of invoking the given functions
 * with the `this` binding of the created function, where each successive
 * invocation is supplied the return value of the previous.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {...(Function|Function[])} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flowRight
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flow([_.add, square]);
 * addSquare(1, 2);
 * // => 9
 */
var flow = createFlow();

module.exports = flow;

},{"./_createFlow":1508}],1633:[function(require,module,exports){
var createFlow = require('./_createFlow');

/**
 * This method is like `_.flow` except that it creates a function that
 * invokes the given functions from right to left.
 *
 * @static
 * @since 3.0.0
 * @memberOf _
 * @category Util
 * @param {...(Function|Function[])} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flow
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flowRight([square, _.add]);
 * addSquare(1, 2);
 * // => 9
 */
var flowRight = createFlow(true);

module.exports = flowRight;

},{"./_createFlow":1508}],1634:[function(require,module,exports){
var arrayEach = require('./_arrayEach'),
    baseEach = require('./_baseEach'),
    castFunction = require('./_castFunction'),
    isArray = require('./isArray');

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

},{"./_arrayEach":1393,"./_baseEach":1417,"./_castFunction":1478,"./isArray":1648}],1635:[function(require,module,exports){
var baseForOwn = require('./_baseForOwn'),
    castFunction = require('./_castFunction');

/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes `iteratee` for each property. The iteratee is invoked with three
 * arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forOwnRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forOwn(object, iteratee) {
  return object && baseForOwn(object, castFunction(iteratee));
}

module.exports = forOwn;

},{"./_baseForOwn":1425,"./_castFunction":1478}],1636:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":1428}],1637:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    createAggregator = require('./_createAggregator');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue(result, key, [value]);
  }
});

module.exports = groupBy;

},{"./_baseAssignValue":1412,"./_createAggregator":1500}],1638:[function(require,module,exports){
var baseHas = require('./_baseHas'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;

},{"./_baseHas":1432,"./_hasPath":1538}],1639:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":1433,"./_hasPath":1538}],1640:[function(require,module,exports){
/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

module.exports = head;

},{}],1641:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],1642:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf'),
    isArrayLike = require('./isArrayLike'),
    isString = require('./isString'),
    toInteger = require('./toInteger'),
    values = require('./values');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

module.exports = includes;

},{"./_baseIndexOf":1434,"./isArrayLike":1649,"./isString":1662,"./toInteger":1705,"./values":1713}],1643:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseIndexOf(array, value, index);
}

module.exports = indexOf;

},{"./_baseIndexOf":1434,"./toInteger":1705}],1644:[function(require,module,exports){
var baseSlice = require('./_baseSlice');

/**
 * Gets all but the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.initial([1, 2, 3]);
 * // => [1, 2]
 */
function initial(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice(array, 0, -1) : [];
}

module.exports = initial;

},{"./_baseSlice":1468}],1645:[function(require,module,exports){
var baseInvoke = require('./_baseInvoke'),
    baseRest = require('./_baseRest');

/**
 * Invokes the method at `path` of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
 *
 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
 * // => [2, 3]
 */
var invoke = baseRest(baseInvoke);

module.exports = invoke;

},{"./_baseInvoke":1435,"./_baseRest":1462}],1646:[function(require,module,exports){
var apply = require('./_apply'),
    baseEach = require('./_baseEach'),
    baseInvoke = require('./_baseInvoke'),
    baseRest = require('./_baseRest'),
    isArrayLike = require('./isArrayLike');

/**
 * Invokes the method at `path` of each element in `collection`, returning
 * an array of the results of each invoked method. Any additional arguments
 * are provided to each invoked method. If `path` is a function, it's invoked
 * for, and `this` bound to, each element in `collection`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|string} path The path of the method to invoke or
 *  the function invoked per iteration.
 * @param {...*} [args] The arguments to invoke each method with.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
 * // => [[1, 5, 7], [1, 2, 3]]
 *
 * _.invokeMap([123, 456], String.prototype.split, '');
 * // => [['1', '2', '3'], ['4', '5', '6']]
 */
var invokeMap = baseRest(function(collection, path, args) {
  var index = -1,
      isFunc = typeof path == 'function',
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value) {
    result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
  });
  return result;
});

module.exports = invokeMap;

},{"./_apply":1391,"./_baseEach":1417,"./_baseInvoke":1435,"./_baseRest":1462,"./isArrayLike":1649}],1647:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":1436,"./isObjectLike":1660}],1648:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],1649:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":1656,"./isLength":1657}],1650:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":1649,"./isObjectLike":1660}],1651:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":1583,"./stubFalse":1700}],1652:[function(require,module,exports){
var baseIsDate = require('./_baseIsDate'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsDate = nodeUtil && nodeUtil.isDate;

/**
 * Checks if `value` is classified as a `Date` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
 * @example
 *
 * _.isDate(new Date);
 * // => true
 *
 * _.isDate('Mon April 23 2012');
 * // => false
 */
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

module.exports = isDate;

},{"./_baseIsDate":1437,"./_baseUnary":1473,"./_nodeUtil":1575}],1653:[function(require,module,exports){
var baseKeys = require('./_baseKeys'),
    getTag = require('./_getTag'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLike = require('./isArrayLike'),
    isBuffer = require('./isBuffer'),
    isPrototype = require('./_isPrototype'),
    isTypedArray = require('./isTypedArray');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;

},{"./_baseKeys":1445,"./_getTag":1535,"./_isPrototype":1555,"./isArguments":1647,"./isArray":1648,"./isArrayLike":1649,"./isBuffer":1651,"./isTypedArray":1664}],1654:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

},{"./_baseIsEqual":1438}],1655:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike'),
    isPlainObject = require('./isPlainObject');

/** `Object#toString` result references. */
var domExcTag = '[object DOMException]',
    errorTag = '[object Error]';

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag || tag == domExcTag ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
}

module.exports = isError;

},{"./_baseGetTag":1430,"./isObjectLike":1660,"./isPlainObject":1661}],1656:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":1430,"./isObject":1659}],1657:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],1658:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;

},{"./_baseGetTag":1430,"./isObjectLike":1660}],1659:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],1660:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],1661:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":1430,"./_getPrototype":1531,"./isObjectLike":1660}],1662:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

},{"./_baseGetTag":1430,"./isArray":1648,"./isObjectLike":1660}],1663:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":1430,"./isObjectLike":1660}],1664:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":1443,"./_baseUnary":1473,"./_nodeUtil":1575}],1665:[function(require,module,exports){
/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

},{}],1666:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    createAggregator = require('./_createAggregator');

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The corresponding value of
 * each key is the last element responsible for generating the key. The
 * iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * var array = [
 *   { 'dir': 'left', 'code': 97 },
 *   { 'dir': 'right', 'code': 100 }
 * ];
 *
 * _.keyBy(array, function(o) {
 *   return String.fromCharCode(o.code);
 * });
 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
 *
 * _.keyBy(array, 'dir');
 * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
 */
var keyBy = createAggregator(function(result, value, key) {
  baseAssignValue(result, key, value);
});

module.exports = keyBy;

},{"./_baseAssignValue":1412,"./_createAggregator":1500}],1667:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":1398,"./_baseKeys":1445,"./isArrayLike":1649}],1668:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":1398,"./_baseKeysIn":1446,"./isArrayLike":1649}],1669:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],1670:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictLastIndexOf = require('./_strictLastIndexOf'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * This method is like `_.indexOf` except that it iterates over elements of
 * `array` from right to left.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.lastIndexOf([1, 2, 1, 2], 2);
 * // => 3
 *
 * // Search from the `fromIndex`.
 * _.lastIndexOf([1, 2, 1, 2], 2, 2);
 * // => 1
 */
function lastIndexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length;
  if (fromIndex !== undefined) {
    index = toInteger(fromIndex);
    index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
  }
  return value === value
    ? strictLastIndexOf(array, value, index)
    : baseFindIndex(array, baseIsNaN, index, true);
}

module.exports = lastIndexOf;

},{"./_baseFindIndex":1422,"./_baseIsNaN":1441,"./_strictLastIndexOf":1598,"./toInteger":1705}],1671:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseIteratee = require('./_baseIteratee'),
    baseMap = require('./_baseMap'),
    isArray = require('./isArray');

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;

},{"./_arrayMap":1399,"./_baseIteratee":1444,"./_baseMap":1449,"./isArray":1648}],1672:[function(require,module,exports){
var baseExtremum = require('./_baseExtremum'),
    baseGt = require('./_baseGt'),
    identity = require('./identity');

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

module.exports = max;

},{"./_baseExtremum":1420,"./_baseGt":1431,"./identity":1641}],1673:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":1381}],1674:[function(require,module,exports){
var baseMerge = require('./_baseMerge'),
    createAssigner = require('./_createAssigner');

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;

},{"./_baseMerge":1452,"./_createAssigner":1501}],1675:[function(require,module,exports){
var baseExtremum = require('./_baseExtremum'),
    baseLt = require('./_baseLt'),
    identity = require('./identity');

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * _.min([4, 2, 8, 6]);
 * // => 2
 *
 * _.min([]);
 * // => undefined
 */
function min(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseLt)
    : undefined;
}

module.exports = min;

},{"./_baseExtremum":1420,"./_baseLt":1448,"./identity":1641}],1676:[function(require,module,exports){
/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */
function negate(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0: return !predicate.call(this);
      case 1: return !predicate.call(this, args[0]);
      case 2: return !predicate.call(this, args[0], args[1]);
      case 3: return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}

module.exports = negate;

},{}],1677:[function(require,module,exports){
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],1678:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":1583}],1679:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseClone = require('./_baseClone'),
    baseUnset = require('./_baseUnset'),
    castPath = require('./_castPath'),
    copyObject = require('./_copyObject'),
    customOmitClone = require('./_customOmitClone'),
    flatRest = require('./_flatRest'),
    getAllKeysIn = require('./_getAllKeysIn');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

module.exports = omit;

},{"./_arrayMap":1399,"./_baseClone":1413,"./_baseUnset":1475,"./_castPath":1479,"./_copyObject":1495,"./_customOmitClone":1515,"./_flatRest":1521,"./_getAllKeysIn":1524}],1680:[function(require,module,exports){
var before = require('./before');

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

module.exports = once;

},{"./before":1609}],1681:[function(require,module,exports){
var apply = require('./_apply'),
    arrayMap = require('./_arrayMap'),
    baseFlatten = require('./_baseFlatten'),
    baseIteratee = require('./_baseIteratee'),
    baseRest = require('./_baseRest'),
    baseUnary = require('./_baseUnary'),
    castRest = require('./_castRest'),
    isArray = require('./isArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Creates a function that invokes `func` with its arguments transformed.
 *
 * @static
 * @since 4.0.0
 * @memberOf _
 * @category Function
 * @param {Function} func The function to wrap.
 * @param {...(Function|Function[])} [transforms=[_.identity]]
 *  The argument transforms.
 * @returns {Function} Returns the new function.
 * @example
 *
 * function doubled(n) {
 *   return n * 2;
 * }
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var func = _.overArgs(function(x, y) {
 *   return [x, y];
 * }, [square, doubled]);
 *
 * func(9, 3);
 * // => [81, 6]
 *
 * func(10, 5);
 * // => [100, 10]
 */
var overArgs = castRest(function(func, transforms) {
  transforms = (transforms.length == 1 && isArray(transforms[0]))
    ? arrayMap(transforms[0], baseUnary(baseIteratee))
    : arrayMap(baseFlatten(transforms, 1), baseUnary(baseIteratee));

  var funcsLength = transforms.length;
  return baseRest(function(args) {
    var index = -1,
        length = nativeMin(args.length, funcsLength);

    while (++index < length) {
      args[index] = transforms[index].call(this, args[index]);
    }
    return apply(func, this, args);
  });
});

module.exports = overArgs;

},{"./_apply":1391,"./_arrayMap":1399,"./_baseFlatten":1423,"./_baseIteratee":1444,"./_baseRest":1462,"./_baseUnary":1473,"./_castRest":1480,"./isArray":1648}],1682:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    createWrap = require('./_createWrap'),
    getHolder = require('./_getHolder'),
    replaceHolders = require('./_replaceHolders');

/** Used to compose bitmasks for function metadata. */
var WRAP_PARTIAL_FLAG = 32;

/**
 * Creates a function that invokes `func` with `partials` prepended to the
 * arguments it receives. This method is like `_.bind` except it does **not**
 * alter the `this` binding.
 *
 * The `_.partial.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for partially applied arguments.
 *
 * **Note:** This method doesn't set the "length" property of partially
 * applied functions.
 *
 * @static
 * @memberOf _
 * @since 0.2.0
 * @category Function
 * @param {Function} func The function to partially apply arguments to.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new partially applied function.
 * @example
 *
 * function greet(greeting, name) {
 *   return greeting + ' ' + name;
 * }
 *
 * var sayHelloTo = _.partial(greet, 'hello');
 * sayHelloTo('fred');
 * // => 'hello fred'
 *
 * // Partially applied with placeholders.
 * var greetFred = _.partial(greet, _, 'fred');
 * greetFred('hi');
 * // => 'hi fred'
 */
var partial = baseRest(function(func, partials) {
  var holders = replaceHolders(partials, getHolder(partial));
  return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
});

// Assign default placeholders.
partial.placeholder = {};

module.exports = partial;

},{"./_baseRest":1462,"./_createWrap":1513,"./_getHolder":1527,"./_replaceHolders":1582}],1683:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    createWrap = require('./_createWrap'),
    getHolder = require('./_getHolder'),
    replaceHolders = require('./_replaceHolders');

/** Used to compose bitmasks for function metadata. */
var WRAP_PARTIAL_RIGHT_FLAG = 64;

/**
 * This method is like `_.partial` except that partially applied arguments
 * are appended to the arguments it receives.
 *
 * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for partially applied arguments.
 *
 * **Note:** This method doesn't set the "length" property of partially
 * applied functions.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Function
 * @param {Function} func The function to partially apply arguments to.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new partially applied function.
 * @example
 *
 * function greet(greeting, name) {
 *   return greeting + ' ' + name;
 * }
 *
 * var greetFred = _.partialRight(greet, 'fred');
 * greetFred('hi');
 * // => 'hi fred'
 *
 * // Partially applied with placeholders.
 * var sayHelloTo = _.partialRight(greet, 'hello', _);
 * sayHelloTo('fred');
 * // => 'hello fred'
 */
var partialRight = baseRest(function(func, partials) {
  var holders = replaceHolders(partials, getHolder(partialRight));
  return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
});

// Assign default placeholders.
partialRight.placeholder = {};

module.exports = partialRight;

},{"./_baseRest":1462,"./_createWrap":1513,"./_getHolder":1527,"./_replaceHolders":1582}],1684:[function(require,module,exports){
var createAggregator = require('./_createAggregator');

/**
 * Creates an array of elements split into two groups, the first of which
 * contains elements `predicate` returns truthy for, the second of which
 * contains elements `predicate` returns falsey for. The predicate is
 * invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of grouped elements.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': false },
 *   { 'user': 'fred',    'age': 40, 'active': true },
 *   { 'user': 'pebbles', 'age': 1,  'active': false }
 * ];
 *
 * _.partition(users, function(o) { return o.active; });
 * // => objects for [['fred'], ['barney', 'pebbles']]
 *
 * // The `_.matches` iteratee shorthand.
 * _.partition(users, { 'age': 1, 'active': false });
 * // => objects for [['pebbles'], ['barney', 'fred']]
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.partition(users, ['active', false]);
 * // => objects for [['barney', 'pebbles'], ['fred']]
 *
 * // The `_.property` iteratee shorthand.
 * _.partition(users, 'active');
 * // => objects for [['fred'], ['barney', 'pebbles']]
 */
var partition = createAggregator(function(result, value, key) {
  result[key ? 0 : 1].push(value);
}, function() { return [[], []]; });

module.exports = partition;

},{"./_createAggregator":1500}],1685:[function(require,module,exports){
var basePick = require('./_basePick'),
    flatRest = require('./_flatRest');

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;

},{"./_basePick":1455,"./_flatRest":1521}],1686:[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":1457,"./_basePropertyDeep":1458,"./_isKey":1551,"./_toKey":1600}],1687:[function(require,module,exports){
var createWrap = require('./_createWrap'),
    flatRest = require('./_flatRest');

/** Used to compose bitmasks for function metadata. */
var WRAP_REARG_FLAG = 256;

/**
 * Creates a function that invokes `func` with arguments arranged according
 * to the specified `indexes` where the argument value at the first index is
 * provided as the first argument, the argument value at the second index is
 * provided as the second argument, and so on.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} func The function to rearrange arguments for.
 * @param {...(number|number[])} indexes The arranged argument indexes.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var rearged = _.rearg(function(a, b, c) {
 *   return [a, b, c];
 * }, [2, 0, 1]);
 *
 * rearged('b', 'c', 'a')
 * // => ['a', 'b', 'c']
 */
var rearg = flatRest(function(func, indexes) {
  return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
});

module.exports = rearg;

},{"./_createWrap":1513,"./_flatRest":1521}],1688:[function(require,module,exports){
var arrayReduce = require('./_arrayReduce'),
    baseEach = require('./_baseEach'),
    baseIteratee = require('./_baseIteratee'),
    baseReduce = require('./_baseReduce'),
    isArray = require('./isArray');

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;

},{"./_arrayReduce":1401,"./_baseEach":1417,"./_baseIteratee":1444,"./_baseReduce":1461,"./isArray":1648}],1689:[function(require,module,exports){
var arrayReduceRight = require('./_arrayReduceRight'),
    baseEachRight = require('./_baseEachRight'),
    baseIteratee = require('./_baseIteratee'),
    baseReduce = require('./_baseReduce'),
    isArray = require('./isArray');

/**
 * This method is like `_.reduce` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduce
 * @example
 *
 * var array = [[0, 1], [2, 3], [4, 5]];
 *
 * _.reduceRight(array, function(flattened, other) {
 *   return flattened.concat(other);
 * }, []);
 * // => [4, 5, 2, 3, 0, 1]
 */
function reduceRight(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduceRight : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
}

module.exports = reduceRight;

},{"./_arrayReduceRight":1402,"./_baseEachRight":1418,"./_baseIteratee":1444,"./_baseReduce":1461,"./isArray":1648}],1690:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    baseFilter = require('./_baseFilter'),
    baseIteratee = require('./_baseIteratee'),
    isArray = require('./isArray'),
    negate = require('./negate');

/**
 * The opposite of `_.filter`; this method returns the elements of `collection`
 * that `predicate` does **not** return truthy for.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.filter
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': true }
 * ];
 *
 * _.reject(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.reject(users, { 'age': 40, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.reject(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.reject(users, 'active');
 * // => objects for ['barney']
 */
function reject(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, negate(baseIteratee(predicate, 3)));
}

module.exports = reject;

},{"./_arrayFilter":1395,"./_baseFilter":1421,"./_baseIteratee":1444,"./isArray":1648,"./negate":1676}],1691:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    toInteger = require('./toInteger');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = start === undefined ? start : toInteger(start);
  return baseRest(func, start);
}

module.exports = rest;

},{"./_baseRest":1462,"./toInteger":1705}],1692:[function(require,module,exports){
var castPath = require('./_castPath'),
    isFunction = require('./isFunction'),
    toKey = require('./_toKey');

/**
 * This method is like `_.get` except that if the resolved value is a
 * function it's invoked with the `this` binding of its parent object and
 * its result is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to resolve.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
 *
 * _.result(object, 'a[0].b.c1');
 * // => 3
 *
 * _.result(object, 'a[0].b.c2');
 * // => 4
 *
 * _.result(object, 'a[0].b.c3', 'default');
 * // => 'default'
 *
 * _.result(object, 'a[0].b.c3', _.constant('default'));
 * // => 'default'
 */
function result(object, path, defaultValue) {
  path = castPath(path, object);

  var index = -1,
      length = path.length;

  // Ensure the loop is entered when path is empty.
  if (!length) {
    length = 1;
    object = undefined;
  }
  while (++index < length) {
    var value = object == null ? undefined : object[toKey(path[index])];
    if (value === undefined) {
      index = length;
      value = defaultValue;
    }
    object = isFunction(value) ? value.call(object) : value;
  }
  return object;
}

module.exports = result;

},{"./_castPath":1479,"./_toKey":1600,"./isFunction":1656}],1693:[function(require,module,exports){
var arraySample = require('./_arraySample'),
    baseSample = require('./_baseSample'),
    isArray = require('./isArray');

/**
 * Gets a random element from `collection`.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 * @example
 *
 * _.sample([1, 2, 3, 4]);
 * // => 2
 */
function sample(collection) {
  var func = isArray(collection) ? arraySample : baseSample;
  return func(collection);
}

module.exports = sample;

},{"./_arraySample":1403,"./_baseSample":1463,"./isArray":1648}],1694:[function(require,module,exports){
var baseSet = require('./_baseSet');

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;

},{"./_baseSet":1464}],1695:[function(require,module,exports){
var arrayShuffle = require('./_arrayShuffle'),
    baseShuffle = require('./_baseShuffle'),
    isArray = require('./isArray');

/**
 * Creates an array of shuffled values, using a version of the
 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 * @example
 *
 * _.shuffle([1, 2, 3, 4]);
 * // => [4, 1, 3, 2]
 */
function shuffle(collection) {
  var func = isArray(collection) ? arrayShuffle : baseShuffle;
  return func(collection);
}

module.exports = shuffle;

},{"./_arrayShuffle":1404,"./_baseShuffle":1467,"./isArray":1648}],1696:[function(require,module,exports){
var arraySome = require('./_arraySome'),
    baseIteratee = require('./_baseIteratee'),
    baseSome = require('./_baseSome'),
    isArray = require('./isArray'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Checks if `predicate` returns truthy for **any** element of `collection`.
 * Iteration is stopped once `predicate` returns truthy. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 * @example
 *
 * _.some([null, 0, 'yes', false], Boolean);
 * // => true
 *
 * var users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'fred',   'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.some(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.some(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.some(users, 'active');
 * // => true
 */
function some(collection, predicate, guard) {
  var func = isArray(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = some;

},{"./_arraySome":1405,"./_baseIteratee":1444,"./_baseSome":1469,"./_isIterateeCall":1550,"./isArray":1648}],1697:[function(require,module,exports){
var baseFlatten = require('./_baseFlatten'),
    baseOrderBy = require('./_baseOrderBy'),
    baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;

},{"./_baseFlatten":1423,"./_baseOrderBy":1454,"./_baseRest":1462,"./_isIterateeCall":1550}],1698:[function(require,module,exports){
var apply = require('./_apply'),
    arrayPush = require('./_arrayPush'),
    baseRest = require('./_baseRest'),
    castSlice = require('./_castSlice'),
    toInteger = require('./toInteger');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * create function and an array of arguments much like
 * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
 *
 * **Note:** This method is based on the
 * [spread operator](https://mdn.io/spread_operator).
 *
 * @static
 * @memberOf _
 * @since 3.2.0
 * @category Function
 * @param {Function} func The function to spread arguments over.
 * @param {number} [start=0] The start position of the spread.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.spread(function(who, what) {
 *   return who + ' says ' + what;
 * });
 *
 * say(['fred', 'hello']);
 * // => 'fred says hello'
 *
 * var numbers = Promise.all([
 *   Promise.resolve(40),
 *   Promise.resolve(36)
 * ]);
 *
 * numbers.then(_.spread(function(x, y) {
 *   return x + y;
 * }));
 * // => a Promise of 76
 */
function spread(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = start == null ? 0 : nativeMax(toInteger(start), 0);
  return baseRest(function(args) {
    var array = args[start],
        otherArgs = castSlice(args, 0, start);

    if (array) {
      arrayPush(otherArgs, array);
    }
    return apply(func, this, otherArgs);
  });
}

module.exports = spread;

},{"./_apply":1391,"./_arrayPush":1400,"./_baseRest":1462,"./_castSlice":1481,"./toInteger":1705}],1699:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],1700:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],1701:[function(require,module,exports){
var baseSlice = require('./_baseSlice');

/**
 * Gets all but the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.tail([1, 2, 3]);
 * // => [2, 3]
 */
function tail(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice(array, 1, length) : [];
}

module.exports = tail;

},{"./_baseSlice":1468}],1702:[function(require,module,exports){
var baseSlice = require('./_baseSlice'),
    toInteger = require('./toInteger');

/**
 * Creates a slice of `array` with `n` elements taken from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.take([1, 2, 3]);
 * // => [1]
 *
 * _.take([1, 2, 3], 2);
 * // => [1, 2]
 *
 * _.take([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.take([1, 2, 3], 0);
 * // => []
 */
function take(array, n, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : toInteger(n);
  return baseSlice(array, 0, n < 0 ? 0 : n);
}

module.exports = take;

},{"./_baseSlice":1468,"./toInteger":1705}],1703:[function(require,module,exports){
var debounce = require('./debounce'),
    isObject = require('./isObject');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

},{"./debounce":1617,"./isObject":1659}],1704:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":1706}],1705:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":1704}],1706:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":1659,"./isSymbol":1663}],1707:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

},{"./_copyObject":1495,"./keysIn":1668}],1708:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":1472}],1709:[function(require,module,exports){
var ary = require('./ary');

/**
 * Creates a function that accepts up to one argument, ignoring any
 * additional arguments.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 * @example
 *
 * _.map(['6', '8', '10'], _.unary(parseInt));
 * // => [6, 8, 10]
 */
function unary(func) {
  return ary(func, 1);
}

module.exports = unary;

},{"./ary":1605}],1710:[function(require,module,exports){
var baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    baseUniq = require('./_baseUniq'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;

},{"./_baseFlatten":1423,"./_baseRest":1462,"./_baseUniq":1474,"./isArrayLikeObject":1650}],1711:[function(require,module,exports){
var toString = require('./toString');

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

module.exports = uniqueId;

},{"./toString":1708}],1712:[function(require,module,exports){
var baseUnset = require('./_baseUnset');

/**
 * Removes the property at `path` of `object`.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 7 } }] };
 * _.unset(object, 'a[0].b.c');
 * // => true
 *
 * console.log(object);
 * // => { 'a': [{ 'b': {} }] };
 *
 * _.unset(object, ['a', '0', 'b', 'c']);
 * // => true
 *
 * console.log(object);
 * // => { 'a': [{ 'b': {} }] };
 */
function unset(object, path) {
  return object == null ? true : baseUnset(object, path);
}

module.exports = unset;

},{"./_baseUnset":1475}],1713:[function(require,module,exports){
var baseValues = require('./_baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

},{"./_baseValues":1476,"./keys":1667}],1714:[function(require,module,exports){
var baseDifference = require('./_baseDifference'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.pull`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([2, 1, 2, 3], 1, 2);
 * // => [3]
 */
var without = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, values)
    : [];
});

module.exports = without;

},{"./_baseDifference":1416,"./_baseRest":1462,"./isArrayLikeObject":1650}],1715:[function(require,module,exports){
var castFunction = require('./_castFunction'),
    partial = require('./partial');

/**
 * Creates a function that provides `value` to `wrapper` as its first
 * argument. Any additional arguments provided to the function are appended
 * to those provided to the `wrapper`. The wrapper is invoked with the `this`
 * binding of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {*} value The value to wrap.
 * @param {Function} [wrapper=identity] The wrapper function.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var p = _.wrap(_.escape, function(func, text) {
 *   return '<p>' + func(text) + '</p>';
 * });
 *
 * p('fred, barney, & pebbles');
 * // => '<p>fred, barney, &amp; pebbles</p>'
 */
function wrap(value, wrapper) {
  return partial(castFunction(wrapper), value);
}

module.exports = wrap;

},{"./_castFunction":1478,"./partial":1682}],1716:[function(require,module,exports){
var LazyWrapper = require('./_LazyWrapper'),
    LodashWrapper = require('./_LodashWrapper'),
    baseLodash = require('./_baseLodash'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike'),
    wrapperClone = require('./_wrapperClone');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array and iteratees accept only
 * one argument. The heuristic for whether a section qualifies for shortcut
 * fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */
function lodash(value) {
  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty.call(value, '__wrapped__')) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}

// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = baseLodash.prototype;
lodash.prototype.constructor = lodash;

module.exports = lodash;

},{"./_LazyWrapper":1377,"./_LodashWrapper":1379,"./_baseLodash":1447,"./_wrapperClone":1603,"./isArray":1648,"./isObjectLike":1660}],1717:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":1310,"trim":1728}],1718:[function(require,module,exports){
/*
 * Copyright (c) 2012 Mathieu Turcotte
 * Licensed under the MIT license.
 */

module.exports = require('./lib/checks');
},{"./lib/checks":1719}],1719:[function(require,module,exports){
/*
 * Copyright (c) 2012 Mathieu Turcotte
 * Licensed under the MIT license.
 */

var util = require('util');

var errors = module.exports = require('./errors');

function failCheck(ExceptionConstructor, callee, messageFormat, formatArgs) {
    messageFormat = messageFormat || '';
    var message = util.format.apply(this, [messageFormat].concat(formatArgs));
    var error = new ExceptionConstructor(message);
    Error.captureStackTrace(error, callee);
    throw error;
}

function failArgumentCheck(callee, message, formatArgs) {
    failCheck(errors.IllegalArgumentError, callee, message, formatArgs);
}

function failStateCheck(callee, message, formatArgs) {
    failCheck(errors.IllegalStateError, callee, message, formatArgs);
}

module.exports.checkArgument = function(value, message) {
    if (!value) {
        failArgumentCheck(arguments.callee, message,
            Array.prototype.slice.call(arguments, 2));
    }
};

module.exports.checkState = function(value, message) {
    if (!value) {
        failStateCheck(arguments.callee, message,
            Array.prototype.slice.call(arguments, 2));
    }
};

module.exports.checkIsDef = function(value, message) {
    if (value !== undefined) {
        return value;
    }

    failArgumentCheck(arguments.callee, message ||
        'Expected value to be defined but was undefined.',
        Array.prototype.slice.call(arguments, 2));
};

module.exports.checkIsDefAndNotNull = function(value, message) {
    // Note that undefined == null.
    if (value != null) {
        return value;
    }

    failArgumentCheck(arguments.callee, message ||
        'Expected value to be defined and not null but got "' +
        typeOf(value) + '".', Array.prototype.slice.call(arguments, 2));
};

// Fixed version of the typeOf operator which returns 'null' for null values
// and 'array' for arrays.
function typeOf(value) {
    var s = typeof value;
    if (s == 'object') {
        if (!value) {
            return 'null';
        } else if (value instanceof Array) {
            return 'array';
        }
    }
    return s;
}

function typeCheck(expect) {
    return function(value, message) {
        var type = typeOf(value);

        if (type == expect) {
            return value;
        }

        failArgumentCheck(arguments.callee, message ||
            'Expected "' + expect + '" but got "' + type + '".',
            Array.prototype.slice.call(arguments, 2));
    };
}

module.exports.checkIsString = typeCheck('string');
module.exports.checkIsArray = typeCheck('array');
module.exports.checkIsNumber = typeCheck('number');
module.exports.checkIsBoolean = typeCheck('boolean');
module.exports.checkIsFunction = typeCheck('function');
module.exports.checkIsObject = typeCheck('object');

},{"./errors":1720,"util":1769}],1720:[function(require,module,exports){
/*
 * Copyright (c) 2012 Mathieu Turcotte
 * Licensed under the MIT license.
 */

var util = require('util');

function IllegalArgumentError(message) {
    Error.call(this, message);
    this.message = message;
}
util.inherits(IllegalArgumentError, Error);

IllegalArgumentError.prototype.name = 'IllegalArgumentError';

function IllegalStateError(message) {
    Error.call(this, message);
    this.message = message;
}
util.inherits(IllegalStateError, Error);

IllegalStateError.prototype.name = 'IllegalStateError';

module.exports.IllegalStateError = IllegalStateError;
module.exports.IllegalArgumentError = IllegalArgumentError;
},{"util":1769}],1721:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1722:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"dup":88}],1723:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');

function fixStatsType(stat) {
  return {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  }[stat.type] || stat.type;
}

function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : dtlsRole || 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    var trackId = transceiver.rtpSender._initialTrackId ||
        transceiver.rtpSender.track.id;
    transceiver.rtpSender._initialTrackId = trackId;
    // spec.
    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
        trackId + '\r\n';
    sdp += 'a=' + msid;
    // for Chrome. Legacy should no longer be required.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;

    // RTX
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
}

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

function maybeAddCandidate(iceTransport, candidate) {
  // Edge's internal representation adds some fields therefore
  // not all fieldѕ are taken into account.
  var alreadyAdded = iceTransport.getRemoteCandidates()
      .find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation &&
            candidate.ip === remoteCandidate.ip &&
            candidate.port === remoteCandidate.port &&
            candidate.priority === remoteCandidate.priority &&
            candidate.protocol === remoteCandidate.protocol &&
            candidate.type === remoteCandidate.type;
      });
  if (!alreadyAdded) {
    iceTransport.addRemoteCandidate(candidate);
  }
  return !alreadyAdded;
}


function makeError(name, description) {
  var e = new Error(description);
  e.name = name;
  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
  e.code = {
    NotSupportedError: 9,
    InvalidStateError: 11,
    InvalidAccessError: 15,
    TypeError: undefined,
    OperationError: undefined
  }[name];
  return e;
}

module.exports = function(window, edgeVersion) {
  // https://w3c.github.io/mediacapture-main/#mediastream
  // Helper function to add the track to the stream and
  // dispatch the event ourselves.
  function addTrackToStreamAndFireEvent(track, stream) {
    stream.addTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
        {track: track}));
  }

  function removeTrackFromStreamAndFireEvent(track, stream) {
    stream.removeTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
        {track: track}));
  }

  function fireAddTrack(pc, track, receiver, streams) {
    var trackEvent = new Event('track');
    trackEvent.track = track;
    trackEvent.receiver = receiver;
    trackEvent.transceiver = {receiver: receiver};
    trackEvent.streams = streams;
    window.setTimeout(function() {
      pc._dispatchEvent('track', trackEvent);
    });
  }

  var RTCPeerConnection = function(config) {
    var pc = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          pc[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.canTrickleIceCandidates = null;

    this.needNegotiation = false;

    this.localStreams = [];
    this.remoteStreams = [];

    this.localDescription = null;
    this.remoteDescription = null;

    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.connectionState = 'new';
    this.iceGatheringState = 'new';

    config = JSON.parse(JSON.stringify(config || {}));

    this.usingBundle = config.bundlePolicy === 'max-bundle';
    if (config.rtcpMuxPolicy === 'negotiate') {
      throw(makeError('NotSupportedError',
          'rtcpMuxPolicy \'negotiate\' is not supported'));
    } else if (!config.rtcpMuxPolicy) {
      config.rtcpMuxPolicy = 'require';
    }

    switch (config.iceTransportPolicy) {
      case 'all':
      case 'relay':
        break;
      default:
        config.iceTransportPolicy = 'all';
        break;
    }

    switch (config.bundlePolicy) {
      case 'balanced':
      case 'max-compat':
      case 'max-bundle':
        break;
      default:
        config.bundlePolicy = 'balanced';
        break;
    }

    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

    this._iceGatherers = [];
    if (config.iceCandidatePoolSize) {
      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
        this._iceGatherers.push(new window.RTCIceGatherer({
          iceServers: config.iceServers,
          gatherPolicy: config.iceTransportPolicy
        }));
      }
    } else {
      config.iceCandidatePoolSize = 0;
    }

    this._config = config;

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
    this._sdpSessionVersion = 0;

    this._dtlsRole = undefined; // role for a=setup to use in answers.

    this._isClosed = false;
  };

  // set up event handlers on prototype
  RTCPeerConnection.prototype.onicecandidate = null;
  RTCPeerConnection.prototype.onaddstream = null;
  RTCPeerConnection.prototype.ontrack = null;
  RTCPeerConnection.prototype.onremovestream = null;
  RTCPeerConnection.prototype.onsignalingstatechange = null;
  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
  RTCPeerConnection.prototype.onconnectionstatechange = null;
  RTCPeerConnection.prototype.onicegatheringstatechange = null;
  RTCPeerConnection.prototype.onnegotiationneeded = null;
  RTCPeerConnection.prototype.ondatachannel = null;

  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
    if (this._isClosed) {
      return;
    }
    this.dispatchEvent(event);
    if (typeof this['on' + name] === 'function') {
      this['on' + name](event);
    }
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this._dispatchEvent('icegatheringstatechange', event);
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  RTCPeerConnection.prototype.getLocalStreams = function() {
    return this.localStreams;
  };

  RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  };

  // internal helper to create a transceiver object.
  // (which is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      associatedRemoteMediaStreams: [],
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    if (!doNotAdd) {
      this.transceivers.push(transceiver);
    }
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call addTrack on a closed peerconnection.');
    }

    var alreadyExists = this.transceivers.find(function(s) {
      return s.track === track;
    });

    if (alreadyExists) {
      throw makeError('InvalidAccessError', 'Track already exists.');
    }

    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    this._maybeFireNegotiationNeeded();

    if (this.localStreams.indexOf(stream) === -1) {
      this.localStreams.push(stream);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var pc = this;
    if (edgeVersion >= 15025) {
      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        pc.addTrack(track, clonedStream);
      });
    }
  };

  RTCPeerConnection.prototype.removeTrack = function(sender) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call removeTrack on a closed peerconnection.');
    }

    if (!(sender instanceof window.RTCRtpSender)) {
      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
          'does not implement interface RTCRtpSender.');
    }

    var transceiver = this.transceivers.find(function(t) {
      return t.rtpSender === sender;
    });

    if (!transceiver) {
      throw makeError('InvalidAccessError',
          'Sender was not created by this connection.');
    }
    var stream = transceiver.stream;

    transceiver.rtpSender.stop();
    transceiver.rtpSender = null;
    transceiver.track = null;
    transceiver.stream = null;

    // remove the stream from the set of local streams
    var localStreams = this.transceivers.map(function(t) {
      return t.stream;
    });
    if (localStreams.indexOf(stream) === -1 &&
        this.localStreams.indexOf(stream) > -1) {
      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
    }

    this._maybeFireNegotiationNeeded();
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var pc = this;
    stream.getTracks().forEach(function(track) {
      var sender = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (sender) {
        pc.removeTrack(sender);
      }
    });
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };


  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
      usingBundle) {
    var pc = this;
    if (usingBundle && sdpMLineIndex > 0) {
      return this.transceivers[0].iceGatherer;
    } else if (this._iceGatherers.length) {
      return this._iceGatherers.shift();
    }
    var iceGatherer = new window.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    Object.defineProperty(iceGatherer, 'state',
        {value: 'new', writable: true}
    );

    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      // polyfill since RTCIceGatherer.state is not implemented in
      // Edge 10547 yet.
      iceGatherer.state = end ? 'completed' : 'gathering';
      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
      }
    };
    iceGatherer.addEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    return iceGatherer;
  };

  // start gathering from an RTCIceGatherer.
  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
    var pc = this;
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer.onlocalcandidate) {
      return;
    }
    var bufferedCandidateEvents =
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
    iceGatherer.removeEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    iceGatherer.onlocalcandidate = function(evt) {
      if (pc.usingBundle && sdpMLineIndex > 0) {
        // if we know that we use bundle we can drop candidates with
        // ѕdpMLineIndex > 0. If we don't do this then our state gets
        // confused since we dispose the extra ice gatherer.
        return;
      }
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      // Edge emits an empty object for RTCIceCandidateComplete‥
      var end = !cand || Object.keys(cand).length === 0;
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
          iceGatherer.state = 'completed';
        }
      } else {
        if (iceGatherer.state === 'new') {
          iceGatherer.state = 'gathering';
        }
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        // also the usernameFragment. TODO: update SDP to take both variants.
        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

        var serializedCandidate = SDPUtils.writeCandidate(cand);
        event.candidate = Object.assign(event.candidate,
            SDPUtils.parseCandidate(serializedCandidate));

        event.candidate.candidate = serializedCandidate;
        event.candidate.toJSON = function() {
          return {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            usernameFragment: event.candidate.usernameFragment
          };
        };
      }

      // update local description.
      var sections = SDPUtils.getMediaSections(pc.localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex] +=
            'a=end-of-candidates\r\n';
      }
      pc.localDescription.sdp =
          SDPUtils.getDescription(pc.localDescription.sdp) +
          sections.join('');
      var complete = pc.transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      if (pc.iceGatheringState !== 'gathering') {
        pc.iceGatheringState = 'gathering';
        pc._emitGatheringStateChange();
      }

      // Emit candidate. Also emit null candidate when all gatherers are
      // complete.
      if (!end) {
        pc._dispatchEvent('icecandidate', event);
      }
      if (complete) {
        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
        pc.iceGatheringState = 'complete';
        pc._emitGatheringStateChange();
      }
    };

    // emit already gathered candidates.
    window.setTimeout(function() {
      bufferedCandidateEvents.forEach(function(e) {
        iceGatherer.onlocalcandidate(e);
      });
    }, 0);
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var pc = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      pc._updateIceConnectionState();
      pc._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      pc._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      pc._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      if (transceiver.recvEncodingParameters.length) {
        params.encodings = transceiver.recvEncodingParameters;
      } else {
        params.encodings = [{}];
      }
      params.rtcp = {
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.rtcpParameters.cname) {
        params.rtcp.cname = transceiver.rtcpParameters.cname;
      }
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set local ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // VERY limited support for SDP munging. Limited to:
      // * changing the order of codecs
      sections = SDPUtils.splitSections(description.sdp);
      sessionpart = sections.shift();
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var caps = SDPUtils.parseRtpParameters(mediaSection);
        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
      });

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        pc._gather(transceiver.mid, sdpMLineIndex);
      });
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(pc.remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = pc.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

        if (!rejected && !transceiver.rejected) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!pc.usingBundle || sdpMLineIndex === 0) {
            pc._gather(transceiver.mid, sdpMLineIndex);
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  isIceLite ? 'controlling' : 'controlled');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          pc._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    pc.localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-local-offer');
    } else {
      pc._updateSignalingState('stable');
    }

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set remote ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var streams = {};
    pc.remoteStreams.forEach(function(stream) {
      streams[stream.id] = stream;
    });
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    pc.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      pc.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      // treat bundle-only as not-rejected.
      var rejected = SDPUtils.isRejected(mediaSection) &&
          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if ((kind === 'application' && protocol === 'DTLS/SCTP') || rejected) {
        // TODO: this is dangerous in the case where a non-rejected m-line
        //     becomes rejected.
        pc.transceivers[sdpMLineIndex] = {
          mid: mid,
          kind: kind,
          rejected: true
        };
        return;
      }

      if (!rejected && pc.transceivers[sdpMLineIndex] &&
          pc.transceivers[sdpMLineIndex].rejected) {
        // recycle a rejected transceiver.
        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          pc.transceivers[sdpMLineIndex]) {
        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
        pc.transceivers[sdpMLineIndex].iceGatherer =
            pc.transceivers[0].iceGatherer;
        pc.transceivers[sdpMLineIndex].iceTransport =
            pc.transceivers[0].iceTransport;
        pc.transceivers[sdpMLineIndex].dtlsTransport =
            pc.transceivers[0].dtlsTransport;
        if (pc.transceivers[sdpMLineIndex].rtpSender) {
          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex] ||
            pc._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              usingBundle);
        }

        if (cands.length && transceiver.iceTransport.state === 'new') {
          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
            transceiver.iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        var isNewTrack = false;
        if (direction === 'sendrecv' || direction === 'sendonly') {
          isNewTrack = !transceiver.rtpReceiver;
          rtpReceiver = transceiver.rtpReceiver ||
              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

          if (isNewTrack) {
            var stream;
            track = rtpReceiver.track;
            // FIXME: does not work with Plan B.
            if (remoteMsid && remoteMsid.stream === '-') {
              // no-op. a stream id of '-' means: no associated stream.
            } else if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                  get: function() {
                    return remoteMsid.stream;
                  }
                });
              }
              Object.defineProperty(track, 'id', {
                get: function() {
                  return remoteMsid.track;
                }
              });
              stream = streams[remoteMsid.stream];
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              stream = streams.default;
            }
            if (stream) {
              addTrackToStreamAndFireEvent(track, stream);
              transceiver.associatedRemoteMediaStreams.push(stream);
            }
            receiverList.push([track, rtpReceiver, stream]);
          }
        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
            var nativeTrack = s.getTracks().find(function(t) {
              return t.id === transceiver.rtpReceiver.track.id;
            });
            if (nativeTrack) {
              removeTrackFromStreamAndFireEvent(nativeTrack, s);
            }
          });
          transceiver.associatedRemoteMediaStreams = [];
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        pc._transceive(pc.transceivers[sdpMLineIndex],
            false,
            isNewTrack);
      } else if (description.type === 'answer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        pc.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (cands.length && iceTransport.state === 'new') {
          if ((isIceLite || isComplete) &&
              (!usingBundle || sdpMLineIndex === 0)) {
            iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        if (!usingBundle || sdpMLineIndex === 0) {
          if (iceTransport.state === 'new') {
            iceTransport.start(iceGatherer, remoteIceParameters,
                'controlling');
          }
          if (dtlsTransport.state === 'new') {
            dtlsTransport.start(remoteDtlsParameters);
          }
        }

        pc._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams.default);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    if (pc._dtlsRole === undefined) {
      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
    }

    pc.remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-remote-offer');
    } else {
      pc._updateSignalingState('stable');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        if (pc.remoteStreams.indexOf(stream) === -1) {
          pc.remoteStreams.push(stream);
          var event = new Event('addstream');
          event.stream = stream;
          window.setTimeout(function() {
            pc._dispatchEvent('addstream', event);
          });
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          fireAddTrack(pc, track, receiver, [stream]);
        });
      }
    });
    receiverList.forEach(function(item) {
      if (item[2]) {
        return;
      }
      fireAddTrack(pc, item[0], item[1], []);
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(pc && pc.transceivers)) {
        return;
      }
      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._isClosed = true;
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this._dispatchEvent('signalingstatechange', event);
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var pc = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (pc.needNegotiation) {
        pc.needNegotiation = false;
        var event = new Event('negotiationneeded');
        pc._dispatchEvent('negotiationneeded', event);
      }
    }, 0);
  };

  // Update the ice connection state.
  RTCPeerConnection.prototype._updateIceConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      states[transceiver.iceTransport.state]++;
    });

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.checking > 0) {
      newState = 'checking';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    } else if (states.completed > 0) {
      newState = 'completed';
    }

    if (newState !== this.iceConnectionState) {
      this.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this._dispatchEvent('iceconnectionstatechange', event);
    }
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      states[transceiver.iceTransport.state]++;
      states[transceiver.dtlsTransport.state]++;
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    }

    if (newState !== this.connectionState) {
      this.connectionState = newState;
      var event = new Event('connectionstatechange');
      this._dispatchEvent('connectionstatechange', event);
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createOffer after close'));
    }

    var numAudioTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    var offerOptions = arguments[0];
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    pc.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        pc._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        pc._createTransceiver('video');
        numVideoTracks--;
      }
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = transceiver.mid || SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
            pc.usingBundle);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }

        // for subsequent offers, we might have to re-use the payload
        // type of the last offer.
        if (transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.codecs) {
          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                codec.clockRate === remoteCodec.clockRate) {
              codec.preferredPayloadType = remoteCodec.payloadType;
            }
          });
        }
      });
      localCapabilities.headerExtensions.forEach(function(hdrExt) {
        var remoteExtensions = transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.headerExtensions || [];
        remoteExtensions.forEach(function(rHdrExt) {
          if (hdrExt.uri === rHdrExt.uri) {
            hdrExt.id = rHdrExt.id;
          }
        });
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video' &&
            !sendEncodingParameters[0].rtx) {
          sendEncodingParameters[0].rtx = {
            ssrc: sendEncodingParameters[0].ssrc + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
            transceiver.dtlsTransport, kind);
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (pc._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
          'offer', transceiver.stream, pc._dtlsRole);
      sdp += 'a=rtcp-rsize\r\n';

      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
          (sdpMLineIndex === 0 || !pc.usingBundle)) {
        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
          cand.component = 1;
          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
        });

        if (transceiver.iceGatherer.state === 'completed') {
          sdp += 'a=end-of-candidates\r\n';
        }
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer after close'));
    }

    if (!(pc.signalingState === 'have-remote-offer' ||
        pc.signalingState === 'have-local-pranswer')) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer in signalingState ' + pc.signalingState));
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    if (pc.usingBundle) {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    var mediaSectionsInOffer = SDPUtils.getMediaSections(
        pc.remoteDescription.sdp).length;
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
        return;
      }
      if (transceiver.rejected) {
        if (transceiver.kind === 'application') {
          sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
        } else if (transceiver.kind === 'audio') {
          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
              'a=rtpmap:0 PCMU/8000\r\n';
        } else if (transceiver.kind === 'video') {
          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
              'a=rtpmap:120 VP8/90000\r\n';
        }
        sdp += 'c=IN IP4 0.0.0.0\r\n' +
            'a=inactive\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
              !transceiver.sendEncodingParameters[0].rtx) {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream, pc._dtlsRole);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    var pc = this;
    var sections;
    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
        candidate.sdpMid)) {
      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
    }

    // TODO: needs to go into ops queue.
    return new Promise(function(resolve, reject) {
      if (!pc.remoteDescription) {
        return reject(makeError('InvalidStateError',
            'Can not add ICE candidate without a remote description'));
      } else if (!candidate || candidate.candidate === '') {
        for (var j = 0; j < pc.transceivers.length; j++) {
          if (pc.transceivers[j].rejected) {
            continue;
          }
          pc.transceivers[j].iceTransport.addRemoteCandidate({});
          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);
          sections[j] += 'a=end-of-candidates\r\n';
          pc.remoteDescription.sdp =
              SDPUtils.getDescription(pc.remoteDescription.sdp) +
              sections.join('');
          if (pc.usingBundle) {
            break;
          }
        }
      } else {
        var sdpMLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < pc.transceivers.length; i++) {
            if (pc.transceivers[i].mid === candidate.sdpMid) {
              sdpMLineIndex = i;
              break;
            }
          }
        }
        var transceiver = pc.transceivers[sdpMLineIndex];
        if (transceiver) {
          if (transceiver.rejected) {
            return resolve();
          }
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return resolve();
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component && cand.component !== 1) {
            return resolve();
          }
          // when using bundle, avoid adding candidates to the wrong
          // ice transport. And avoid adding candidates added in the SDP.
          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
              return reject(makeError('OperationError',
                  'Can not add ICE candidate'));
            }
          }

          // update the remoteDescription.
          var candidateString = candidate.candidate.trim();
          if (candidateString.indexOf('a=') === 0) {
            candidateString = candidateString.substr(2);
          }
          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);
          sections[sdpMLineIndex] += 'a=' +
              (cand.type ? candidateString : 'end-of-candidates')
              + '\r\n';
          pc.remoteDescription.sdp =
              SDPUtils.getDescription(pc.remoteDescription.sdp) +
              sections.join('');
        } else {
          return reject(makeError('OperationError',
              'Can not add ICE candidate'));
        }
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.getStats = function(selector) {
    if (selector && selector instanceof window.MediaStreamTrack) {
      var senderOrReceiver = null;
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.rtpSender &&
            transceiver.rtpSender.track === selector) {
          senderOrReceiver = transceiver.rtpSender;
        } else if (transceiver.rtpReceiver &&
            transceiver.rtpReceiver.track === selector) {
          senderOrReceiver = transceiver.rtpReceiver;
        }
      });
      if (!senderOrReceiver) {
        throw makeError('InvalidAccessError', 'Invalid selector.');
      }
      return senderOrReceiver.getStats();
    }

    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
          'dtlsTransport'].forEach(function(method) {
            if (transceiver[method]) {
              promises.push(transceiver[method].getStats());
            }
          });
    });
    return Promise.all(promises).then(function(allStats) {
      var results = new Map();
      allStats.forEach(function(stats) {
        stats.forEach(function(stat) {
          results.set(stat.id, stat);
        });
      });
      return results;
    });
  };

  // fix low-level stat names and return Map instead of object.
  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
    'RTCIceTransport', 'RTCDtlsTransport'];
  ortcObjects.forEach(function(ortcObjectName) {
    var obj = window[ortcObjectName];
    if (obj && obj.prototype && obj.prototype.getStats) {
      var nativeGetstats = obj.prototype.getStats;
      obj.prototype.getStats = function() {
        return nativeGetstats.apply(this)
        .then(function(nativeStats) {
          var mapStats = new Map();
          Object.keys(nativeStats).forEach(function(id) {
            nativeStats[id].type = fixStatsType(nativeStats[id]);
            mapStats.set(id, nativeStats[id]);
          });
          return mapStats;
        });
      };
    }
  });

  // legacy callback shims. Should be moved to adapter.js some days.
  var methods = ['createOffer', 'createAnswer'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[0] === 'function' ||
          typeof args[1] === 'function') { // legacy
        return nativeMethod.apply(this, [arguments[2]])
        .then(function(description) {
          if (typeof args[0] === 'function') {
            args[0].apply(null, [description]);
          }
        }, function(error) {
          if (typeof args[1] === 'function') {
            args[1].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function' ||
          typeof args[2] === 'function') { // legacy
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        }, function(error) {
          if (typeof args[2] === 'function') {
            args[2].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  // getStats is special. It doesn't have a spec legacy method yet we support
  // getStats(something, cb) without error callbacks.
  ['getStats'].forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function') {
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  return RTCPeerConnection;
};

},{"sdp":1722}],1724:[function(require,module,exports){
function count(self, substr) {
  var count = 0
  var pos = self.indexOf(substr)

  while (pos >= 0) {
    count += 1
    pos = self.indexOf(substr, pos + 1)
  }

  return count
}

module.exports = count
},{}],1725:[function(require,module,exports){
function splitLeft(self, sep, maxSplit, limit) {

  if (typeof maxSplit === 'undefined') {
    var maxSplit = -1;
  }

  var splitResult = self.split(sep);
  var splitPart1 = splitResult.slice(0, maxSplit);
  var splitPart2 = splitResult.slice(maxSplit);

  if (splitPart2.length === 0) {
    splitResult = splitPart1;
  } else {
    splitResult = splitPart1.concat(splitPart2.join(sep));
  }

  if (typeof limit === 'undefined') {
    return splitResult;
  } else if (limit < 0) {
    return splitResult.slice(limit);
  } else {
    return splitResult.slice(0, limit);
  }

}

module.exports = splitLeft;

},{}],1726:[function(require,module,exports){
function splitRight(self, sep, maxSplit, limit) {

  if (typeof maxSplit === 'undefined') {
    var maxSplit = -1;
  }
  if (typeof limit === 'undefined') {
    var limit = 0;
  }

  var splitResult = [self];

  for (var i = self.length-1; i >= 0; i--) {

    if (
      splitResult[0].slice(i).indexOf(sep) === 0 &&
      (splitResult.length <= maxSplit || maxSplit === -1)
    ) {
      splitResult.splice(1, 0, splitResult[0].slice(i+sep.length)); // insert
      splitResult[0] = splitResult[0].slice(0, i)
    }
  }

  if (limit >= 0) {
    return splitResult.slice(-limit);
  } else {
    return splitResult.slice(0, -limit);
  }

}

module.exports = splitRight;

},{}],1727:[function(require,module,exports){
/*
string.js - Copyright (C) 2012-2014, JP Richardson <jprichardson@gmail.com>
*/

!(function() {
  "use strict";

  var VERSION = '3.3.3';

  var ENTITIES = {};

  // from http://semplicewebsites.com/removing-accents-javascript
  var latin_map={"Á":"A","Ă":"A","Ắ":"A","Ặ":"A","Ằ":"A","Ẳ":"A","Ẵ":"A","Ǎ":"A","Â":"A","Ấ":"A","Ậ":"A","Ầ":"A","Ẩ":"A","Ẫ":"A","Ä":"A","Ǟ":"A","Ȧ":"A","Ǡ":"A","Ạ":"A","Ȁ":"A","À":"A","Ả":"A","Ȃ":"A","Ā":"A","Ą":"A","Å":"A","Ǻ":"A","Ḁ":"A","Ⱥ":"A","Ã":"A","Ꜳ":"AA","Æ":"AE","Ǽ":"AE","Ǣ":"AE","Ꜵ":"AO","Ꜷ":"AU","Ꜹ":"AV","Ꜻ":"AV","Ꜽ":"AY","Ḃ":"B","Ḅ":"B","Ɓ":"B","Ḇ":"B","Ƀ":"B","Ƃ":"B","Ć":"C","Č":"C","Ç":"C","Ḉ":"C","Ĉ":"C","Ċ":"C","Ƈ":"C","Ȼ":"C","Ď":"D","Ḑ":"D","Ḓ":"D","Ḋ":"D","Ḍ":"D","Ɗ":"D","Ḏ":"D","ǲ":"D","ǅ":"D","Đ":"D","Ƌ":"D","Ǳ":"DZ","Ǆ":"DZ","É":"E","Ĕ":"E","Ě":"E","Ȩ":"E","Ḝ":"E","Ê":"E","Ế":"E","Ệ":"E","Ề":"E","Ể":"E","Ễ":"E","Ḙ":"E","Ë":"E","Ė":"E","Ẹ":"E","Ȅ":"E","È":"E","Ẻ":"E","Ȇ":"E","Ē":"E","Ḗ":"E","Ḕ":"E","Ę":"E","Ɇ":"E","Ẽ":"E","Ḛ":"E","Ꝫ":"ET","Ḟ":"F","Ƒ":"F","Ǵ":"G","Ğ":"G","Ǧ":"G","Ģ":"G","Ĝ":"G","Ġ":"G","Ɠ":"G","Ḡ":"G","Ǥ":"G","Ḫ":"H","Ȟ":"H","Ḩ":"H","Ĥ":"H","Ⱨ":"H","Ḧ":"H","Ḣ":"H","Ḥ":"H","Ħ":"H","Í":"I","Ĭ":"I","Ǐ":"I","Î":"I","Ï":"I","Ḯ":"I","İ":"I","Ị":"I","Ȉ":"I","Ì":"I","Ỉ":"I","Ȋ":"I","Ī":"I","Į":"I","Ɨ":"I","Ĩ":"I","Ḭ":"I","Ꝺ":"D","Ꝼ":"F","Ᵹ":"G","Ꞃ":"R","Ꞅ":"S","Ꞇ":"T","Ꝭ":"IS","Ĵ":"J","Ɉ":"J","Ḱ":"K","Ǩ":"K","Ķ":"K","Ⱪ":"K","Ꝃ":"K","Ḳ":"K","Ƙ":"K","Ḵ":"K","Ꝁ":"K","Ꝅ":"K","Ĺ":"L","Ƚ":"L","Ľ":"L","Ļ":"L","Ḽ":"L","Ḷ":"L","Ḹ":"L","Ⱡ":"L","Ꝉ":"L","Ḻ":"L","Ŀ":"L","Ɫ":"L","ǈ":"L","Ł":"L","Ǉ":"LJ","Ḿ":"M","Ṁ":"M","Ṃ":"M","Ɱ":"M","Ń":"N","Ň":"N","Ņ":"N","Ṋ":"N","Ṅ":"N","Ṇ":"N","Ǹ":"N","Ɲ":"N","Ṉ":"N","Ƞ":"N","ǋ":"N","Ñ":"N","Ǌ":"NJ","Ó":"O","Ŏ":"O","Ǒ":"O","Ô":"O","Ố":"O","Ộ":"O","Ồ":"O","Ổ":"O","Ỗ":"O","Ö":"O","Ȫ":"O","Ȯ":"O","Ȱ":"O","Ọ":"O","Ő":"O","Ȍ":"O","Ò":"O","Ỏ":"O","Ơ":"O","Ớ":"O","Ợ":"O","Ờ":"O","Ở":"O","Ỡ":"O","Ȏ":"O","Ꝋ":"O","Ꝍ":"O","Ō":"O","Ṓ":"O","Ṑ":"O","Ɵ":"O","Ǫ":"O","Ǭ":"O","Ø":"O","Ǿ":"O","Õ":"O","Ṍ":"O","Ṏ":"O","Ȭ":"O","Ƣ":"OI","Ꝏ":"OO","Ɛ":"E","Ɔ":"O","Ȣ":"OU","Ṕ":"P","Ṗ":"P","Ꝓ":"P","Ƥ":"P","Ꝕ":"P","Ᵽ":"P","Ꝑ":"P","Ꝙ":"Q","Ꝗ":"Q","Ŕ":"R","Ř":"R","Ŗ":"R","Ṙ":"R","Ṛ":"R","Ṝ":"R","Ȑ":"R","Ȓ":"R","Ṟ":"R","Ɍ":"R","Ɽ":"R","Ꜿ":"C","Ǝ":"E","Ś":"S","Ṥ":"S","Š":"S","Ṧ":"S","Ş":"S","Ŝ":"S","Ș":"S","Ṡ":"S","Ṣ":"S","Ṩ":"S","ẞ":"SS","Ť":"T","Ţ":"T","Ṱ":"T","Ț":"T","Ⱦ":"T","Ṫ":"T","Ṭ":"T","Ƭ":"T","Ṯ":"T","Ʈ":"T","Ŧ":"T","Ɐ":"A","Ꞁ":"L","Ɯ":"M","Ʌ":"V","Ꜩ":"TZ","Ú":"U","Ŭ":"U","Ǔ":"U","Û":"U","Ṷ":"U","Ü":"U","Ǘ":"U","Ǚ":"U","Ǜ":"U","Ǖ":"U","Ṳ":"U","Ụ":"U","Ű":"U","Ȕ":"U","Ù":"U","Ủ":"U","Ư":"U","Ứ":"U","Ự":"U","Ừ":"U","Ử":"U","Ữ":"U","Ȗ":"U","Ū":"U","Ṻ":"U","Ų":"U","Ů":"U","Ũ":"U","Ṹ":"U","Ṵ":"U","Ꝟ":"V","Ṿ":"V","Ʋ":"V","Ṽ":"V","Ꝡ":"VY","Ẃ":"W","Ŵ":"W","Ẅ":"W","Ẇ":"W","Ẉ":"W","Ẁ":"W","Ⱳ":"W","Ẍ":"X","Ẋ":"X","Ý":"Y","Ŷ":"Y","Ÿ":"Y","Ẏ":"Y","Ỵ":"Y","Ỳ":"Y","Ƴ":"Y","Ỷ":"Y","Ỿ":"Y","Ȳ":"Y","Ɏ":"Y","Ỹ":"Y","Ź":"Z","Ž":"Z","Ẑ":"Z","Ⱬ":"Z","Ż":"Z","Ẓ":"Z","Ȥ":"Z","Ẕ":"Z","Ƶ":"Z","Ĳ":"IJ","Œ":"OE","ᴀ":"A","ᴁ":"AE","ʙ":"B","ᴃ":"B","ᴄ":"C","ᴅ":"D","ᴇ":"E","ꜰ":"F","ɢ":"G","ʛ":"G","ʜ":"H","ɪ":"I","ʁ":"R","ᴊ":"J","ᴋ":"K","ʟ":"L","ᴌ":"L","ᴍ":"M","ɴ":"N","ᴏ":"O","ɶ":"OE","ᴐ":"O","ᴕ":"OU","ᴘ":"P","ʀ":"R","ᴎ":"N","ᴙ":"R","ꜱ":"S","ᴛ":"T","ⱻ":"E","ᴚ":"R","ᴜ":"U","ᴠ":"V","ᴡ":"W","ʏ":"Y","ᴢ":"Z","á":"a","ă":"a","ắ":"a","ặ":"a","ằ":"a","ẳ":"a","ẵ":"a","ǎ":"a","â":"a","ấ":"a","ậ":"a","ầ":"a","ẩ":"a","ẫ":"a","ä":"a","ǟ":"a","ȧ":"a","ǡ":"a","ạ":"a","ȁ":"a","à":"a","ả":"a","ȃ":"a","ā":"a","ą":"a","ᶏ":"a","ẚ":"a","å":"a","ǻ":"a","ḁ":"a","ⱥ":"a","ã":"a","ꜳ":"aa","æ":"ae","ǽ":"ae","ǣ":"ae","ꜵ":"ao","ꜷ":"au","ꜹ":"av","ꜻ":"av","ꜽ":"ay","ḃ":"b","ḅ":"b","ɓ":"b","ḇ":"b","ᵬ":"b","ᶀ":"b","ƀ":"b","ƃ":"b","ɵ":"o","ć":"c","č":"c","ç":"c","ḉ":"c","ĉ":"c","ɕ":"c","ċ":"c","ƈ":"c","ȼ":"c","ď":"d","ḑ":"d","ḓ":"d","ȡ":"d","ḋ":"d","ḍ":"d","ɗ":"d","ᶑ":"d","ḏ":"d","ᵭ":"d","ᶁ":"d","đ":"d","ɖ":"d","ƌ":"d","ı":"i","ȷ":"j","ɟ":"j","ʄ":"j","ǳ":"dz","ǆ":"dz","é":"e","ĕ":"e","ě":"e","ȩ":"e","ḝ":"e","ê":"e","ế":"e","ệ":"e","ề":"e","ể":"e","ễ":"e","ḙ":"e","ë":"e","ė":"e","ẹ":"e","ȅ":"e","è":"e","ẻ":"e","ȇ":"e","ē":"e","ḗ":"e","ḕ":"e","ⱸ":"e","ę":"e","ᶒ":"e","ɇ":"e","ẽ":"e","ḛ":"e","ꝫ":"et","ḟ":"f","ƒ":"f","ᵮ":"f","ᶂ":"f","ǵ":"g","ğ":"g","ǧ":"g","ģ":"g","ĝ":"g","ġ":"g","ɠ":"g","ḡ":"g","ᶃ":"g","ǥ":"g","ḫ":"h","ȟ":"h","ḩ":"h","ĥ":"h","ⱨ":"h","ḧ":"h","ḣ":"h","ḥ":"h","ɦ":"h","ẖ":"h","ħ":"h","ƕ":"hv","í":"i","ĭ":"i","ǐ":"i","î":"i","ï":"i","ḯ":"i","ị":"i","ȉ":"i","ì":"i","ỉ":"i","ȋ":"i","ī":"i","į":"i","ᶖ":"i","ɨ":"i","ĩ":"i","ḭ":"i","ꝺ":"d","ꝼ":"f","ᵹ":"g","ꞃ":"r","ꞅ":"s","ꞇ":"t","ꝭ":"is","ǰ":"j","ĵ":"j","ʝ":"j","ɉ":"j","ḱ":"k","ǩ":"k","ķ":"k","ⱪ":"k","ꝃ":"k","ḳ":"k","ƙ":"k","ḵ":"k","ᶄ":"k","ꝁ":"k","ꝅ":"k","ĺ":"l","ƚ":"l","ɬ":"l","ľ":"l","ļ":"l","ḽ":"l","ȴ":"l","ḷ":"l","ḹ":"l","ⱡ":"l","ꝉ":"l","ḻ":"l","ŀ":"l","ɫ":"l","ᶅ":"l","ɭ":"l","ł":"l","ǉ":"lj","ſ":"s","ẜ":"s","ẛ":"s","ẝ":"s","ḿ":"m","ṁ":"m","ṃ":"m","ɱ":"m","ᵯ":"m","ᶆ":"m","ń":"n","ň":"n","ņ":"n","ṋ":"n","ȵ":"n","ṅ":"n","ṇ":"n","ǹ":"n","ɲ":"n","ṉ":"n","ƞ":"n","ᵰ":"n","ᶇ":"n","ɳ":"n","ñ":"n","ǌ":"nj","ó":"o","ŏ":"o","ǒ":"o","ô":"o","ố":"o","ộ":"o","ồ":"o","ổ":"o","ỗ":"o","ö":"o","ȫ":"o","ȯ":"o","ȱ":"o","ọ":"o","ő":"o","ȍ":"o","ò":"o","ỏ":"o","ơ":"o","ớ":"o","ợ":"o","ờ":"o","ở":"o","ỡ":"o","ȏ":"o","ꝋ":"o","ꝍ":"o","ⱺ":"o","ō":"o","ṓ":"o","ṑ":"o","ǫ":"o","ǭ":"o","ø":"o","ǿ":"o","õ":"o","ṍ":"o","ṏ":"o","ȭ":"o","ƣ":"oi","ꝏ":"oo","ɛ":"e","ᶓ":"e","ɔ":"o","ᶗ":"o","ȣ":"ou","ṕ":"p","ṗ":"p","ꝓ":"p","ƥ":"p","ᵱ":"p","ᶈ":"p","ꝕ":"p","ᵽ":"p","ꝑ":"p","ꝙ":"q","ʠ":"q","ɋ":"q","ꝗ":"q","ŕ":"r","ř":"r","ŗ":"r","ṙ":"r","ṛ":"r","ṝ":"r","ȑ":"r","ɾ":"r","ᵳ":"r","ȓ":"r","ṟ":"r","ɼ":"r","ᵲ":"r","ᶉ":"r","ɍ":"r","ɽ":"r","ↄ":"c","ꜿ":"c","ɘ":"e","ɿ":"r","ś":"s","ṥ":"s","š":"s","ṧ":"s","ş":"s","ŝ":"s","ș":"s","ṡ":"s","ṣ":"s","ṩ":"s","ʂ":"s","ᵴ":"s","ᶊ":"s","ȿ":"s","ɡ":"g","ß":"ss","ᴑ":"o","ᴓ":"o","ᴝ":"u","ť":"t","ţ":"t","ṱ":"t","ț":"t","ȶ":"t","ẗ":"t","ⱦ":"t","ṫ":"t","ṭ":"t","ƭ":"t","ṯ":"t","ᵵ":"t","ƫ":"t","ʈ":"t","ŧ":"t","ᵺ":"th","ɐ":"a","ᴂ":"ae","ǝ":"e","ᵷ":"g","ɥ":"h","ʮ":"h","ʯ":"h","ᴉ":"i","ʞ":"k","ꞁ":"l","ɯ":"m","ɰ":"m","ᴔ":"oe","ɹ":"r","ɻ":"r","ɺ":"r","ⱹ":"r","ʇ":"t","ʌ":"v","ʍ":"w","ʎ":"y","ꜩ":"tz","ú":"u","ŭ":"u","ǔ":"u","û":"u","ṷ":"u","ü":"u","ǘ":"u","ǚ":"u","ǜ":"u","ǖ":"u","ṳ":"u","ụ":"u","ű":"u","ȕ":"u","ù":"u","ủ":"u","ư":"u","ứ":"u","ự":"u","ừ":"u","ử":"u","ữ":"u","ȗ":"u","ū":"u","ṻ":"u","ų":"u","ᶙ":"u","ů":"u","ũ":"u","ṹ":"u","ṵ":"u","ᵫ":"ue","ꝸ":"um","ⱴ":"v","ꝟ":"v","ṿ":"v","ʋ":"v","ᶌ":"v","ⱱ":"v","ṽ":"v","ꝡ":"vy","ẃ":"w","ŵ":"w","ẅ":"w","ẇ":"w","ẉ":"w","ẁ":"w","ⱳ":"w","ẘ":"w","ẍ":"x","ẋ":"x","ᶍ":"x","ý":"y","ŷ":"y","ÿ":"y","ẏ":"y","ỵ":"y","ỳ":"y","ƴ":"y","ỷ":"y","ỿ":"y","ȳ":"y","ẙ":"y","ɏ":"y","ỹ":"y","ź":"z","ž":"z","ẑ":"z","ʑ":"z","ⱬ":"z","ż":"z","ẓ":"z","ȥ":"z","ẕ":"z","ᵶ":"z","ᶎ":"z","ʐ":"z","ƶ":"z","ɀ":"z","ﬀ":"ff","ﬃ":"ffi","ﬄ":"ffl","ﬁ":"fi","ﬂ":"fl","ĳ":"ij","œ":"oe","ﬆ":"st","ₐ":"a","ₑ":"e","ᵢ":"i","ⱼ":"j","ₒ":"o","ᵣ":"r","ᵤ":"u","ᵥ":"v","ₓ":"x"};

//******************************************************************************
// Added an initialize function which is essentially the code from the S
// constructor.  Now, the S constructor calls this and a new method named
// setValue calls it as well.  The setValue function allows constructors for
// modules that extend string.js to set the initial value of an object without
// knowing the internal workings of string.js.
//
// Also, all methods which return a new S object now call:
//
//      return new this.constructor(s);
//
// instead of:
//
//      return new S(s);
//
// This allows extended objects to keep their proper instanceOf and constructor.
//******************************************************************************

  function initialize (object, s) {
    if (s !== null && s !== undefined) {
      if (typeof s === 'string')
        object.s = s;
      else
        object.s = s.toString();
    } else {
      object.s = s; //null or undefined
    }

    object.orig = s; //original object, currently only used by toCSV() and toBoolean()

    if (s !== null && s !== undefined) {
      if (object.__defineGetter__) {
        object.__defineGetter__('length', function() {
          return object.s.length;
        })
      } else {
        object.length = s.length;
      }
    } else {
      object.length = -1;
    }
  }

  function S(s) {
  	initialize(this, s);
  }

  var __nsp = String.prototype;
  var __sp = S.prototype = {

    between: function(left, right) {
      var s = this.s;
      var startPos = s.indexOf(left);
      var endPos = s.indexOf(right, startPos + left.length);
      if (endPos == -1 && right != null)
        return new this.constructor('')
      else if (endPos == -1 && right == null)
        return new this.constructor(s.substring(startPos + left.length))
      else
        return new this.constructor(s.slice(startPos + left.length, endPos));
    },

    //# modified slightly from https://github.com/epeli/underscore.string
    camelize: function() {
      var s = this.trim().s.replace(/(\-|_|\s)+(.)?/g, function(mathc, sep, c) {
        return (c ? c.toUpperCase() : '');
      });
      return new this.constructor(s);
    },

    capitalize: function() {
      return new this.constructor(this.s.substr(0, 1).toUpperCase() + this.s.substring(1).toLowerCase());
    },

    charAt: function(index) {
      return this.s.charAt(index);
    },

    chompLeft: function(prefix) {
      var s = this.s;
      if (s.indexOf(prefix) === 0) {
         s = s.slice(prefix.length);
         return new this.constructor(s);
      } else {
        return this;
      }
    },

    chompRight: function(suffix) {
      if (this.endsWith(suffix)) {
        var s = this.s;
        s = s.slice(0, s.length - suffix.length);
        return new this.constructor(s);
      } else {
        return this;
      }
    },

    //#thanks Google
    collapseWhitespace: function() {
      var s = this.s.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
      return new this.constructor(s);
    },

    contains: function(ss) {
      return this.s.indexOf(ss) >= 0;
    },

    count: function(ss) {
      return require('./_count')(this.s, ss)
    },

    //#modified from https://github.com/epeli/underscore.string
    dasherize: function() {
      var s = this.trim().s.replace(/[_\s]+/g, '-').replace(/([A-Z])/g, '-$1').replace(/-+/g, '-').toLowerCase();
      return new this.constructor(s);
    },

    equalsIgnoreCase: function(prefix) {
      var s = this.s;
      return s.toLowerCase() == prefix.toLowerCase()
    },

    latinise: function() {
      var s = this.replace(/[^A-Za-z0-9\[\] ]/g, function(x) { return latin_map[x] || x; });
      return new this.constructor(s);
    },

    decodeHtmlEntities: function() { //https://github.com/substack/node-ent/blob/master/index.js
      var s = this.s;
      s = s.replace(/&#(\d+);?/g, function (_, code) {
        return String.fromCharCode(code);
      })
      .replace(/&#[xX]([A-Fa-f0-9]+);?/g, function (_, hex) {
        return String.fromCharCode(parseInt(hex, 16));
      })
      .replace(/&([^;\W]+;?)/g, function (m, e) {
        var ee = e.replace(/;$/, '');
        var target = ENTITIES[e] || (e.match(/;$/) && ENTITIES[ee]);

        if (typeof target === 'number') {
          return String.fromCharCode(target);
        }
        else if (typeof target === 'string') {
          return target;
        }
        else {
          return m;
        }
      })

      return new this.constructor(s);
    },

    endsWith: function() {
      var suffixes = Array.prototype.slice.call(arguments, 0);
      for (var i = 0; i < suffixes.length; ++i) {
        var l  = this.s.length - suffixes[i].length;
        if (l >= 0 && this.s.indexOf(suffixes[i], l) === l) return true;
      }
      return false;
    },

    escapeHTML: function() { //from underscore.string
      return new this.constructor(this.s.replace(/[&<>"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; }));
    },

    ensureLeft: function(prefix) {
      var s = this.s;
      if (s.indexOf(prefix) === 0) {
        return this;
      } else {
        return new this.constructor(prefix + s);
      }
    },

    ensureRight: function(suffix) {
      var s = this.s;
      if (this.endsWith(suffix))  {
        return this;
      } else {
        return new this.constructor(s + suffix);
      }
    },

    humanize: function() { //modified from underscore.string
      if (this.s === null || this.s === undefined)
        return new this.constructor('')
      var s = this.underscore().replace(/_id$/,'').replace(/_/g, ' ').trim().capitalize()
      return new this.constructor(s)
    },

    isAlpha: function() {
      return !/[^a-z\xDF-\xFF]|^$/.test(this.s.toLowerCase());
    },

    isAlphaNumeric: function() {
      return !/[^0-9a-z\xDF-\xFF]/.test(this.s.toLowerCase());
    },

    isEmpty: function() {
      return this.s === null || this.s === undefined ? true : /^[\s\xa0]*$/.test(this.s);
    },

    isLower: function() {
      return this.isAlpha() && this.s.toLowerCase() === this.s;
    },

    isNumeric: function() {
      return !/[^0-9]/.test(this.s);
    },

    isUpper: function() {
      return this.isAlpha() && this.s.toUpperCase() === this.s;
    },

    left: function(N) {
      if (N >= 0) {
        var s = this.s.substr(0, N);
        return new this.constructor(s);
      } else {
        return this.right(-N);
      }
    },

    lines: function() { //convert windows newlines to unix newlines then convert to an Array of lines
      return this.replaceAll('\r\n', '\n').s.split('\n');
    },

    pad: function(len, ch) { //https://github.com/component/pad
      if (ch == null) ch = ' ';
      if (this.s.length >= len) return new this.constructor(this.s);
      len = len - this.s.length;
      var left = Array(Math.ceil(len / 2) + 1).join(ch);
      var right = Array(Math.floor(len / 2) + 1).join(ch);
      return new this.constructor(left + this.s + right);
    },

    padLeft: function(len, ch) { //https://github.com/component/pad
      if (ch == null) ch = ' ';
      if (this.s.length >= len) return new this.constructor(this.s);
      return new this.constructor(Array(len - this.s.length + 1).join(ch) + this.s);
    },

    padRight: function(len, ch) { //https://github.com/component/pad
      if (ch == null) ch = ' ';
      if (this.s.length >= len) return new this.constructor(this.s);
      return new this.constructor(this.s + Array(len - this.s.length + 1).join(ch));
    },

    parseCSV: function(delimiter, qualifier, escape, lineDelimiter) { //try to parse no matter what
      delimiter = delimiter || ',';
      escape = escape || '\\'
      if (typeof qualifier == 'undefined')
        qualifier = '"';

      var i = 0, fieldBuffer = [], fields = [], len = this.s.length, inField = false, inUnqualifiedString = false, self = this;
      var ca = function(i){return self.s.charAt(i)};
      if (typeof lineDelimiter !== 'undefined') var rows = [];

      if (!qualifier)
        inField = true;

      while (i < len) {
        var current = ca(i);
        switch (current) {
          case escape:
            //fix for issues #32 and #35
            if (inField && ((escape !== qualifier) || ca(i+1) === qualifier)) {
              i += 1;
              fieldBuffer.push(ca(i));
              break;
            }
            if (escape !== qualifier) break;
          case qualifier:
            inField = !inField;
            break;
          case delimiter:
            if(inUnqualifiedString) {
              inField=false;
              inUnqualifiedString=false;
            }
            if (inField && qualifier)
              fieldBuffer.push(current);
            else {
              fields.push(fieldBuffer.join(''))
              fieldBuffer.length = 0;
            }
            break;
          case lineDelimiter:
            if(inUnqualifiedString) {
              inField=false;
              inUnqualifiedString=false;
              fields.push(fieldBuffer.join(''))
              rows.push(fields);
              fields = [];
              fieldBuffer.length = 0;
            }
            else if (inField) {
              fieldBuffer.push(current);
            } else {
              if (rows) {
                fields.push(fieldBuffer.join(''))
                rows.push(fields);
                fields = [];
                fieldBuffer.length = 0;
              }
            }
            break;
          case ' ':
            if (inField)
              fieldBuffer.push(current);
            break;
          default:
            if (inField)
              fieldBuffer.push(current);
            else if(current!==qualifier) {
              fieldBuffer.push(current);
              inField=true;
              inUnqualifiedString=true;
            }
            break;
        }
        i += 1;
      }

      fields.push(fieldBuffer.join(''));
      if (rows) {
        rows.push(fields);
        return rows;
      }
      return fields;
    },

    replaceAll: function(ss, r) {
      //var s = this.s.replace(new RegExp(ss, 'g'), r);
      var s = this.s.split(ss).join(r)
      return new this.constructor(s);
    },

    splitLeft: function(sep, maxSplit, limit) {
      return require('./_splitLeft')(this.s, sep, maxSplit, limit)
    },

    splitRight: function(sep, maxSplit, limit) {
      return require('./_splitRight')(this.s, sep, maxSplit, limit)
    },

    strip: function() {
      var ss = this.s;
      for(var i= 0, n=arguments.length; i<n; i++) {
        ss = ss.split(arguments[i]).join('');
      }
      return new this.constructor(ss);
    },

    stripLeft: function (chars) {
      var regex;
      var pattern;
      var ss = ensureString(this.s);

      if (chars === undefined) {
        pattern = /^\s+/g;
      }
      else {
        regex = escapeRegExp(chars);
        pattern = new RegExp("^[" + regex + "]+", "g");
      }

      return new this.constructor(ss.replace(pattern, ""));
    },

    stripRight: function (chars) {
      var regex;
      var pattern;
      var ss = ensureString(this.s);

      if (chars === undefined) {
        pattern = /\s+$/g;
      }
      else {
        regex = escapeRegExp(chars);
        pattern = new RegExp("[" + regex + "]+$", "g");
      }

      return new this.constructor(ss.replace(pattern, ""));
    },

    right: function(N) {
      if (N >= 0) {
        var s = this.s.substr(this.s.length - N, N);
        return new this.constructor(s);
      } else {
        return this.left(-N);
      }
    },

    setValue: function (s) {
	  initialize(this, s);
	  return this;
    },

    slugify: function() {
      var sl = (new S(new S(this.s).latinise().s.replace(/[^\w\s-]/g, '').toLowerCase())).dasherize().s;
      if (sl.charAt(0) === '-')
        sl = sl.substr(1);
      return new this.constructor(sl);
    },

    startsWith: function() {
      var prefixes = Array.prototype.slice.call(arguments, 0);
      for (var i = 0; i < prefixes.length; ++i) {
        if (this.s.lastIndexOf(prefixes[i], 0) === 0) return true;
      }
      return false;
    },

    stripPunctuation: function() {
      //return new this.constructor(this.s.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g,""));
      return new this.constructor(this.s.replace(/[^\w\s]|_/g, "").replace(/\s+/g, " "));
    },

    stripTags: function() { //from sugar.js
      var s = this.s, args = arguments.length > 0 ? arguments : [''];
      multiArgs(args, function(tag) {
        s = s.replace(RegExp('<\/?' + tag + '[^<>]*>', 'gi'), '');
      });
      return new this.constructor(s);
    },

    template: function(values, opening, closing) {
      var s = this.s
      var opening = opening || Export.TMPL_OPEN
      var closing = closing || Export.TMPL_CLOSE

      var open = opening.replace(/[-[\]()*\s]/g, "\\$&").replace(/\$/g, '\\$')
      var close = closing.replace(/[-[\]()*\s]/g, "\\$&").replace(/\$/g, '\\$')
      var r = new RegExp(open + '(.+?)' + close, 'g')
        //, r = /\{\{(.+?)\}\}/g
      var matches = s.match(r) || [];

      matches.forEach(function(match) {
        var key = match.substring(opening.length, match.length - closing.length).trim();//chop {{ and }}
        var value = typeof values[key] == 'undefined' ? '' : values[key];
        s = s.replace(match, value);
      });
      return new this.constructor(s);
    },

    times: function(n) {
      return new this.constructor(new Array(n + 1).join(this.s));
    },

    titleCase: function() {
      var s = this.s;
      if (s) {
        s = s.replace(/(^[a-z]| [a-z]|-[a-z]|_[a-z])/g,
          function($1){
            return $1.toUpperCase();
          }
        );
      }
      return new this.constructor(s);
    },

    toBoolean: function() {
      if (typeof this.orig === 'string') {
        var s = this.s.toLowerCase();
        return s === 'true' || s === 'yes' || s === 'on' || s === '1';
      } else
        return this.orig === true || this.orig === 1;
    },

    toFloat: function(precision) {
      var num = parseFloat(this.s)
      if (precision)
        return parseFloat(num.toFixed(precision))
      else
        return num
    },

    toInt: function() { //thanks Google
      // If the string starts with '0x' or '-0x', parse as hex.
      return /^\s*-?0x/i.test(this.s) ? parseInt(this.s, 16) : parseInt(this.s, 10)
    },

    trim: function() {
      var s;
      if (typeof __nsp.trim === 'undefined')
        s = this.s.replace(/(^\s*|\s*$)/g, '')
      else
        s = this.s.trim()
      return new this.constructor(s);
    },

    trimLeft: function() {
      var s;
      if (__nsp.trimLeft)
        s = this.s.trimLeft();
      else
        s = this.s.replace(/(^\s*)/g, '');
      return new this.constructor(s);
    },

    trimRight: function() {
      var s;
      if (__nsp.trimRight)
        s = this.s.trimRight();
      else
        s = this.s.replace(/\s+$/, '');
      return new this.constructor(s);
    },

    truncate: function(length, pruneStr) { //from underscore.string, author: github.com/rwz
      var str = this.s;

      length = ~~length;
      pruneStr = pruneStr || '...';

      if (str.length <= length) return new this.constructor(str);

      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },
        template = str.slice(0, length+1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

      if (template.slice(template.length-2).match(/\w\w/))
        template = template.replace(/\s*\S+$/, '');
      else
        template = new S(template.slice(0, template.length-1)).trimRight().s;

      return (template+pruneStr).length > str.length ? new S(str) : new S(str.slice(0, template.length)+pruneStr);
    },

    toCSV: function() {
      var delim = ',', qualifier = '"', escape = '\\', encloseNumbers = true, keys = false;
      var dataArray = [];

      function hasVal(it) {
        return it !== null && it !== '';
      }

      if (typeof arguments[0] === 'object') {
        delim = arguments[0].delimiter || delim;
        delim = arguments[0].separator || delim;
        qualifier = arguments[0].qualifier || qualifier;
        encloseNumbers = !!arguments[0].encloseNumbers;
        escape = arguments[0].escape || escape;
        keys = !!arguments[0].keys;
      } else if (typeof arguments[0] === 'string') {
        delim = arguments[0];
      }

      if (typeof arguments[1] === 'string')
        qualifier = arguments[1];

      if (arguments[1] === null)
        qualifier = null;

       if (this.orig instanceof Array)
        dataArray  = this.orig;
      else { //object
        for (var key in this.orig)
          if (this.orig.hasOwnProperty(key))
            if (keys)
              dataArray.push(key);
            else
              dataArray.push(this.orig[key]);
      }

      var rep = escape + qualifier;
      var buildString = [];
      for (var i = 0; i < dataArray.length; ++i) {
        var shouldQualify = hasVal(qualifier)
        if (typeof dataArray[i] == 'number')
          shouldQualify &= encloseNumbers;

        if (shouldQualify)
          buildString.push(qualifier);

        if (dataArray[i] !== null && dataArray[i] !== undefined) {
          var d = new S(dataArray[i]).replaceAll(qualifier, rep).s;
          buildString.push(d);
        } else
          buildString.push('')

        if (shouldQualify)
          buildString.push(qualifier);

        if (delim)
          buildString.push(delim);
      }

      //chop last delim
      //console.log(buildString.length)
      buildString.length = buildString.length - 1;
      return new this.constructor(buildString.join(''));
    },

    toString: function() {
      return this.s;
    },

    //#modified from https://github.com/epeli/underscore.string
    underscore: function() {
      var s = this.trim().s.replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/([A-Z\d]+)([A-Z][a-z])/g,'$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
      return new this.constructor(s);
    },

    unescapeHTML: function() { //from underscore.string
      return new this.constructor(this.s.replace(/\&([^;]+);/g, function(entity, entityCode){
        var match;

        if (entityCode in escapeChars) {
          return escapeChars[entityCode];
        } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
          return String.fromCharCode(parseInt(match[1], 16));
        } else if (match = entityCode.match(/^#(\d+)$/)) {
          return String.fromCharCode(~~match[1]);
        } else {
          return entity;
        }
      }));
    },

    valueOf: function() {
      return this.s.valueOf();
    },

    //#Added a New Function called wrapHTML.
    wrapHTML: function (tagName, tagAttrs) {
      var s = this.s, el = (tagName == null) ? 'span' : tagName, elAttr = '', wrapped = '';
      if(typeof tagAttrs == 'object') for(var prop in tagAttrs) elAttr += ' ' + prop + '="' +(new this.constructor(tagAttrs[prop])).escapeHTML() + '"';
      s = wrapped.concat('<', el, elAttr, '>', this, '</', el, '>');
      return new this.constructor(s);
    }
  }

  var methodsAdded = [];
  function extendPrototype() {
    for (var name in __sp) {
      (function(name){
        var func = __sp[name];
        if (!__nsp.hasOwnProperty(name)) {
          methodsAdded.push(name);
          __nsp[name] = function() {
            String.prototype.s = this;
            return func.apply(this, arguments);
          }
        }
      })(name);
    }
  }

  function restorePrototype() {
    for (var i = 0; i < methodsAdded.length; ++i)
      delete String.prototype[methodsAdded[i]];
    methodsAdded.length = 0;
  }


/*************************************
/* Attach Native JavaScript String Properties
/*************************************/

  var nativeProperties = getNativeStringProperties();
  for (var name in nativeProperties) {
    (function(name) {
      var stringProp = __nsp[name];
      if (typeof stringProp == 'function') {
        //console.log(stringProp)
        if (!__sp[name]) {
          if (nativeProperties[name] === 'string') {
            __sp[name] = function() {
              //console.log(name)
              return new this.constructor(stringProp.apply(this, arguments));
            }
          } else {
            __sp[name] = stringProp;
          }
        }
      }
    })(name);
  }


/*************************************
/* Function Aliases
/*************************************/

  __sp.repeat = __sp.times;
  __sp.include = __sp.contains;
  __sp.toInteger = __sp.toInt;
  __sp.toBool = __sp.toBoolean;
  __sp.decodeHTMLEntities = __sp.decodeHtmlEntities //ensure consistent casing scheme of 'HTML'


//******************************************************************************
// Set the constructor.  Without this, string.js objects are instances of
// Object instead of S.
//******************************************************************************

  __sp.constructor = S;


/*************************************
/* Private Functions
/*************************************/

  function getNativeStringProperties() {
    var names = getNativeStringPropertyNames();
    var retObj = {};

    for (var i = 0; i < names.length; ++i) {
      var name = names[i];
      if (name === 'to' || name === 'toEnd') continue;       // get rid of the shelljs prototype messup
      var func = __nsp[name];
      try {
        var type = typeof func.apply('teststring');
        retObj[name] = type;
      } catch (e) {}
    }
    return retObj;
  }

  function getNativeStringPropertyNames() {
    var results = [];
    if (Object.getOwnPropertyNames) {
      results = Object.getOwnPropertyNames(__nsp);
      results.splice(results.indexOf('valueOf'), 1);
      results.splice(results.indexOf('toString'), 1);
      return results;
    } else { //meant for legacy cruft, this could probably be made more efficient
      var stringNames = {};
      var objectNames = [];
      for (var name in String.prototype)
        stringNames[name] = name;

      for (var name in Object.prototype)
        delete stringNames[name];

      //stringNames['toString'] = 'toString'; //this was deleted with the rest of the object names
      for (var name in stringNames) {
        results.push(name);
      }
      return results;
    }
  }

  function Export(str) {
    return new S(str);
  };

  //attach exports to StringJSWrapper
  Export.extendPrototype = extendPrototype;
  Export.restorePrototype = restorePrototype;
  Export.VERSION = VERSION;
  Export.TMPL_OPEN = '{{';
  Export.TMPL_CLOSE = '}}';
  Export.ENTITIES = ENTITIES;



/*************************************
/* Exports
/*************************************/

  if (typeof module !== 'undefined'  && typeof module.exports !== 'undefined') {
    module.exports = Export;

  } else {

    if(typeof define === "function" && define.amd) {
      define([], function() {
        return Export;
      });
    } else {
      window.S = Export;
    }
  }


/*************************************
/* 3rd Party Private Functions
/*************************************/

  //from sugar.js
  function multiArgs(args, fn) {
    var result = [], i;
    for(i = 0; i < args.length; i++) {
      result.push(args[i]);
      if(fn) fn.call(args, args[i], i);
    }
    return result;
  }

  //from underscore.string
  var escapeChars = {
    lt: '<',
    gt: '>',
    quot: '"',
    apos: "'",
    amp: '&'
  };

  function escapeRegExp (s) {
    // most part from https://github.com/skulpt/skulpt/blob/ecaf75e69c2e539eff124b2ab45df0b01eaf2295/src/str.js#L242
    var c;
    var i;
    var ret = [];
    var re = /^[A-Za-z0-9]+$/;
    s = ensureString(s);
    for (i = 0; i < s.length; ++i) {
      c = s.charAt(i);

      if (re.test(c)) {
        ret.push(c);
      }
      else {
        if (c === "\\000") {
          ret.push("\\000");
        }
        else {
          ret.push("\\" + c);
        }
      }
    }
    return ret.join("");
  }

  function ensureString(string) {
    return string == null ? '' : '' + string;
  }

  //from underscore.string
  var reversedEscapeChars = {};
  for(var key in escapeChars){ reversedEscapeChars[escapeChars[key]] = key; }

  ENTITIES = {
    "amp" : "&",
    "gt" : ">",
    "lt" : "<",
    "quot" : "\"",
    "apos" : "'",
    "AElig" : 198,
    "Aacute" : 193,
    "Acirc" : 194,
    "Agrave" : 192,
    "Aring" : 197,
    "Atilde" : 195,
    "Auml" : 196,
    "Ccedil" : 199,
    "ETH" : 208,
    "Eacute" : 201,
    "Ecirc" : 202,
    "Egrave" : 200,
    "Euml" : 203,
    "Iacute" : 205,
    "Icirc" : 206,
    "Igrave" : 204,
    "Iuml" : 207,
    "Ntilde" : 209,
    "Oacute" : 211,
    "Ocirc" : 212,
    "Ograve" : 210,
    "Oslash" : 216,
    "Otilde" : 213,
    "Ouml" : 214,
    "THORN" : 222,
    "Uacute" : 218,
    "Ucirc" : 219,
    "Ugrave" : 217,
    "Uuml" : 220,
    "Yacute" : 221,
    "aacute" : 225,
    "acirc" : 226,
    "aelig" : 230,
    "agrave" : 224,
    "aring" : 229,
    "atilde" : 227,
    "auml" : 228,
    "ccedil" : 231,
    "eacute" : 233,
    "ecirc" : 234,
    "egrave" : 232,
    "eth" : 240,
    "euml" : 235,
    "iacute" : 237,
    "icirc" : 238,
    "igrave" : 236,
    "iuml" : 239,
    "ntilde" : 241,
    "oacute" : 243,
    "ocirc" : 244,
    "ograve" : 242,
    "oslash" : 248,
    "otilde" : 245,
    "ouml" : 246,
    "szlig" : 223,
    "thorn" : 254,
    "uacute" : 250,
    "ucirc" : 251,
    "ugrave" : 249,
    "uuml" : 252,
    "yacute" : 253,
    "yuml" : 255,
    "copy" : 169,
    "reg" : 174,
    "nbsp" : 160,
    "iexcl" : 161,
    "cent" : 162,
    "pound" : 163,
    "curren" : 164,
    "yen" : 165,
    "brvbar" : 166,
    "sect" : 167,
    "uml" : 168,
    "ordf" : 170,
    "laquo" : 171,
    "not" : 172,
    "shy" : 173,
    "macr" : 175,
    "deg" : 176,
    "plusmn" : 177,
    "sup1" : 185,
    "sup2" : 178,
    "sup3" : 179,
    "acute" : 180,
    "micro" : 181,
    "para" : 182,
    "middot" : 183,
    "cedil" : 184,
    "ordm" : 186,
    "raquo" : 187,
    "frac14" : 188,
    "frac12" : 189,
    "frac34" : 190,
    "iquest" : 191,
    "times" : 215,
    "divide" : 247,
    "OElig;" : 338,
    "oelig;" : 339,
    "Scaron;" : 352,
    "scaron;" : 353,
    "Yuml;" : 376,
    "fnof;" : 402,
    "circ;" : 710,
    "tilde;" : 732,
    "Alpha;" : 913,
    "Beta;" : 914,
    "Gamma;" : 915,
    "Delta;" : 916,
    "Epsilon;" : 917,
    "Zeta;" : 918,
    "Eta;" : 919,
    "Theta;" : 920,
    "Iota;" : 921,
    "Kappa;" : 922,
    "Lambda;" : 923,
    "Mu;" : 924,
    "Nu;" : 925,
    "Xi;" : 926,
    "Omicron;" : 927,
    "Pi;" : 928,
    "Rho;" : 929,
    "Sigma;" : 931,
    "Tau;" : 932,
    "Upsilon;" : 933,
    "Phi;" : 934,
    "Chi;" : 935,
    "Psi;" : 936,
    "Omega;" : 937,
    "alpha;" : 945,
    "beta;" : 946,
    "gamma;" : 947,
    "delta;" : 948,
    "epsilon;" : 949,
    "zeta;" : 950,
    "eta;" : 951,
    "theta;" : 952,
    "iota;" : 953,
    "kappa;" : 954,
    "lambda;" : 955,
    "mu;" : 956,
    "nu;" : 957,
    "xi;" : 958,
    "omicron;" : 959,
    "pi;" : 960,
    "rho;" : 961,
    "sigmaf;" : 962,
    "sigma;" : 963,
    "tau;" : 964,
    "upsilon;" : 965,
    "phi;" : 966,
    "chi;" : 967,
    "psi;" : 968,
    "omega;" : 969,
    "thetasym;" : 977,
    "upsih;" : 978,
    "piv;" : 982,
    "ensp;" : 8194,
    "emsp;" : 8195,
    "thinsp;" : 8201,
    "zwnj;" : 8204,
    "zwj;" : 8205,
    "lrm;" : 8206,
    "rlm;" : 8207,
    "ndash;" : 8211,
    "mdash;" : 8212,
    "lsquo;" : 8216,
    "rsquo;" : 8217,
    "sbquo;" : 8218,
    "ldquo;" : 8220,
    "rdquo;" : 8221,
    "bdquo;" : 8222,
    "dagger;" : 8224,
    "Dagger;" : 8225,
    "bull;" : 8226,
    "hellip;" : 8230,
    "permil;" : 8240,
    "prime;" : 8242,
    "Prime;" : 8243,
    "lsaquo;" : 8249,
    "rsaquo;" : 8250,
    "oline;" : 8254,
    "frasl;" : 8260,
    "euro;" : 8364,
    "image;" : 8465,
    "weierp;" : 8472,
    "real;" : 8476,
    "trade;" : 8482,
    "alefsym;" : 8501,
    "larr;" : 8592,
    "uarr;" : 8593,
    "rarr;" : 8594,
    "darr;" : 8595,
    "harr;" : 8596,
    "crarr;" : 8629,
    "lArr;" : 8656,
    "uArr;" : 8657,
    "rArr;" : 8658,
    "dArr;" : 8659,
    "hArr;" : 8660,
    "forall;" : 8704,
    "part;" : 8706,
    "exist;" : 8707,
    "empty;" : 8709,
    "nabla;" : 8711,
    "isin;" : 8712,
    "notin;" : 8713,
    "ni;" : 8715,
    "prod;" : 8719,
    "sum;" : 8721,
    "minus;" : 8722,
    "lowast;" : 8727,
    "radic;" : 8730,
    "prop;" : 8733,
    "infin;" : 8734,
    "ang;" : 8736,
    "and;" : 8743,
    "or;" : 8744,
    "cap;" : 8745,
    "cup;" : 8746,
    "int;" : 8747,
    "there4;" : 8756,
    "sim;" : 8764,
    "cong;" : 8773,
    "asymp;" : 8776,
    "ne;" : 8800,
    "equiv;" : 8801,
    "le;" : 8804,
    "ge;" : 8805,
    "sub;" : 8834,
    "sup;" : 8835,
    "nsub;" : 8836,
    "sube;" : 8838,
    "supe;" : 8839,
    "oplus;" : 8853,
    "otimes;" : 8855,
    "perp;" : 8869,
    "sdot;" : 8901,
    "lceil;" : 8968,
    "rceil;" : 8969,
    "lfloor;" : 8970,
    "rfloor;" : 8971,
    "lang;" : 9001,
    "rang;" : 9002,
    "loz;" : 9674,
    "spades;" : 9824,
    "clubs;" : 9827,
    "hearts;" : 9829,
    "diams;" : 9830
  }


}).call(this);

},{"./_count":1724,"./_splitLeft":1725,"./_splitRight":1726}],1728:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],1729:[function(require,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1730:[function(require,module,exports){

module.exports = require('./lib/urlsafe-base64');
},{"./lib/urlsafe-base64":1731}],1731:[function(require,module,exports){
(function (Buffer){
/*!
 * urlsafe-base64
 */

/**
 * Module Dependencies
 */

// None yet!

/**
 * Library version.
 */

exports.version = '1.0.0';

/**
 * .encode
 *
 * return an encoded Buffer as URL Safe Base64
 *
 * Note: This function encodes to the RFC 4648 Spec where '+' is encoded
 *       as '-' and '/' is encoded as '_'. The padding character '=' is
 *       removed.
 *
 * @param {Buffer} buffer
 * @return {String}
 * @api public
 */

exports.encode = function encode(buffer) {

  return buffer.toString('base64')
    .replace(/\+/g, '-') // Convert '+' to '-'
    .replace(/\//g, '_') // Convert '/' to '_'
    .replace(/=+$/, ''); // Remove ending '='

};

/**
 * .decode
 *
 * return an decoded URL Safe Base64 as Buffer
 *
 * @param {String}
 * @return {Buffer}
 * @api public
 */

exports.decode = function decode(base64) {

  // Add removed at end '='
  base64 += Array(5 - base64.length % 4).join('=');

  base64 = base64
    .replace(/\-/g, '+') // Convert '-' to '+'
    .replace(/\_/g, '/'); // Convert '_' to '/'

  return new Buffer(base64, 'base64');

};

/**
 * .validate
 *
 * Validates a string if it is URL Safe Base64 encoded.
 *
 * @param {String}
 * @return {Boolean}
 * @api public
 */

exports.validate = function validate(base64) {

  return /^[A-Za-z0-9\-_]+$/.test(base64);

};
}).call(this,require("buffer").Buffer)
},{"buffer":1735}],1732:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],1733:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],1734:[function(require,module,exports){
arguments[4][997][0].apply(exports,arguments)
},{"dup":997}],1735:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":1733,"ieee754":1738}],1736:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":1740}],1737:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],1738:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],1739:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],1740:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],1741:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],1742:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":1743}],1743:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],1744:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1745:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],1746:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],1747:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":1745,"./encode":1746}],1748:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":1749}],1749:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":1751,"./_stream_writable":1753,"core-util-is":1736,"inherits":1739,"process-nextick-args":1742}],1750:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":1752,"core-util-is":1736,"inherits":1739}],1751:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":1749,"./internal/streams/BufferList":1754,"./internal/streams/destroy":1755,"./internal/streams/stream":1756,"_process":1743,"core-util-is":1736,"events":1737,"inherits":1739,"isarray":1741,"process-nextick-args":1742,"safe-buffer":1761,"string_decoder/":1763,"util":1734}],1752:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":1749,"core-util-is":1736,"inherits":1739}],1753:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":1749,"./internal/streams/destroy":1755,"./internal/streams/stream":1756,"_process":1743,"core-util-is":1736,"inherits":1739,"process-nextick-args":1742,"safe-buffer":1761,"timers":1764,"util-deprecate":1767}],1754:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":1761,"util":1734}],1755:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":1742}],1756:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":1737}],1757:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":1758}],1758:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":1749,"./lib/_stream_passthrough.js":1750,"./lib/_stream_readable.js":1751,"./lib/_stream_transform.js":1752,"./lib/_stream_writable.js":1753}],1759:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":1758}],1760:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":1753}],1761:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":1735}],1762:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":1737,"inherits":1739,"readable-stream/duplex.js":1748,"readable-stream/passthrough.js":1757,"readable-stream/readable.js":1758,"readable-stream/transform.js":1759,"readable-stream/writable.js":1760}],1763:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":1761}],1764:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":1743,"timers":1764}],1765:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":1766,"punycode":1744,"querystring":1747}],1766:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],1767:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1768:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],1769:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":1768,"_process":1743,"inherits":1739}]},{},[1]);
